<!DOCTYPE html>	
<html lang="en" xml:lang="en">
<head>
<title>overwritten</title>
		<script src='js/respec.js' class='remove'></script>
		<!-- <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js' class='remove'></script> -->
		<script class='remove'>				
		
		var respecConfig = {
					 
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "OIPF-FINAL",
		  
		  OIPFrelease: "2",	
		  OIPFversion: "2.3",
		  OIPFvolume: "5",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "volume5",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
		  title:"Declarative Application Environment",
          subtitle   :  "",

          // if you wish the publication date to be other than today, set this
           publishDate:  "2014-01-24",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          //copyrightStart: "2005",
		
		  //additionalCopyrightHolders: "",
		  
		  overrideCopyright: " ",
		  
		  
          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",



          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Editor", url: "contact@oipf.tv",
                company: "Open IPTV Forum", companyURL: "http://www.oipf.tv/" },
          ],
		  
          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],
          
          // name of the WG
          wg:           "OIPF Solutions WG",
          
          // URI of the public WG page
          wgURI:        "http://www.oipf.tv",
          
          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "contact@oipf.tv",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          		  
		  maxTocLevel:	3,
		  maxSectionNumberingLevel: 9,
		  
				
		  localBiblio: {
			"CEA-2014-A": "CEA, CEA-2014-A, \"Web-based Protocol Framework for Remote User Interface on UPnP Networks and the Internet (Web4CE)\", (including the August 2008 Errata)",
			
			"EN300468" : "ETSI EN 300 468 V1.9.1 (2008-11), \"Digital Video Broadcasting (DVB); Specification for Service Information (SI) in DVB systems\".<br>Also available as DVB Bluebook A38 (09/2012)",

			"Widgets-Packaging":"W3C, \"<a href=http://www.w3.org/TR/2011/REC-widgets-20110927/>Widget Packaging and XML Configuration</a>\", W3C Recommendation 27 September 2011",
			"Widgets-Access":"W3C, \"<a href=http://www.w3.org/TR/2012/REC-widgets-access-20120207/>Widget Access Request Policy</a>\", W3C Recommendation 7 February 2012.",
			"Widgets-APIs":"W3C, \"<a href=http://www.w3.org/TR/2011/CR-widgets-apis-20111213/>Widget Interface</a>\", W3C Candidate Recommendation 13 December 2011",
			"Web-Storage":"W3C, \"<a href=http://www.w3.org/TR/2011/CR-webstorage-20111208/>Web Storage</a>\", W3C Candidate Recommendation 08 December 2011",
			"Widgets-DigSig":"W3C, \"<a href=http://www.w3.org/TR/2011/PR-widgets-digsig-20110811/>XML Digital Signatures for Widgets</a>\", W3C Proposed Recommendation 11 August 2011",
			
			"DASH":"ISO/IEC 23009-1, Information technology &mdash; Dynamic adaptive streaming over HTTP (DASH) &mdash; Part 1: Media presentation description and segment formats",
			"DLNA":"DLNA Networked Device Interoperability Guidelines, August 2009",
			
			"TIMING-CONTROL":"W3C, Timing control for script-based animations, W3C Working Draft 21 February 2012",
			
			"TS102539":"ETSI TS 102 539, \"Digital Video Broadcasting (DVB); Carriage of Broadband Content Guide (BCG) information over Internet Protocol (IP)\"",
			
			"3GPPTS24.229":"3GPP, TS 24.229, \"IP Multimedia Call Control Protocol based on Session Initiation Protocol (SIP) and Session Description Protocol (SDP) Stage 3 (Release 8)\"",
			
			"TS102851":"ETSI TS 102 851, \"Digital Video Broadcasting (DVB); Uniform Resource Identifiers (URI) for DVB Systems\"",
			
			"ISO639-2":"ISO 639-2:1998 Codes for the representation of names of languages &mdash; Part 2: Alpha-3 code",
			"TS101154":"ETSI TS 101 154, \"Digital Video Broadcasting (DVB);Specification for the use of Video and Audio Coding in Broadcasting Applications based on the MPEG-2 Transport Stream\"",
			"TS102822-3-1":"ETSI TS 102 822-3-1, \"Broadcast and On-line Services: Search, select and rightful use of content on personal storage systems (\"TV-Anytime\"); Part 3: Metadata; Sub-part 1: Phase 1 - Metadata schemas\"",
			
			"PRES":"OMA, OMA-TS-Presence_SIMPLE_XDM-V1_1-20080627-A, \"Presence XDM Specification\"",
			"IM":"OMA, OMA-TS-SIMPLE_IM-V1_0-20080820-D, \"Instant Messaging using SIMPLE\"",
			
			"TISPAN":"ETSI TS 183 063, \"Telecommunications and Internet converged Services and Protocols for Advanced Networking (TISPAN);IMS-based IPTV stage 3 specification\"",
			
			"MPEG-7":"ISO/IEC 15938-5, \"Multimedia Content Description Interface - Part 5:Multimedia description schemes\", May 2003",
			"IEC62455":"IEC, IEC 62455, \"Internet protocol (IP) and transport stream (TS) based service access\"",
			
			"TS102323":"ETSI TS 102 323, \"Digital Video Broadcasting (DVB);Carriage and signalling of TV-Anytime information in DVB transport streams\"",
			"TS102796":"ETSI TS 102 796, \"Hybrid Broadcast-Broadband TV\"",
			"DVB-IPTV":"ETSI TS 102 034 V1.4.1, \"DVB-IPTV 1.4: Transport of MPEG-2 TS Based DVB Services over IP Based Networks (and associated XML)\"",
			
			"Media-Fragments-URI":"W3C, \"<a href=http://www.w3.org/TR/media-frags>Media Fragments URI 1.0</a>\", Recommendation 25 September 2012",
			"MEDIA_FRAGMENTS_HTTP":"W3C, \"<a href=http://www.w3.org/TR/2011/WD-media-frags-recipes-20111201/>Protocol for Media Fragments 1.0 Resolution in HTTP</a>\", W3C Working Draft 1 December 2011",
		  },
      };
      
		</script>

<link rel="stylesheet" href="styles/oipf-dae-spec.css" type="text/css" />
</head>
<body>
<section id="abstract">
<p>This Technical Specification (TS) has been produced by the Open IPTV Forum.</p>
<p>This specification provides multiple options for some features. The Open IPTV Forum Profiles specification complements the Release 2 specifications by defining the Open IPTV Forum implementation and deployment profiles.</p>
</section>
<section id='Introduction' class="introductory">
<h1>Introduction</h1>
The Open IPTV Forum Release 2 Specification consists of ten volumes: <ul>
<li>Volume 1 &mdash; Overview [[.OIPF_OVIEW2]],
<li>Volume 2 &mdash; Media Formats [[.OIPF_MEDIA2]],
<li>Volume 2a &mdash; HTTP Adaptive Streaming [[.OIPF_HAS2]],
<li>Volume 3 &mdash; Content Metadata [[.OIPF_META2]],
<li>Volume 4 &mdash; Protocols [[.OIPF_PROT2]],
<li>Volume 4a &mdash; Examples of IPTV Protocol Sequences [[.OIPF_PROT_EX2]],
<li>Volume 5 &mdash; Declarative Application Environment (the present volume),
<li>Volume 5a &mdash; Web Standards TV Profile [[.OIPF_WSTVP2]],
<li>Volume 6 &mdash; Procedural Application Environment [[.OIPF_PAE2]], and
<li>Volume 7 &mdash; Authentication, Content Protection and Service Protection [[.OIPF_CSP2]].
</ul>
<p>The present document, the Declarative Application Environment Specification (Volume 5), specifies the DAE functionality of the Open IPTV Forum Release 2 Solution.</p>
</section>


<section id='scope'>
<h1>Scope</h1>
<p>The Open IPTV Forum has developed an end-to-end solution to allow any consumer end-device, compliant to the Open IPTV Forum specifications, to access enriched and personalized IPTV services either in a managed or a non-managed network.</p>
<p>Its functional architecture specification [[.OIPF_ARCH2]] defines a block called OITF which resides inside the residential network. The OITF includes the functionality required to access IPTV services for both the unmanaged and the managed network.</p>
<p>Part of these functionalities is the <b>Declarative Application Environment (DAE)</b>: a declarative language based environment (browser) based on CEA-2014 [[!CEA-2014-A]] for presentation of user interfaces and including scripting support for interaction with network server-side applications and access to the APIs of the other OITF functions.</p>
<p>The DAE is the focus of this specification.<p>
<p>The requirements for specifying this functionality are derived from the following sources:</p><ul>
<li>Open IPTV Service and Platform Requirement for R2 [[.OIPF_REQS2]];
<li>Open IPTV Functional Architecture for R2 [[.OIPF_ARCH2]].
</ul>
</section>

<section id='references'>
<h1>References</h1>
</section>

<section>
<h1>Conventions and Terminology</h1>
<section id="conventions"><h2>Conventions</h2>
<p>All sections and appendixes, except &ldquo;Scope&rdquo; and &ldquo;Introduction&rdquo;, are normative, unless they are explicitly indicated to be informative.</p>
<p>The key words &ldquo;MUST&rdquo;, &ldquo;MUST NOT&rdquo;, &ldquo;REQUIRED&rdquo;, &ldquo;SHALL&rdquo;, &ldquo;SHALL NOT&rdquo;, &ldquo;SHOULD&rdquo;, &ldquo;SHOULD NOT&rdquo;, &ldquo;RECOMMENDED&rdquo;, &ldquo;MAY&rdquo;, and &ldquo;OPTIONAL&rdquo; in this document are to be interpreted as described in [[RFC2119]]. </p>
<p>In sections of the present document whose presence is indicated by one of the capabilities defined in section <a href="#client-capability-description" class="sectionRef"></a>, use of the [[RFC2119]] terms &ldquo;MUST&rdquo;, &ldquo;SHALL&rdquo; or &ldquo;REQUIRED&rdquo; applies only when the capability is made available to DAE applications. They do not have the effect of making that section mandatory.</p>
<p>In this document, &ldquo;application&rdquo; means &ldquo;declarative application&rdquo; (browser based application) throughout the DAE platform specification, as opposed to the &ldquo;procedural applications&rdquo; (Java based applications) defined in the PAE platform specification.</p>
<p>In the documented APIs JavaScript attributes are read-write unless otherwise specified.</p>
<p>The type &ldquo;<code><b>Integer</b></code>&rdquo; is not a valid JavaScript type as is. It is used as a short hand notation for a subset of type &ldquo;<code><b>Number</b></code>&rdquo; which includes only the numbers that can be written without a fractional or decimal component.</p>
</section>
<section><h2>Terminology</h2>
<section><h3>Definitions</h3>
<table class="definitions">
<tr><th>Term</th><th>Definition</th></tr>
<tr><td>Audio from memory</td><td>Audible notifications and audio clips intended to be played from memory.</td></tr>
<tr><td>Broadcast related application</td><td>Interactive application associated with a television or radio channel, with part of a television channel (e.g. a particular program or show) or other television content. Often referred to as &ldquo;red button&rdquo; applications in the industry, regardless of how they are actually started by the end user.</td></tr>
<tr><td>Broadcast independent application</td><td>Interactive application not related to any TV channel or TV content or to the currently selected service provider.</td></tr>
<tr><td>Control UI</td><td>The Remote UI that controls DAE applications in the OITF, sent from an IPTV Applications server via the OITF or pre-stored in the OITF, and rendered in the DLNA RUIC on the Remote Control Device.</td></tr>
<tr><td>DLNA RUIC</td><td>A DLNA device with the role of finding and loading remote UI content exposed by a DLNA RUIS capability and rendering and interacting with the UI content.<br />
Note: This terminology references the DLNA RUI specification.</td></tr>
<tr><td>DLNA RUIS</td><td>A DLNA Function in the OITF with the role of exposing and sourcing UI content.<br />
Note: This terminology references the DLNA RUI specification.</td></tr>
<tr><td>Embedded object</td><td>A software module that extends the capabilities of the OITF browser. Features provided by an embedded object are made available to DAE applications through the methods and properties of a specific JavaScript object.</td></tr>
<tr><td>HTML document</td><td>An XHTML document and associated style and script files conforming to the restrictions and extensions defined in the present document.</td></tr>
<tr><td>Key Event</td><td>Event sent to a DAE application in response to input from the end-user. This input is typically generated in response to the end-user pressing a button on a conventional remote control. It may also be generated by some other mechanism on alternative input devices such as game controllers, touch screens, wands or drastically reduced remote controls.</td></tr>
<tr><td>Mandatory</td><td>The feature is an absolute requirement of the specification (a &ldquo;MUST&rdquo; as defined by [[RFC2119]]).</td></tr>
<tr><td>MB or megabyte</td><td>2<sup>20</sup> bytes</td></tr>
<tr><td>Non-visual embedded object</td><td>A non-visual embedded object is an embedded object that has no visible representation and cannot get input focus</td></tr>
<tr><td>Optional</td><td>The feature is truly optional (a &ldquo;MAY&rdquo; as defined by [[RFC2119]])</td></tr>
<tr><td>Remote Control Device</td><td>A mobile or portable device which has the functionality of the DLNA RUIC.</td></tr>
<tr><td>Remote UI</td><td>The display of a UI from one device on a second (remote) device across a network.</td></tr>
<tr><td>Service provider related application</td><td>Interactive application related to the service provider selected through the service provider selection process.</td></tr>
<tr><td>Trick Mode</td><td>Facility to allow the User to control the playback of Content, such as pause, fast and slow playback, reverse playback, instant access, replay, forward and reverse skipping.</td></tr>
</table>
</section>
<section><h3>Abbreviations</h3>
<p>In addition to the Abbreviations provided in <a href="volume1.html#abbreviations" class="extRef">Volume 1</a>, the following abbreviations are used in this Volume.</p>
<table class="definitions">
<tr>
<th>Acronym</th><th>Explanation</th>
</tr>
<tr><td>AJAX</td><td>Asynchronous JavaScript and XML</td></tr>
<tr><td>CRID</td><td>Content Reference Identifier</td></tr>
<tr><td>CSS</td><td>Cascading style sheets</td></tr>
<tr><td>DOM</td><td>Document object model</td></tr>
<tr><td>GIF</td><td>Graphics Interchange Format</td></tr>
<tr><td>HAS</td><td>HTTP Adaptive Streaming</td></tr>
<tr><td>HE-AAC</td><td>High Efficiency AAC</td></tr>
<tr><td>IR</td><td>Infra Red</td></tr>
<tr><td>JPEG</td><td>Joint Photographic Experts Group</td></tr>
<tr><td>MPD</td><td>Media Presentation Description</td></tr>
<tr><td>PNG</td><td>Portable Network Graphics</td></tr>
<tr><td>PSI</td><td>Public Service Identifier</td></tr>
<tr><td>RDF</td><td>Remote Control Function</td></tr>
<tr><td>SVG</td><td>Scalable Vector Graphics</td></tr>
<tr><td>TLS</td><td>Transport Layer Security</td></tr>
<tr><td>WAVE</td><td>Waveform audio format</td></tr>
</table>
</section>
</section>
</section>

<!-- section 4 -->
<section id='dae-overview'>
<h1>DAE Overview</h1>
<p>This specification builds on a selection of W3C specifications defined in [[.OIPF_WSTVP2]] with additions defined in this document in order to expose to an IPTV service provider the capabilities of any particular OITF.</p>
<p>Section <a href="#conventions" class="sectionRef"></a> of this document defines how to interpret [[RFC2119]] terms like "SHALL" in sections of this document included in a capability. In sections of this document which are not covered by capabilities, terms like "SHALL" apply as used in each section.</p>

<section id="architecture-of-dae">
<h2>Architecture of DAE</h2>
<p>The following diagram provides an overview of the OITF architecture in relation to this specification.</p>
<figure id="oitf-architecture">
<img alt="Figure 1" src="images/OITF-Architecture.png" style="width:90%" />
<figcaption>Figure ####: OITF architecture</figcaption>
</figure>
<p>The various system services are described below:</p>
<p>Application Manager (Widgets): This service handles the starting and stopping of applications and the downloading, starting, stopping and removal of widgets. See sections <a href="#application-definition" class="sectionRef"></a>, <a href="#application-lifecycle" class="sectionRef"></a>, <a href="#widgets-lifecycle" class="sectionRef"></a>, <a href="#applications-management-apis" class="sectionRef"></a> and <a href="#dae-widgets" class="sectionRef"></a> of this specification.</p>
<p>Capabilities: This service handles terminal capabilities and exposing them to applications. See sections <a href="#application-oipfcapabilities" class="sectionRef"></a> and <a href="#client-capability-description" class="sectionRef"></a> of this specification.</p>
<p>CoD metadata: This service handles the downloading, storage and retrieval of CoD metadata. See section <a href="#content-on-demand-metadata-apis" class="sectionRef"></a> of this specification.</p>
<p>Configurations: This service handles reporting and changing device configuration and power management. See section <a href="#configuration-and-setting-apis" class="sectionRef"></a> of this specification.</p>
<p>Content Download: This service handles initiating downloading of content by applications, downloading the content and managing content once downloaded. See sections <a href="#download-manager" class="sectionRef"></a> and <a href="#content-download-apis" class="sectionRef"></a> of this specification.</p>
<p>Content Service Protection: This service handles content and service protection. See section <a href="#content-service-protection-api" class="sectionRef"></a> of this specification.</p>
<p>DLNA RUI: This service enables a DAE application on an OITF to export a user interface to another device in the home as defined by the DLNA remote UI specification. See sections <a href="#dlna-remote-control-function" class="sectionRef"></a>, <a href="#dlna-rui-remote-control-function-apis" class="sectionRef"></a> and <a href="#dlna-rui-rcf-implementation" class="sectionRef"></a> of this specification.</p>
<p>Gateway Discovery/Control: This service handles gateways, including discovery and managing information about them. See sections <a href="#gateway-discovery-and-control" class="sectionRef"></a> and <a href="#gateway-discovery-and-control-apis" class="sectionRef"></a> of this specification.</p>
<p>IMS &mdash; Messaging, Presence, Chat, Telephony: This service handles IMS including messaging, presence, chat and telephony. See section <a href="#communication-services-apis" class="sectionRef"></a> of this specification.</p>
<p>Media Playback: This service handles playback of media including streaming on-demand, downloaded content and scheduled content which has been recorded. Live scheduled content is part of a different service. See sections <a href="#unicast-streaming" class="sectionRef"></a> and <a href="#media-playback-apis" class="sectionRef"></a> of this specification.</p>
<p>Notification: This service handles notifications from the network to the OITF. See section <a href="#event-notifications" class="sectionRef"></a> of this specification.</p>
<p>Parental Rating and Control: This service handles parental rating and control including reporting of changing of parental rating status and providing parental rating PIN codes. See sections <a href="#parental-access-control" class="sectionRef"></a>, <a href="#parental-rating-and-parental-control-apis" class="sectionRef"></a>, <a href="#video-broadcast-extensions-parental-ratings" class="sectionRef"></a> and <a href="#av-control-extensions-for-parental-rating-errors" class="sectionRef"></a> of this specification.</p>
<p>Remote Management: This service handles remote management when supported as a DAE application. See section <a href="#remote-management-apis" class="sectionRef"></a> of this specification.</p>
<p>Scheduled Content and hybrid tuner &mdash; playback, favourite lists, channel scan, metadata: This service handles scheduled content services whether these are delivered by IP or by a classical cable, satellite or terrestrial tuner in a hybrid device. See sections <a href="#multicast-streaming" class="sectionRef"></a>, <a href="#scheduled-content" class="sectionRef"></a>, <a href="#metadata-apis" class="sectionRef"></a> and <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a> of this specification.</p>
<p>Scheduled Recording: This service handles recording of scheduled content. See section <a href="#scheduled-recording-apis" class="sectionRef"></a> of this specification.
<p>NOTE: Native Applications are out of scope of the DAE specification.</p>
</section>
<section id="gateway-discovery-and-control">
<h2>Gateway Discovery and Control</h2>
<p>This section describes how DAE applications discover the information of the gateway and subsequently interacts with the gateway. The discovery of the IG and AG by the OITF are defined in <a href="volume4.html#s10-1" class="extRef">section 10.1</a> of [[.OIPF_PROT2]]. The discovery takes place prior to the DAE application being initialized. The information about the discovered gateways is made available to DAE applications through the <a href="#application-oipfgatewayinfo" class="apiRef">application/oipfGatewayInfo</a> embedded object. DAE applications can use this gateway information to interact with the discovered gateways (e.g. IG, AG, CSP gateway and so on). The <a href="#application-oipfgatewayinfo" class="apiRef">application/oipfGatewayInfo</a> embedded object SHALL be made accessible through the DOM with the interface as defined in section <a href="#application-oipfgatewayinfo" class="sectionRef"></a>.</p>
<p>Access to the functionality of the <a href="#application-oipfgatewayinfo" class="apiRef">application/oipfGatewayInfo</a> embedded object is privileged and SHALL adhere to the security requirements defined in section <a href="#application-service-security" class="sectionRef"></a>.</p>
</section>

<section id="application-definition">
<h2>Application Definition</h2>
<p>This section defines what is meant by the concept of a 'DAE application'; which files and assets are considered to be part of a DAE application and how this relates to DAE application security and lifecycle.</p>
<p>A DAE application is either:</p><ul>
<li>An associated collection of documents (HTML or SVG where supported) from within a common boundary (see section <a href="#application-boundaries" class="sectionRef"></a> for more details), or
<li>A Widget as specified in section <a href="#widgets" class="sectionRef"></a>.
</ul>
<p>While the application is loaded within the browser, an additional browser object (the <a href="#application-oipfApplicationManager" class="apiRef">oipfApplicationManager</a> object), defined in section <a href="#application-oipfApplicationManager" class="sectionRef"></a> is present and accessible by the DAE application. The <a href="#application-oipfApplicationManager" class="apiRef">oipfApplicationManager</a> object provides access to the <a href="#application-class" class="apiRef">Application</a> class defined in section <a href="#application-class" class="sectionRef"></a>.
<p>The difference between a DAE application and a traditional web page is that web pages are stand-alone with no formal concept of a group of pages or a context within which a group of pages are loaded and execute. For this reason, the definition and details of a DAE application focuses on the application execution environment and the additional capabilities provided to DAE applications. The next subsections describe some of the differences. Additional details about the DAE application lifecycle can be found in section <a href="#application-lifecycle" class="sectionRef"></a>.</p>
<section id="similarities-applications-and-web-pages">
<h3>Similarities between applications and traditional web pages</h3>
<p>DAE applications are comprised of pages which are conceptually no different from traditional web pages. Both pages in a DAE application and traditional web pages can include the contents of other documents. These included documents can have a variety of types, including Cascading Style Sheets (CSS), JavaScript, SVG, JPEG, PNG and GIF.</p>
<p>A dynamic DOM, combined with XMLHttpRequest, permits AJAX-style changes to the current page in a DAE application or web page without necessarily replacing the entire document.</p>
</section>
<section id="differences-applications-and-web-pages">
<h3>Differences between applications and traditional web pages</h3>
<p>A DAE application provides shared context and state common to a number of pages &mdash; a concept which doesn't formally exist in the web. Loading and unloading pages within the context of a DAE application is the same as loading and unloading web pages.<p>
<p>The application context includes information about the state of an application from the platform's perspective &mdash; permissions, priority (for example, which to terminate first in the event of insufficient resources) and similar information that spans all documents within an application during the lifetime of that application.</p>
<p>An OITF MAY support the execution of more than one application simultaneously. Applications MAY share the same screen estate in a defined and controlled fashion. This differs from multiple web pages, which are typically handled through different browser &ldquo;windows&rdquo; or &ldquo;tabs&rdquo; and may not share the same screen estate concurrently (although the details of this behaviour are often browser-dependent). This also differs from the use of frames, which, apart from iframes, do not support overlapping screen estate. Where simultaneous execution of more than one application is supported, both foreground and background applications SHALL be supported simultaneously.</p>
<p>Where simultaneous execution of more than one application is supported, applications SHALL be recorded within a hierarchy of applications. Each object representing an application possesses an interface that provides access to methods and attributes that are uniquely available to applications. For example, facilities to create and destroy applications can be accessed through such methods.</p>
</section>
<section id="application-tree">
<h3>The application tree</h3>
<p>Where simultaneous execution of more than one application is supported, applications are organised into a tree structure. Using the <a href="#application-createapplication" class="apiRef">createApplication()</a> method as defined in section <a href="#application-class-methods" class="sectionRef"></a>, applications can either be started as child nodes of the application or as a sibling of the application (i.e. added as an additional child of this application's parent). The root node of an application tree is created upon loading an initial application URI or by creating a sibling of an application tree's root node. An OITF MAY keep track of multiple application trees. Each of these individual application trees are connected to a hidden system root node maintained by the OITF that is not accessible by other applications.</p>
<p>Applications created while the DAE environment is running (e.g. as a result of an external notification) that are not created through <a href="#application-createapplication" class="apiRef">createApplication()</a> SHALL be created as children of the hidden system root node.</p>
</section>
<section id="application-display-model">
<h3>The application display model</h3>
<p>Applications SHALL be displayed on the OITF in one of the application visualization modes as defined in section <a href="#use-of-the-display" class="sectionRef"></a>.</p>
<p>The mode used SHALL be determined prior to initialisation of the DAE execution environment and shall persist until termination or re-initialization of the DAE execution environment. The means by which this mode is chosen is outside the scope of this specification.</p>
<p>Each application has an associated DOM <code>Window</code> object and a DOM <code>Document</code> object that represents the document that is currently loaded for that application. Even &ldquo;windowless&rdquo; applications that are never made visible have an associated DOM Window object.</p>
<section>
<h4>Manipulating an application's DOM Window object</h4>
<p>Standard DOM <code>Window</code> methods are used to resize, scroll, position and access the application document (see section <a href="#use-of-the-display" class="sectionRef"></a>). Many browsers restrict the size or location of windows; these restrictions SHALL NOT be enforced for windows associated with applications within the browser area. Any area of the display available to DAE applications may be used by any application. Thus, 'widget'-style applications can create a small window that contains only the application without needing to be concerned with any minimum size restrictions enforced by browsers.</p>
</section>
</section>
<section id="security-model">
<h3>The security model</h3>
<p>Each application has a set of permissions to perform various privileged operations within the OITF. The permissions that are granted to an application are defined by the intersection of three permission sets:</p><ol>
<li>The permissions requested by the application, using the mechanism defined in section <a href="#dae-security" class="sectionRef"></a>.
<li>The permissions supported by the OITF. Some permissions may not be supported due to capability restrictions (e.g. the <i>permission_pvr</i> permission will never be granted on a receiver that does not support PVR capability).
<li>The permissions that may be granted, as determined by user settings or configuration settings specified by the operator (e.g. blacklists or whitelists; see section <a href="#dae-security" class="sectionRef"></a> for more information). This is a subset of (2), and may be different for different users.
</ol>
</section>
<section id="inheritance-of-permissions">
<h3>Inheritance of permissions</h3>
<p>Applications created by other applications (e.g. using the methods described in sections <a href="#creating-a-new-application-bi-apps" class="sectionRef"></a> or <a href="#creating-a-new-application-createapplication" class="sectionRef"></a>) SHALL NOT inherit the permissions issued to the parent application. The permissions granted to the new application will be defined by the mechanism specified in section <a href="#dae-security" class="sectionRef"></a>.</p>
<p>When an application uses cross-document messaging (see the <code>window.postMessage()</code> method defined in HTML5 Web Messaging as referenced in [[.OIPF_WSTVP2]]) to communicate with another application, any action carried out in response to the message SHALL take place in the security context of the application to which the message was sent. Applications SHOULD take care to ensure that privileged actions are only taken in response to messages from an appropriate source.</p>
</section>
<section id="privileged-application-apis">
<h3>Privileged application APIs</h3>
<p>The privilege model implemented with applications is based upon requiring access to the <a href="#application-class" class="apiRef">Application</a> object representing an application in order to access the privileged functionality related to application lifecycle management and inter-application communication.</p>
<section>
<h4>Compromising the security</h4>
<p>Since applications have access to <a href="#application-class" class="apiRef">Application</a> objects, it is possible for applications to compromise the security of the framework by passing these objects to untrusted code. For example, an application could raise an event on an untrusted document and pass a reference to its <a href="#application-class" class="apiRef">Application</a> object in the message. Where simultaneous execution of more than one application is supported, any calls to methods on an <a href="#application-class" class="apiRef">Application</a> object from pages not running as part of an application from the same provider SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>.</p>
</section>
</section>
<section id="active-applications-list">
<h3>Active applications list</h3>
<p>Where simultaneous execution of more than one application is supported, the OITF SHALL maintain a list of application nodes ordered in a &ldquo;most recently activated&rdquo; order &mdash; the active applications list. This list is used by the cross-application event dispatch algorithm as defined in section <a href="#cross-application-event-handling" class="sectionRef"></a> and is not directly visible to applications.</p>
<p>An application is activated through calling the <a href="#application-activateinput" class="apiRef">activateInput()</a> method of the application node. This marks an application as active and SHALL insert the application at the start of the active application list (removing it from the list first if it is already present).</p>
<p>An application is deactivated through the <a href="#application-deactivateinput" class="apiRef">deactivateInput()</a> method of the application node. This marks an application inactive and SHALL remove it from the active application list.</p>
<p>The currently active application is the application at the start of the active application list.</p>
<p>This specification does not define any behaviour if more than one copy of the browser is executing.</p>
</section>
<section id="widgets">
<h3>Widgets</h3>
<p>DAE Widgets are a specialization of DAE applications and share aspects with W3C Widgets.</p>
<p>W3C Widgets are standardized by the &ldquo;Widgets 1.0 family of specifications&rdquo; as described in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#the-widget-family-of-specifications" class="extRef">section 1.4</a> of [[!Widgets-Packaging]]. Section <a href="#dae-widgets" class="sectionRef"></a> of this document specifies which parts of W3C Widgets specifications are in supported by DAE Widgets. From here on, when using the word &ldquo;Widget&rdquo; we will refer to DAE Widgets as defined in this specification.</p>
<p>Widgets can be primarily seen as packaged DAE applications. Since they are packaged, it is possible to have a single download and installation on an OITF. Widgets may also be installed on an OITF via non-HTTP distribution channels and even over off-network channels (e.g. a USB thumb drive). Packaging also provides an easy way to deploy and/or update applications on the OITF when it is installed in the home. The packaging and configuration of a DAE Widget is described in section <a href="#widgets-packaging-and-configuration" class="sectionRef"></a>.</p>
<p>Since DAE Widgets are DAE Applications everything that is defined for a DAE Application is also applicable to a Widget unless specified. Furthermore Widgets have several specific features as defined in section <a href="#dae-widgets" class="sectionRef"></a>.</p>
</section>
<section id="origin-for-broadcast-delivered-documents">
<h3>Origin for Broadcast-delivered Documents</h3>
<p>For documents that are delivered by an object carousel in a broadcast channel (as defined in <a href="volume2.html#system-mpeg2-ts" class="extRef">section 4.1</a> of [[.OIPF_MEDIA2]], the following SHALL apply;</p><ul>
<li>For each broadcast channel, the OITF SHALL generate a unique origin as defined in [[!RFC6454]].
<li>These origins SHALL be of the form scheme/host/port tuple where the OITF does not use the same scheme for any documents other than those delivered by a broadcast object carousel.
<li>The origin SHALL be the one for the channel from which the document was loaded regardless of any subsequent channel changes
</ul>
<p>Specifically this origin SHALL be used with the Web Storage API as referenced in [[.OIPF_WSTVP2]].</p>
</section>

</section>
<section id="resource-management">
<h2>Resource Management</h2>
<p>This section describes how resources (including non-granular resources such as memory and display area) are shared between multiple applications that may be running simultaneously. Applications SHOULD be able to tolerate the loss of scarce resources if they are needed by another application, and SHOULD follow current industry best practises in order to minimize the resources they consume.</p>
<p>This specification is silent about the mechanism for sharing resources between DAE applications and other applications running on the OITF. In the remainder of this section and this document, the term application refers solely to DAE applications.</p>
<section id="application-lifecycle-issues">
<h3>Application lifecycle issues</h3>
<p>Where simultaneous execution of more than one application is supported, if an application attempts to start and not enough resources are available, the application with the lowest priority MAY be terminated until sufficient resources are available for the new application to execute or until no applications with a lower priority are running. Applications without a priority associated with them (e.g. applications started by the DRM agent, see section <a href="#starting-applications-from-drm-agent" class="sectionRef"></a>) SHALL be assumed to have a priority of 0x7F.</p>
<p>Applications may register a listener for <code>ApplicationUnloaded</code> events (see section <a href="#application-oipfApplicationManager-events" class="sectionRef"></a>) to receive notification of the termination of a child application, where simultaneous execution of more than one application is supported.</p>
<p>Failure to load an asset (e.g. an image file) or CSS file due to a lack of memory SHALL have no effect on the lifecycle of an application, but may result in visual artefacts (e.g. images not being displayed). Failure to load an HTML file due to a lack of memory MAY cause the application to be terminated.</p>
</section>
<section id="caching-of-application-files">
<h3>Caching of application files</h3>
<p>Application files MAY be cached on the receiver in order to improve performance; this specification is silent about the use of any particular caching strategy.</p>
</section>
<section id="memory-usage">
<h3>Memory usage</h3>
<p>Applications SHOULD use current industry best practises to avoid memory leaks and to free memory when it is no longer required. In particular, applications SHALL unregister all event listeners before termination, and SHOULD unregister them as soon as they are no longer required.</p>
<p>Where available, applications SHALL use explicit destructor functions to indicate to the platform that resources may be re-used by other applications.</p>
<p>Applications MAY use the <a href="#oipfApplicationManager-gc" class="apiRef">gc()</a> method on the <a href="#application-oipfApplicationManager" class="apiRef">application/oipfApplicationManager</a> embedded object to provide hints to the OITF that a garbage collection cycle should be carried out. The OITF is not required to act on these hints.</p>
<p>The <code>LowMemory</code> event described in section <a href="#application-oipfApplicationManager-events" class="sectionRef"></a> SHALL be generated when the receiver is running low on memory. The amount of free memory that causes this event to be generated is implementation dependent. Applications may register a listener for these events in order to handle low-memory situations as they choose best.</p>
</section>
<section id="claiming-scarce-resources">
<h3>Instantiating embedded objects and claiming scarce system resources</h3>
<p>The objects defined in section <a href="#dae-apis" class="sectionRef"></a> of this specification are embedded objects. These are typically instantiated through the standard DOM 2 methods for creating HTML objects or the <code>oipfObjectFactory</code> as defined in section <a href="#object-factory-api" class="sectionRef"></a>.</p>
<p>All embedded objects as defined in section <a href="#dae-apis" class="sectionRef"></a> SHALL NOT claim scarce system resources (such as a hybrid tuner) at the time of instantiation. Hence, instantiation SHALL NOT fail if the object type is supported (and sufficient memory is available).</p>
<p>For each embedded object for which scarce resource conflicts may be a problem, the state diagram and the accompanying text define how to deal with claiming (and releasing) scarce system resources.</p>
<p>Once an OIPF embedded object has been instantiated, dynamic change of its MIME type which could cause the properties and methods associated with the object to change SHALL be ignored.</p>
<p>For instance, it is possible to change the MIME type of an A/V Control embedded object from <code>video/mpeg</code> to <code>video/mp4</code> but it is not possible to change the MIME type of an OIPF embedded object from &ldquo;<a href="#application-oipfApplicationManager" class="apiRef">application/oipfApplicationManager</a>&rdquo; to &ldquo;<a href="#application-oipfconfiguration" class="apiRef">application/oipfConfiguration</a>&rdquo;.</p>
</section>
<section id="media-control">
<h3>Media control</h3>
<p>If insufficient resources are available to present the media, the attempt to play the media SHALL fail. For the video/broadcast object, this shall be indicated by a <code>ChannelChangeError</code> event with a value of 11 for the error state. For an A/V Control object, the <code>error</code> property shall take the value 3.</p>
<p>When the video/broadcast or A/V Control object either is instantiated in the <code>DYNAMIC_ALLOCATION</code> model or transitions to the <code>DYNAMIC_ALLOCATION</code> model, scarce resources such as a media decoder SHALL only be claimed following a call to the <a href="#video-broadcast-bindtocurrentchannel" class="apiRef">bindToCurrentChannel()</a>, <a href="#video-broadcast-setchannel" class="apiRef">setChannel()</a>, <a href="#video-broadcast-nextchannel" class="apiRef">nextChannel()</a> or <a href="#video-broadcast-prevchannel" class="apiRef">prevChannel()</a> methods on a <a href="#video-broadcast" class="apiRef">video/broadcast</a> object or the <code>play()</code> method on an A/V Control object. By implication, instantiating a <a href="#video-broadcast" class="apiRef">video/broadcast</a> or A/V Control object does not cause the media referred to by the object's data attribute to start playing immediately. See section <a href="#video-broadcast-state-diagram" class="sectionRef"></a> for details of when scarce resources are released by a video/broadcast object and section <a href="#av-control-state-diagram" class="sectionRef"></a> when scarce resources are released by an A/V Control object.</p>
<p>Scarce resources can be claimed by the video/broadcast or A/V Control object at instantiation time by specifying the <code>requiredCapabilities</code> parameter. In this case the <code>STATIC_ALLOCATION</code> method is used and the scarce resources are held by the object until it is either destroyed or the <code>release()</code> method is called.</p>
<p>This specification is intentionally silent about handling of resource use by embedded applications including scheduled recordings.</p>
</section>
<section id="use-of-the-display">
<h3>Use of the display</h3>
<p>A compliant OITF SHALL support at least one of the following application visualization modes for managing the display of applications:</p><ol>
<li>Multiple applications may be visible simultaneously, with each application having a full-screen window, with the OITF managing focus. Setting parts of an application to be transparent SHALL cause the following to be visible except where the application has drawn UI elements.<ul>
<li>firstly any applications with a lower Z-index
<li>secondly video (if the hardware supports overlay as per the <code>&lt;overlay*&gt;</code> elements defined in section <a href="#default-ui-profiles" class="sectionRef"></a> for the capability profiles)</ul>
<p>In this mode, applications from the same service provider that are intended to run simultaneously SHOULD take care to co-ordinate their use of the display in order to ensure that important UI elements are not obscured.</p>

<li>Multiple applications may be visible simultaneously, with the OITF managing the size, position, visibility and focus between applications.
<li>Only one application is visible at any time; switching to a different application either hides the currently-visible application (where simultaneous execution of more than one application is supported) or terminates the currently visible application (where simultaneous execution of more than one application is not supported). The mechanism for switching between applications is implementation-dependent. In this case, the <a href="#application-show" class="apiRef">show()</a>, <a href="#application-hide" class="apiRef">hide()</a>, <a href="#application-activateinput" class="apiRef">activateInput()</a> and <a href="#application-deactivateinput" class="apiRef">deactivateInput()</a> methods of the <a href="#application-class" class="apiRef">Application</a> object provide hints to the execution environment about whether the user should be notified that an application requires attention. The mechanism for notifying the user is outside the scope of this specification.
</ol>
<p>Applications SHALL be created with an associated DOM <code>Window</code> object, that covers the display area made available by the OITF to a DAE application. The size of the DOM <code>Window</code> can be retrieved through properties <code>innerWidth</code> and <code>innerHeight</code> of the DOM <code>Window</code> object.</p>
<p>Any areas of the browser area outside the DOM Window that become visible when it is resized SHALL be transparent &mdash; any video (if the hardware supports overlay as per the <code>&lt;overlay*&gt;</code> elements defined in section <a href="#default-ui-profiles" class="sectionRef"></a> for the capability profiles) or applications (if multiple applications can be visible simultaneously) with a lower Z-index will be visible except where the application has drawn UI elements.</p>
<p>Broadcast-related and service provider related applications SHALL initially be created as invisible to avoid screen flicker during application start-up. Once loaded (as SHALL be indicated through an <code>onload</code> event handler), the application then typically calls the <a href="#application-show" class="apiRef">show()</a> method of its parent <a href="#application-class" class="apiRef">Application</a> object. Broadcast-independent applications SHALL initially be created as visible and need not call these methods.</p>
<p>If the application does not ever need to be visible, then its DOM <code>Window</code> object will never be shown. In that case, the application should take steps to avoid being formatted to reduce computation and memory overheads. This is typically accomplished by setting the default CSS style of the document's <code>BODY</code> element to <code>visibility:hidden</code>.</p>
<p>Because all applications have associated DOM <code>Window</code> objects, it is possible to make any application visible even if it is not normally intended to be visible. This is of particular benefit during debugging of hidden service type applications.</p>
<p>Application developers SHOULD explicitly set the background color of the application <code>&lt;body&gt;</code> and <code>&lt;html&gt;</code> elements.</p>
<p>Setting the background color to 'transparent' (e.g. using the CSS construct <code>html, body { background-color: transparent; }</code>) will allow the underlying video to be shown for those areas of the screen that are not obscured by overlapping non-transparent (i.e. opaque) children of the <code>&lt;body&gt;</code> element.</p>
<p>Changing the visibility of an application by calling method <a href="#application-show" class="apiRef">show()</a> or <a href="#application-hide" class="apiRef">hide()</a> on the <a href="#application-class" class="apiRef">Application</a> object SHALL NOT affect its use of resources. The application still keeps running and listens to events unless the application gets deactivated (see section <a href="#active-applications-list" class="sectionRef"></a>) or destroyed (see section <a href="#stopping-an-application" class="sectionRef"></a>).</p>
</section>
<section id="cross-application-event-handling">
<h3>Cross-application event handling</h3>
<p>As defined in the DOM Level 3 Events specification as referenced in [[!OIPF_WSTVP2]], standard DOM events are raised on a specific node within a single document. This specification extends the event capability of the OITF through cross-application events handling, but does not change the DOM2 event model for dispatching events within documents. Where simultaneous execution of more than one application is supported, an OITF SHALL implement the cross-application events and cross-application event handling model described in this section.</p><ol>
<li>An OITF SHALL implement the following cross-application event handling model. Cancelling the propagation of an event in any phase SHALL abort further raising of the event in subsequent phases: If an event is eligible for cross-application event handling (see below for more information) and is targeted at a node in the most recently activated application, then dispatch the event to that node using the standard DOM bubbling/capturing of events. Default actions normally taken by the browser upon receipt of an event SHALL be carried out at the end of this step, unless overridden using the existing DOM methods (i.e. using method preventDefault()).
<li>If the cross-application event is not prevented from being propagated beyond the document root node of the application by using the existing DOM methods, the event is dispatched to other active applications in the application hierarchy using the active applications list described in section <a href="#active-applications-list" class="sectionRef"></a>. The OITF SHALL iterate over the applications in the active application list, from most recently activated to least recently activated, dispatching the event to the Application object of each application in turn. Note that the event SHALL NOT be dispatched to the document, and default browser action SHALL NOT be carried out during this phase. Cancelling the propagation of an event in this phase SHALL abort further raising of the event in subsequent applications.
</ol>
<p>Event listeners for cross-application events are registered and unregistered using the same mechanism as for DOM2 events. Listeners for cross-application events may be registered on the Application object as well as on nodes in the DOM tree.</p>
<p>The following events are valid instances of cross-application events and are applicable for cross application event handling:</p>
<table class="simple" id="events-for-cross-application-event-handling">
<caption>Table ####: Events applicable for cross application event handling</caption>
<thead><tr><th>System event</th><th>Description</th></tr></thead>
<tr><td><code>KeyPress</code></td><td>Generated when a key has been pressed by the user. May also be generated when a key is held down during a key-repeat.</td></tr>
<tr><td><code>KeyUp</code></td><td>Generated when a key pressed by the user has been released.</td></tr>
<tr><td><code>KeyDown</code></td><td>Generated when a key has been pressed by the user.</td></tr>
</table>

<p>The <code>KeyPress</code>, <code>KeyUp</code> and <code>KeyDown</code> events are all targeted cross-application events. The events are targeted at the node that has the input focus.</p>
<p>All events dispatched using the standard <code>dispatchEvent()</code> method are normal DOM events, not cross-application events. As defined in HTML5 Web Messaging as referenced in [[.OIPF_WSTVP2]], the OITF SHALL support the <code>window.postMessage()</code> method for cross-document messaging. The method takes two arguments; a message (of type String) to be dispatched and the targetOrigin, which defines the expected origin (i.e. domain) of the target window, or &ldquo;<code>*</code>&rdquo; if the message can be sent to the target regardless of its origin. The target of the event is the &ldquo;window&rdquo; of a specific application. Applications can use this method to send events to other applications. The receiving application MAY receive those events and interpret them, or MAY dispatch them in its DOM using standard DOM dispatchEvent() methods.</p>
<p>The visibility of an application SHALL NOT affect the cross-application event handling algorithm as defined above &mdash; an active application SHALL receive cross-application events even when it is not visible.</p>
<p>Incoming key events are dispatched using the cross-application event handling algorithm as defined above.</p>
<p>NOTE: This event dispatch model enables key events to be dispatched to multiple applications. Applications wishing to become the primary receiver for key events SHOULD call <a href="#application-activateinput" class="apiRef">Application.activateInput()</a>. Even though <code>Application.activateInput()</code> is called, another application may subsequently be activated. In order to ensure that sensitive key input (e.g. PINs or credit card details) is limited only to the application it is intended for, applications SHOULD check that they are the primary receiver of the key events (using the <a href="#application-isprimaryreceiver" class="apiRef">Application.isPrimaryReceiver</a> property and/or the <code>ApplicationPrimaryReceiver</code> and <code>ApplicationNotPrimaryReceiver</code> events defined in section <a href="#new-dom-events-for-application-support" class="sectionRef"></a>) and SHOULD 'absorb' key events by calling the <code>stopPropagation()</code> method on the DOM2 <code>key</code> event.</p>
<section id="behaviour-of-the-back-key">
<h4>Behaviour of the BACK key</h4>
<p>OIPF applications may use the methods on the <code>History</code> object to navigate the history list. The history list SHALL NOT go back beyond the initial page of an OIPF application.</p>
<p>If a remote features a &ldquo;back&rdquo; or &ldquo;back up&rdquo; key, or one offering similar functionality, the OITF SHALL handle this key as described below:</p><ol>
<li>A <code>VK_BACK</code> key event SHALL be dispatched to applications following the normal key handling process described in section <a href="#cross-application-event-handling" class="sectionRef"></a>
<li>The default behaviour of the <code>VK_BACK</code> key event is implementation-dependent but the OITF SHALL NOT load the previous page in its history list for DAE applications.
</ol>
</section>
</section>
<section id="tuner-resources">
<h3>Tuner resources</h3>
<p>Tuners can be used for recording, scanning or watching broadcast channels (e.g. DVB-T). The priority relating to resource management is as follows. Recording have the highest priority, viewing a channel has the lowest priority. A record request SHALL not be automatically interrupted by a viewing a channel or a scan request. Note to free the tuner for viewing requires interrupting the recording first.</p>
</section>
</section>

<section id="parental-access-control">
<h2>Parental access control</h2>
<p>The present document permits a number of different approaches to parental access control.</p>
<ol type="a">
<li><b>Enforcement in the network.</b>
<p>An IPTV service provider MAY manage parental access control completely in the network. Applications running on application servers back in the network MAY decide to block access to content or arrange a DAE application to ask for a PIN code as necessary. This approach can apply to any kind of content - streaming on-demand content, IP broadcast content and to downloaded content.</p>
<p>No specific support is needed for this approach in the specification.</p>
<li><b>Enforcement in the OITF CSP / CSPG for protected MPEG-2 TS content</b>
<p>IPTV service providers MAY use the content protection mechanism for protected content to enforce access control to protected content. If used, this enforcement will happen in the OITF and in some cases in the CSP Gateway as well. In this approach, the content protection mechanism in the OITF would ask for PIN codes as needed.</p>
<p>The OITF CSP/CSPG-based enforcement of this approach and link to DAE API and events are defined in:</p><ul>
<li><a href="volume7.html#protection-of-mpeg2-transport-streams-context" class="extRef">Section 4.1.5.1</a> of [[.OIPF_CSP2]], for CSP terminal centric approach,
<li>Sections <a href="volume7.html#cspg-dae-interface" class="extRef">4.2.2</a>, <a href="volume7.html#parental-control-info" class="extRef">4.2.3.4.1.1.5</a> and <a href="volume7.html#rights-info" class="extRef">4.2.3.4.1.1.6</a> of [[.OIPF_CSP2]] for CI+ CSP Gateway centric approach
<li>Sections <a href="volume7.html#cspg-dae-interface" class="extRef">4.2.2</a> and <a href="volume5.html#dtcpip-protection-of-mpeg2-transport-streams" class="extRef">4.2.4.5.1</a> of [[.OIPF_CSP2]] for DTCP-IP CSP Gateway centric approach
</ul>
<li><b>enforcement in the OITF</b>
<p>An OITF MAY enforce parental access controls itself. Examples include embedded applications offering access to;</p><ul>
<li>IP delivered content based on information delivered to the metadata CG client.
<li>classical broadcast content in hybrid OITFs
<li>content delivered to the OITF (either streaming or downloaded)
</ul>
</ol>

<p>In approaches b) and c), PIN dialogs would be generated by code forming part of the OITF implementation. The APIs in section <a href="#parental-rating-and-parental-control-apis" class="sectionRef"></a> provide some control over these dialogs. The PIN would typically be configured by an embedded application but MAY also be configured by a DAE application using the optional APIs defined in section <a href="#configuration-class" class="sectionRef"></a> &ldquo;<a href="#configuration-class" class="sectionTitleRef"></a>&rdquo; of the present document.</p>
<p>These approaches b) and c) are reflected in a number of failure modes as defined in the following sections of the specification;</p><ul>
<li>For broadcast channels (both IP and hybrid), in section <a href="#video-broadcast" class="sectionRef"></a> "<a href="#video-broadcast" class="sectionTitleRef"></a>", see <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> where <code>errorState</code> 3 is defined as "parental lock on channel"
<li>Parental rating errors and parental rating changes during playback of A/V content through the AV Control APIs defined in section <a href="#media-playback-apis" class="sectionRef"></a> and the video/broadcast object are reported according to the mechanism described in section <a href="#av-control-extensions-for-parental-rating-errors" class="sectionRef"></a> &ldquo;<a href="#av-control-extensions-for-parental-rating-errors" class="sectionTitleRef"></a>&rdquo; and section <a href="#video-broadcast-extensions-parental-ratings" class="sectionRef"></a> &ldquo;<a href="#video-broadcast-extensions-parental-ratings" class="sectionTitleRef"></a>&rdquo; respectively.
</ul>
<p>NOTE: Due to the variation in regulatory requirements and deployment scenarios, the present document is intentionally silent about which of these approaches or combination of approaches is used.</p>
</section>

<section id="content-download">
<h2>Content Download</h2>
<p>The requirements in this section apply if the <code>&lt;download&gt;</code> element has been given value &ldquo;<code>true</code>&rdquo; in the OITF's capability profile as specified in section <a href="#download-cod-capability" class="sectionRef"></a>.</p>
<section id="download-manager">
<h3>Download manager</h3>
<p>An OITF SHALL support a native download manager (i.e. &ldquo;Content Download&rdquo; component) to perform the actual download and storage of the content, and which allows the user to manage (e.g. suspend/resume, cancel) and monitor the download, in a consistent manner across different service providers. The download manager SHALL continue downloading as a background process even if the browser does not have an active session with the server that originated the download request anymore (e.g. has switched to another DAE application), even after a device power-down or network failure, until it succeeds or the user has given permission to terminate the download. (see section <a href="#download-protocols" class="sectionRef"></a> on HTTP Range support to resume HTTP downloads after a power/network failure).</p>
<p>The native download manager SHALL be able to offer a visualization of its status through the <a href="#application-oipfstatusview" class="apiRef">application/oipfStatusView</a> embedded object as defined in section <a href="#oipfstatusview-overview-of-downloads" class="sectionRef"></a>.</p>
<p>If the attribute <code>manageDownloads</code> of the <code>&lt;download&gt;</code> element in the client capability description is unequal to &ldquo;<code>none</code>&rdquo;, the native download manager SHALL offer control over the active downloads through the JavaScript API defined by the <a href="#application-oipfdownloadmanager" class="apiRef">application/oipfDownloadManager</a> embedded object in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a>.</p>
<p>NOTE 1: Once sufficient data of the content has been downloaded, the content MAY be played back using a native application, and MAY be played back using an A/V Control object. In the latter case, see method <code>setSource()</code> in section <a href="#av-control-extensions-for-playing-media-objects" class="sectionRef"></a> for more information.</p>
<p>NOTE 2: Annex <a href="#cod-clarification" class="sectionRef"></a> clarifies the content download usage scenario in more detail.</p>
</section>
<section id="content-access-download-descriptor">
<h3>Content Access Download Descriptor</h3>
<p>An OITF SHALL support parsing and interpretation of the Content Access Download Descriptor document format with the specified semantics, syntax and MIME type as specified in Annex <a href="#content-access-descriptor-formats" class="sectionRef"></a>.</p>
</section>
<section id="triggering-a-download">
<h3>Triggering a download</h3>
<p>An OITF SHALL support a non-visual embedded object of type &ldquo;<a href="#application-oipfdownloadtrigger" class="apiRef">application/oipfDownloadTrigger</a>&rdquo;, with the JavaScript API as defined in sections <a href="#application-oipfdownloadtrigger" class="sectionRef"></a> and <a href="#extensions-to-application-oipfdownloadtrigger" class="sectionRef"></a> to trigger a download.</p>
<p>The following subsections define some details about the different ways of triggering a download.</p>
<section id="using-the-registerdownload-method">
<h4>Using the registerDownload() method</h4>
<p>The <a href="#downloadtrigger-registerdownload" class="apiRef">registerDownload()</a> method takes a Content Access Download Descriptor as one of its arguments and passes it to the underlying native download manager in order to trigger a download. The following requirements apply:</p><ol>
<li>The Content Access Download Descriptor MAY be created in JavaScript or MAY be fetched using <code>XMLHttpRequest</code>. To this end the OITF SHALL pass the data inside the content access download descriptor into the <code>XMLHttpRequest.responseXML</code> property in JavaScript for further processing, if the OITF encounters an HTTP response message with the Content-Type of &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo;, as the result of an XMLHttpRequest.
<p>NOTE: The behaviour in other cases when the OITF encounters an HTTP response message with the Content-Type &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo;, for example whilst following a link as specified by an anchor element (<code>&lt;a&gt;</code>), is not specified in this document.</p>
<li>If the OITF supports a DRM agent with a matching <code>DRMSystemID</code> as per section <a href="#drm-capability-indication" class="sectionRef"></a>, the OITF SHALL pass included DRM-information as part of the <code>&lt;DRMControlInformation&gt;</code> elements of a content-access download descriptor to the DRM agent.
<li>If the content access descriptor contains multiple content items to be downloaded, then all items are considered to belong together. Therefore, the download of each individual content item has the same download identifier in that case (whereby the <code>ContentID</code> may be used for differentiation). The order by which the items are downloaded is defined by the OITF.
</ol>
</section>
<section id="using-the-registerdownloadurl-method">
<h4>Using the registerDownloadURL() method</h4>
<p>The <a href="#downloadtrigger-registerdownloadurl" class="apiRef">registerDownloadURL()</a> method takes a URL as one of the arguments and passes it to the underlying native download manager in order to trigger a download. The URL MAY point to any type of content. The URL MAY also point to a Content Access Download Descriptor (i.e. with argument <code>contentType</code> having value &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo;). In that case, the method returns a download identifier. The OITF will then fetch the Content Access Download Descriptor, after which the same must happen as if method <a href="#downloadtrigger-registerdownload" class="apiRef">registerDownload()</a> as defined in section <a href="#using-the-registerdownload-method" class="sectionRef"></a> with the given Content Access Download Descriptor as argument was called.</p>
</section>
<section id="using-the-optional-registerdownloadfromcrid-method">
<h4>Using the optional registerDownloadFromCRID() method</h4>
<p>The <a href="#downloadtrigger-registerdownloadfromcrid" class="apiRef">registerDownloadFromCRID()</a> method is an optional method as defined in section <a href="#extensions-to-application-oipfdownloadtrigger" class="sectionRef"></a> and takes a CRID as one of its arguments that is passed to the underlying native download manager in order to trigger a download.</p>
</section>
<section id="general-behaviour-when-triggering-a-download">
<h4>General behaviour regarding triggering a download</h4>
<p>The following are general behavioural requirements apply to triggering downloads:</p><ol>
<li>Fetching the content will typically be initiated immediately. However, the OITF MAY defer the download to a later time.
<li>An OITF SHOULD offer an easy way to continue the UI interaction with the server from which a download has been initiated, e.g. allowing him/her to continue browsing on the page that triggered the download.
<li>An OITF SHOULD inform the user if the content-type of a content item being retrieved cannot be interpreted by the OITF.
</ol>
</section>

</section>
<section id="download-protocols">
<h3>Download protocol(s)</h3>
<p>The OITF SHALL support the HTTP protocol for download as specified in <a href="volume4.html#s5-3-4" class="extRef">section 5.3.4</a> of [[!OIPF_PROT2]]. In addition, the OITF SHALL support the following requirements:</p><ol>
<li>As specified in <a href="volume4.html#s5-3-4" class="extRef">section 5.3.4</a> of [[.OIPF_PROT2]], if a server offers a content item for download using HTTP, the server SHALL make sure that HTTP Range requests as defined in [[!HTTP]] are supported for HTTP GET requests to the URI of that downloadable content item, in order to be able to resume downloads (e.g. after power or network failure).
<li>If the OITF receives an HTTP 404 &ldquo;File Not Found&rdquo; status code, the OITF SHALL stop its attempts to resume the download, and go to a &ldquo;Failed Download&rdquo; state. The handling of other error codes is implementation dependent.
<li>If after downloading a content item the size of the downloaded content item does not match the indicated size parameter or the value for the optional attribute &ldquo;MD5Hash&rdquo; of the given <code>&lt;ContentURL&gt;</code> does not match the hash of the downloaded content, the OITF SHOULD remove the downloaded content item.
</ol>
<p>Integration with download protocols other than HTTP are not specified in this document.</p>
</section>
</section>
<section id="streaming-cod">
<h2>Streaming CoD</h2>
<p>This section defines the content-on-demand streaming interfaces for both DRM-protected and non-DRM protected content.</p>
<section id="unicast-streaming">
<h3>Unicast streaming</h3>
<p>This specification defines 3 mechanisms by which a reference to content can be passed from a DAE application to the OITF.</p><ol>
<li>By setting the <code>data</code> property of a A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> to the reference. The application SHALL set the <code>type</code> attribute to the MIME type of the content referred to by the value of the data attribute to provide a hint about the expected content type, in order for the browser to instantiate the proper object to play the content.
<li>By setting the <code>src</code> attribute of a <code>&lt;video&gt;</code> element to the reference
<li>By including the reference in the <code>&lt;ContentURL&gt;</code> element of a Content Access Streaming descriptor as defined in section <a href="#av-control-extensions-for-playback-through-casd" class="sectionRef"></a> and then setting the <code>data</code> property of an A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> to be a reference to that Content Access Streaming Descriptor. In this case the application SHALL set the <code>type</code> attribute to &ldquo;<code>application/vnd.oipf.ContentAccessStreaming+xml</code>&rdquo;.
<p>Example:<br />
<code>&lt;object id="d1" data=http://www.openiptv.org/fetch?contentID=25 <br />&nbsp;&nbsp;type="application/vnd.oipf.ContentAccessStreaming+xml" width="200" height="100"/&gt;</code>
</p>
</ol>
<p>This specification defines five different possible formats for a reference to unicast streaming content;</p><ol>
<li>A Public Service Identifier (PSI) as defined in Protocol Specification [[.OIPF_PROT2]].
<li>An HTTP URL directly referencing the content to be streamed.
<li>An RTSP URL directly referencing the content to be streamed.
<li>An HTTP or HTTPS URL referencing a HAS MPD
<li>An HTTP or HTTPS URL referencing a MPEG DASH MPD
</ol>
<p>All of the mechanisms that an OITF supports SHALL be supported with all formats of a reference that an OITF supports.</p>

<section id="http-adaptive-streaming">
<h4>HTTP Adaptive Streaming</h4>
<p>If the OITF supports HAS content then it SHALL support the MIME type as specified for the Media Presentation Descriptor (MPD) in [[!TS26234]], i.e. &ldquo;video/vnd.3gpp.mpd&rdquo;, and in the HAS specification [[.OIPF_HAS2]]. If the OITF supports MPEG DASH content then it SHALL support the MIME type as specified for the Media Presentation Descriptor (MPD) in Annex C of [[!DASH]], i.e. &ldquo;<code>application/dash+xml</code>&rdquo;.</p>
<p>The MPD SHALL be retrieved by specifying a URL. To this end, the OITF SHALL fetch the MPD from the URL, after which the MPD SHALL be interpreted and an initial (set of partial) Representation(s) selected.</p>
<p>When the URL is passed to the OITF in the <code>data</code> property of a A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a>, and either a HAS MPD is not valid according to the XML Schema and semantics as defined in <a href="volume2a.html#oipf-has-mpd-schema" class="extRef">Annex A</a> of [[.OIPF_HAS2]] or an MPEG DASH MPD is not valid according to the XML Schema and semantics as defined in [[!DASH]] or [[.OIPF_HAS2]], then the A/V Control object SHALL go to play state 6 ('error'), with error value 4 ('content corrupt or invalid').</p>
<p>If the OITF supports HAS content then HAS SHALL also be supported through the <a href="#video-broadcast" class="apiRef">video/broadcast</a> object for live content. If the OITF supports MPEG DASH content then MPEG DASH SHALL also be supported through the video/broadcast object for live content. This SHALL be done using <a href="#channel-class">Channel</a> objects returned from calls to the <code>createChannelObject( Integer idType, Integer onid, Integer tsid, Integer sid, Integer sourceID, String ipBroadcastID )</code> method where the <code>idType</code> argument is <code>ID_IPTV_URI</code> and the <code>ipBroadcastID</code> argument is a URL which points to an MPD for Scheduled Content (live streaming) over HTTP.</p>
</section>
<section id="multicast-streaming">
<h4>Multicast streaming</h4>
<p>If an OITF has indicated support for IPTV channels through a <code>&lt;video_broadcast&gt;</code> element with type ID_IPTV_* (as defined in section <a href="#channel-constants" class="sectionRef"></a>) the OITF SHALL support passing a content-access descriptor through the '<code>contentAccessDescriptorURL</code>' argument of the '<a href="#video-broadcast-setchannel" class="apiRef">setChannel</a>'-method of the <a href="#video-broadcast" class="apiRef">video/broadcast</a> object (as defined in section <a href="#video-broadcast-methods" class="sectionRef"></a>). If the content-access descriptor includes DRM information, the OITF SHALL pass this information to the DRM agent.</p>
</section>
</section>
</section>
<section id="scheduled-content">
<h2>Scheduled Content</h2>
<p>If an OITF has indicated support for playback and control of scheduled content through the <code>&lt;video_broadcast&gt;</code> element, then it SHALL support the &ldquo;<a href="#video-broadcast" class="apiRef">video/broadcast</a>&rdquo; embedded object defined in section <a href="#video-broadcast" class="sectionRef"></a>. In addition, it SHALL adhere to the requirements for conveyance of the channel list as specified in section <a href="#conveyance-of-channel-list" class="sectionRef"></a>. To protect against unauthorized access to the tuner functionality and people's personal favourite lists, the OITF SHALL adhere to the security model requirements as specified in section <a href="#application-service-security" class="sectionRef"></a>, in particular the tuner related security requirements in section <a href="#security-requirements-for-tuner-control" class="sectionRef"></a>.
NOTE: This section and section <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a> are focused on control and display of scheduled content received over local tuner functionality available to an OITF. The term &ldquo;tuner&rdquo; is used here to identify a piece of functionality to enable switching between different types of scheduled content services that are identified through logical channels. This includes IP broadcast channels (using the mechanisms for Scheduled Content defined in [[.OIPF_PROT2]]), as well as traditional broadcast channels received over a hybrid tuner.
NOTE 2: The APIs in this section allow for deployments whereby the channel line-up and favourite lists for broadcasted content are managed by the client, the server, or a mixture thereof.</p>

<section id="conveyance-of-channel-list">
<h3>Conveyance of channel list</h3>
<p>To enable a service to control the tuner functionality on an OITF, the OITF needs to convey the channel list information that is managed by native code on the OITF device to the service (either the channel list information is provided locally on the OITF via JavaScript, or the channel list is communicated directly to a server). This information includes the list of uniquely identifiable channels that can be received by the physical tuner of a hybrid device, including information about how the channels are ordered and whether or not these channels are part of zero or more favourite lists. It also includes the channel line-up and the favourite lists that MAY be managed by an OITF for IP broadcast channels.<p>
<p>The API supports two methods of conveying the channel list information to a service:</p><ol>
<li>Method 1: through JavaScript, by using the method &ldquo;<a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a>&rdquo;, as defined in section <a href="#method-1-getchannelconfig" class="sectionRef"></a>.
<li>Method 2: through an HTTP POST message that is sent upon the first connection to a service that requires tuner control, as defined in section <a href="#method-2-http-post" class="sectionRef"></a>.
</ol>
<p>An OITF SHALL support method 1, and SHOULD support method 2.</p>
<p>If an OITF conveys the channel list information using the HTTP POST message defined in method 2, then the server SHALL, if it supports method 2, receive the conveyed channel list information and SHOULD rely on this information for the purpose of exerting tuner control. If a service supports using the channel list information sent through the HTTP POST method to exert tuner control , the server SHALL indicate this compatibility with method 2 using the <code>postList</code> attribute specified in section <a href="#tuner-broadcast-capability" class="sectionRef"></a> (i.e., <code>&lt;video_broadcast postList="true"&gt;true&lt;/video_broadcast&gt;</code>), in the server capability description.</p>
<p>If the server does not support method 2, the service SHALL rely on the <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a> method defined in section <a href="#video-broadcast-methods" class="sectionRef"></a> to access the channel list information. If an OITF does not support method 2, the HTTP message of the first connection to the service that requires tuner control SHALL be an HTTP GET message with an empty payload and the service SHALL instead rely on the <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a> method defined in section <a href="#video-broadcast-methods" class="sectionRef"></a> to access the channel list information. If support for method 2 is indicated by both the OITF and the server (through respective capability exchanges), the OITF SHALL convey the channel list information using method 2.</p>
<p>If an OITF does not manage/maintain the channel line-up (i.e. does not have a locally stored channel line up), the <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a> method described in section <a href="#video-broadcast-methods" class="sectionRef"></a> SHALL return <code>null</code>, and the HTTP message described in section <a href="#method-2-http-post" class="sectionRef"></a> SHALL be an HTTP GET message with an empty payload. In that case, the application MAY use the <a href="#video-broadcast-createchannelobject-dsd" class="apiRef">createChannelObject()</a> method as defined in section <a href="#video-broadcast-methods" class="sectionRef"></a> to create channel objects that can be used on subsequent <a href="#video-broadcast-setchannel" class="apiRef">setChannel()</a> requests, and in this way can manage/maintain its own channel list.</p>
<p>NOTE: conveyance of the channel list SHALL adhere to the security model requirements as specified in sections <a href="#security-requirements-for-tuner-control-and-lineup" class="sectionRef"></a> and <a href="#security-requirements-for-exposure-of-the-tuner-channel-lineup" class="sectionRef"></a>.</p>
<section id="method-1-getchannelconfig">
<h4>Method 1: JavaScript method &ldquo;getChannelConfig()&rdquo;</h4>
<p>The OITF SHALL support method &ldquo;<a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a>&rdquo; as defined in section <a href="#video-broadcast-methods" class="sectionRef"></a> for the <a href="#video-broadcast" class="apiRef">video/broadcast</a> embedded object. This method returns a <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> object as defined in section <a href="#channelconfig-class" class="sectionRef"></a>.</p>
</section>
<section id="method-2-http-post">
<h4>Method 2: HTTP POST message</h4>
<p>If an OITF supports sending the channel list through HTTP POST and a server has indicated that it uses the posted channel list information to exert control of the tuner functionality of an OITF (i.e. using attribute <code>postList="true"</code> in the server capability description) for a particular service, then the OITF SHALL issue an HTTP POST over TLS if it decides to connect to that service. The body of the HTTP POST over TLS request SHALL contain the Client Channel Listing, which SHALL adhere to the semantics, syntax and XML Schema that are defined for the Client Channel Listing in Annex <a href="#client-channel-listing-format" class="sectionRef"></a>. The server SHALL silently ignore unknown elements and attributes that are part of the Client Channel Listing.</p>
<p>The server SHALL return a HTML document.</p>
<p>If the favourite lists are not (partially) managed by the OITF, the Client Channel Listing SHALL neither contain the &ldquo;<code>FavouriteLists</code>&rdquo; nor the &ldquo;<code>CurrentFavouriteList</code>&rdquo; element.</p>
</section>
</section>

<section id="conveyance-of-channel-list-and-list-of-scheduled-recordings">
<h3>Conveyance of channel list and list of scheduled recordings</h3>
<p>This section and the following sections SHALL apply to OITFs that have indicated <code>&lt;recording&gt;true&lt;/recording&gt;</code> as defined in section <a href="#pvr-capability" class="sectionRef"></a> in their capability profile.</p>
<p>To enable a service to schedule recordings of content that is to be broadcasted on specific channels, the OITF needs to convey the channel list information that is managed by the native code on the OITF. This information typically includes the channel line-up of the tuner of a hybrid device. The conveyance of channel list information and scheduled recordings is based on the same two methods of conveying the channel list information to a service as defined in section <a href="#conveyance-of-channel-list" class="sectionRef"></a>:</p><ol>
<li>Method 1: through JavaScript, by using the method &ldquo;<a href="#oipfrecordingscheduler-getchannelconfig" class="apiRef">getChannelConfig()</a>&rdquo;. To this end, the OITF SHALL support method &ldquo;<a href="#oipfrecordingscheduler-getchannelconfig" class="apiRef">getChannelConfig()</a>&rdquo; as defined in section <a href="#application-oipfrecordingscheduler-methods" class="sectionRef"></a> for the <a href="#application-oipfrecordingscheduler" class="apiRef">application/oipfRecordingScheduler</a> object.
<li>Method 2: through an HTTP POST message as defined in section <a href="#method-2-http-post" class="sectionRef"></a> that is sent upon the first connection to a service that has indicated that it requires control of the recording functionality and that has indicated compatibility with method 2 using the <code>postList</code> attribute specified in section <a href="#pvr-capability" class="sectionRef"></a> (i.e., <code>&lt;recording postList="true"&gt;true&lt;/recording&gt;</code>), in the server capability description for a particular service.
</ol>
<p>An OITF SHALL support method 1, and SHOULD support method 2. If support for method 2 is indicated by both the OITF and the server (through respective capability exchanges), the OITF SHALL convey the channel list information using method 2. Otherwise, the HTTP message of the first connection to the service that requires tuner control SHALL be an HTTP GET message with an empty payload.</p>
<p>If a server has indicated that it requires control of both the tuner functionality and the recording functionality available to an OITF (i.e. by including both &lt;video_broadcast&gt; and &lt;recording&gt; with value <code>true</code> in the OITF's capability description), the body of the HTTP POST message SHALL contain a single instance of the Client Channel Listing whereby the &lt;Recordable&gt; element defined in Annex <a href="#client-channel-listing-format" class="sectionRef"></a> SHALL be used to indicate whether channels that can be received by the tuner of the OITF can be recorded or not.</p>
<p>If an OITF does not manage the channel line-up, the <a href="#oipfrecordingscheduler-getchannelconfig" class="apiRef">getChannelConfig()</a> method described in section <a href="#application-oipfrecordingscheduler-methods" class="sectionRef"></a> SHALL return null, and the HTTP message described in section <a href="#method-2-http-post" class="sectionRef"></a> SHALL be an HTTP GET message with an empty payload.</p>
<p>In addition, the OITF SHALL also support method <a href="#oipfrecordingscheduler-getscheduledrecordings" class="apiRef">getScheduledRecordings()</a> as defined in <a href="#application-oipfrecordingscheduler-methods" class="sectionRef"></a>. This method returns a <a href="#scheduledrecordingcollection-class" class="apiRef">ScheduledRecordingCollection</a> object, which is defined in section <a href="#scheduledrecordingcollection-class" class="sectionRef"></a>.</p>
<p>Note that the conveyance of the channel listing and the scheduled recordings is subject to the security model requirements specified in section <a href="#application-service-security" class="sectionRef"></a>, and in particular the recording related security requirements in section <a href="#security-requirements-for-recording" class="sectionRef"></a>.</p>
</section>
</section>
<section id="dlna-remote-control-function">
<h2>DLNA RUI Remote Control Function</h2>
<p>This section describes the DLNA RUI RCF (Remote Control Function) and the interactions between the different entities involved. It builds on the RUI feature defined by the DLNA Networked Device Interoperability Guidelines (August 2009) [[!DLNA]] and shows how the DLNA RUI can be integrated into an OITF and used by DAE applications.</p>
<p>The DLNA RUI RCF is the feature that enables a Remote Control Device to be able to control the OITF or a DAE application running on it, from that Remote Control Device. To support this feature, a Remote Control Device SHALL support the DLNA RUIC function and an OITF SHALL support the DLNA RUIS function (as defined in section <a href="#dlna-rui-remote-control-function-apis" class="sectionRef"></a>).</p>
<p>The DLNA RUI RCF provides two main features:<ul>
<li>Providing a Control UI to the Remote Control Device.<ul>
<li>The Control UI is a CE-HTML document through which the user will control the OITF directly or a DAE application on the OITF. There are two options based on the origin of the Control UI for sourcing it as follows:<ul>
<li>Sourcing the Control UI from the OITF itself.
<li>Sourcing the Control UI from an IPTV Applications server via the OITF.
</ul></ul>
<li>Interactions to exchange control messages and results<ul>
<li>The Control UI in the DLNA RUIC sends control messages to the OITF or DAE application and receives the corresponding results.
</ul></ul>
<p>The following sections will introduce the interfaces between the entities that support the DLNA RUI RCF.</p>
<section id="dlna-remote-control-function-interfaces">
<h3>Interfaces used by the DLNA RUI Remote Control Function</h3>
<p>This section describes interfaces related to the DLNA RUI RCF. There are three entities (Remote Control Device, OITF and IPTV Applications server) that communicate with each other through the interfaces described in Figure <a href="#oipf-with-dlna-interfaces" class="figureRef"></a>.</p>
<figure id="oipf-with-dlna-interfaces">
<img alt="FIGURE 2" src="images/OIPF-with-DLNA.png" />
<figcaption>Figure ####: OIPF architecture with DLNA RUI RCF scenario</figcaption>
</figure>
<p>Figure <a href="#oipf-with-dlna-interfaces" class="figureRef"></a> shows the entities in the OIPF Architecture involved in the DLNA RCF and the interfaces between them.</p>
<p>The dotted line &ldquo;d)&rdquo; between the RCF embedded object and the DLNA RUIS indicates that it is a local interface and hence not defined by this specification. The detailed behaviour of each interface is defined as follows:<ol>
<li>Interface a)<br />
This interface is used to retrieve a Control UI from an IPTV Applications server by using XMLHttpRequest object (the Control UI retrieved through interface a) will be delivered to DLNA RUIC via interfaces c), d) and e), sequentially).
<li>Interface b)<br />
This interface is used by the DAE browser to retrieve a DAE application containing an RCF object when the DLNA RUIC requests a DAE application to execute in the OITF.
<li>Interface c)<br />
The DLNA RUI RCF APIs use this interface to enable a DAE application to get the request originating from the DLNA RUIC, through an event dispatched by the OITF, and send the corresponding response or any other information to the DLNA RUIC via the DLNA RUIS.
<li>Interface d)<br />
This is a local interface that is used to pass messages between an RCF object in a DAE application and the DLNA RUIS.
<li>Interface e)<br />
This is a DLNA RUI compatible interface which provides device discovery, sending/receiving HTTP messages and notifications.<br />
When the DLNA RUIC is activated by a user, the DLNA RUIC searches for a DLNA RUIS and does a capability exchange. Then, the DLNA RUIC retrieves the XML UI Listing from the DLNA RUIS and displays it to the user. When the user chooses one of the Control UIs, the DLNA RUIC retrieves the selected Control UI from the DLNA RUIS in the OITF.<br />
The Control UI may send an HTTP request to deliver a message (for example, plays an AV content) and receive a response from the DLNA RUIS.<br />
This interface is also used for the DLNA RUIS to send a 3<sup>rd</sup> party notification defined in section 5.6.1 of [[!CEA-2014-A]].
<li>Interface f)<br />
This interface is used by the selected Control UI (CE-HTML document) to retrieve resources (For example, images, CE-HTML documents, or css or JavaScript files) directly from the IPTV Applications server.
</ol>
</section>
</section>

<section id="power-consumption">
<h2>Power Consumption</h2>
<p>The power states described in this section relate to states exposed to the DAE application. There may be other states supported by the OITF which are not described here.</p>
<p>The OITF will be in one of a number of power states. Its default state is &ldquo;off&rdquo; which consumes no power. The OITF SHALL support an &ldquo;on&rdquo; state where it is running in normal operation. The OITF SHALL support at least one standby state where nothing is being output to the display but power is consumed. An OITF may support two different standby states, &ldquo;active standby&rdquo; and &ldquo;passive standby&rdquo;. An OITF in the &ldquo;passive standby&rdquo; state has the smallest possible power consumption (for example, average under 1W) which may be in line with European Commission Code of Conduct, US Energy Star or other regional requirements. In this state the IR listener and wakeup clock MAY be active but no DAE application is active. The IR listener allows the user to turn on the OITF using a remote control. A DAE application MAY use the wakeup clock to schedule the OITF enter the &ldquo;active standby&rdquo; state, for example to perform a recording.</p>
<p>Note there may be different levels of &ldquo;active standby&rdquo; state but the assumption is that, at least, nothing is being output to the display and one or more DAE applications may execute in the background.</p>
<p>The following explanation describes the behaviour of the OITF when transitioning between the mentioned states and how a DAE application is affected.</p>
<p>A DAE application SHALL be able to execute in the &ldquo;on&rdquo; and &ldquo;active standby&rdquo; states but SHALL NOT be able to execute in the &ldquo;off&rdquo; or &ldquo;passive standby&rdquo; states.</p>
<p>When an OITF is turned &ldquo;on&rdquo; from an &ldquo;off&rdquo; state a DAE application has to be explicitly selected by the user to be executed or the OITF has identified a DAE application to be auto-started. A DAE application has no direct control if it shall auto-start or not and this is left for the OITF to manage. A DAE application MAY auto-start if the Service Discovery and Selection has taken place and the user has selected a service provider.</p>
<p>When an OITF changes to an &ldquo;off&rdquo; or &ldquo;passive standby&rdquo; state from an &ldquo;on&rdquo; or &ldquo;active standby&rdquo; state, the DAE application SHALL get an <code>ApplicationDestroyRequest</code> event. The DAE application has an opportunity to take a final action and gracefully quit or it shall be killed forcibly.</p>
<section id="wake-up-support">
<h3>DAE application wake-up support</h3>
<p>The OITF MAY support wake-up requests from a &ldquo;passive standby&rdquo; state. There are two types of wake-up requests, one on an individual DAE application and one on the OITF. The supported wakeup is indicated in the power consumption capability information.</p>
<section id="single-dae-application-wakeup">
<h4>Single DAE application wakeup</h4>
<p>The OITF MAY support wake-up requests for individual DAE applications when in &ldquo;passive standby&rdquo;. Similar to a scheduled recording, a DAE application may need to execute at a predetermined time. At the wake-up point the DAE application executes and when it completes its task returns to a &ldquo;passive standby&rdquo; state by exiting.</p>
<p>There SHALL only be one wake-up request per DAE application. There MAY be multiple wake-up requests from different DAE applications which SHALL execute independently. The OITF SHALL silently ignore all wake-up requests whose timers expire when it is not in the &ldquo;passive standby&rdquo; state.</p>
<p>When the DAE application terminates and the OITF changes to an &ldquo;active standby&rdquo; or &ldquo;on&rdquo; state for other reasons than a wake-up request the OITF SHALL NOT change power states.</p>
<p>Through capability information it is possible to determine if wake-up and standby modes are supported by OITF.
<p>This is an example of how a DAE application may setup a wake-up request in OITF.</p>
<p>Precondition: The DAE application is actively running and the OITF is either in &ldquo;on&rdquo; or &ldquo;active standby&rdquo; states.</p>
<ol>
<li>End user selects to go into &ldquo;passive standby&rdquo; natively.
<li>An <code>ApplicationDestroyRequest</code> event is generated
<li>The DAE application calls the <a href="#applicationprivatedata-preparewakeupapplication" class="apiRef">prepareWakeupApplication()</a> method and sets a token, time for wake-up and URI associated with the DAE application. The DAE application then quits, e.g. by calling <a href="#application-destroyapplication" class="apiRef">destroyApplication()</a> on its parent <a href="#application-class" class="apiRef">Application</a> object.
<li>The OITF goes into &ldquo;passive standby&rdquo; state.
<li>When the wake-up time triggers, the OITF changes to &ldquo;active standby&rdquo; and the DAE application is initiated with the URI specified in the prior call to <a href="#applicationprivatedata-preparewakeupapplication" class="apiRef">prepareWakeupApplication()</a>.
<li>The DAE application then runs <a href="#applicationprivatedata-clearwakeuptoken" class="apiRef">clearWakeupToken()</a> to get the token set in the prior call to <a href="#applicationprivatedata-preparewakeupapplication" class="apiRef">prepareWakeupApplication()</a>.
<li>The DAE application executes.
<li>Once the DAE application completes execution it shall exit. The OITF changes automatically to a &ldquo;passive standby&rdquo; state.
</ol>
<p>If the OITF is turned &ldquo;on&rdquo; while in this mode the OITF SHALL NOT enter &ldquo;passive standby&rdquo; state.</p>
</section>
<section id="oitf-wakeup">
<h4>OITF wakeup</h4>
<p>The OITF MAY support wake-up requests for the OITF when in &ldquo;passive standby&rdquo;. The application when receiving an event onApplicationRequest may request to wake-up the OITF at a set time using method <a href="#applicationprivatedata-preparewakeupoitf" class="apiRef">prepareWakeupOITF()</a>.</p>
<p>OITF SHALL silently ignore all wake-up requests whose timers expire when it is not in the &ldquo;passive standby&rdquo; state.</p>
</section>
</section>
<section id="oitf-hibernate-support">
<h3>OITF hibernate support</h3>
<p>The OITF MAY support a hibernate mode which allows DAE applications and their state to be stored in memory when in a &ldquo;passive standby&rdquo; state. The support of a hibernate mode greatly reduces the start-up time for DAE applications (for example, start-up times of 3 seconds may be reached).</p>
<p>When the OITF resumes from the hibernate mode, it SHALL restore all of the previous DAE applications with their previous state and SHOULD assign the same resources to the DAE applications as they had prior to the hibernate mode. If this is not possible, the regular callback functions SHALL be used to inform the affected DAE application.</p>
<p>If hibernate mode is supported the event <code>ApplicationHibernateRequest</code> is generated instead of <code>ApplicationDestroyRequest</code> when the OITF enters a &ldquo;passive standby&rdquo; state.</p>
<p>If the OITF supports hibernate mode only the OITF wake-up request is supported. The single DAE application wake-up SHALL NOT be supported. The reason for this limitation is due to the difficulty to support both options.</p>
<p>A wake-up support SHALL NOT make the OITF resume from the hibernate mode. The wake-up support SHALL be supported independently.</p>
<p>The OITF SHALL indicate support for hibernate mode through the <code>&lt;hibernateMode&gt;</code> capability defined in section <a href="#power-consmption-support" class="sectionRef"></a>.</p>
</section>
<section id="state-diagram-for-the-power-state">
<h3>State diagram for the power state</h3>
<p>The following state machine provides an overview of the power state changes that may occur relating to power consumption. The transitions in the state machine due to <a href="#localsystem-setpowerstate" class="apiRef">setPowerState()</a> may be also be triggered by user generated events handled natively by the OITF.</p>
<figure id="state-diagram-of-oitf-power-states">
<img alt="FIGURE 3" src="images/Power-States-Diagram.png" />
<figcaption>Figure ####: State diagram of OITF power states</figcaption>
</figure>
<p>NOTE 1: The transition from the OFF state to the <code>PASSIVE_STANDBY</code> or <code>ON</code> states is manufacturer dependent</p>
</section>

</section>
<section id="display-model">
<h2>Display Model</h2>
<p>Annex <a href="#display-model-annex" class="sectionRef"></a> describes the logical display model of an OITF and the relationship between DAE application graphics and video.</p>
</section>
</section>  <!-- section 4 -->

<!-- section 5 -->
<section id='dae-application-model'>
<h1>DAE Application Model</h1>
<section id="application-lifecycle">
<h2>Application Lifecycle</h2>
<p>This section describes the lifecycle of a DAE application, including when an application is launched, when it is terminated and the behaviour when a DAE leaves the boundary of one application and enters another.</p>
<p>APIs related to DAE applications are described in section <a href="#applications-management-apis" class="sectionRef"></a> &ldquo;<a href="#applications-management-apis" class="sectionTitleRef"></a>.</p>
<section id="creating-a-new-application">
<h3>Creating a new application</h3>
<section id="creating-a-new-application-general">
<h4>General</h4>
<p>The present document defines a number of different application lifecycle models. These include;</p><ul>
<li>Applications started through an OITF-specific user interface
<li>Using the <a href="#application-createapplication" class="apiRef">Application.createApplication()</a> API call
<li>CE-HTML third party notifications
<li>Service provider related applications (from SD&amp;S signalling)
<li>Applications started by the DRM agent
<li>Applications provided by the AG through the remote UI
<li>Broadcast-related applications (either be from SD&amp;S signalling or from broadcast signalling in a hybrid device) 
<li>Broadcast independent applications
<li>Widgets
</ul>
</section>
<section id="creating-a-new-application-bi-apps">
<h4>Broadcast-independent applications</h4>
<p>Broadcast-independent applications are started by fetching the first page of the application from a URL.</p>
</section>
<section id="creating-a-new-application-oitf=ui">
<h4>Applications started through an OITF-specific user interface</h4>
<p>These SHALL be presented as broadcast-independent applications.</p>
</section>
<section id="creating-a-new-application-createapplication">
<h4>Using the Application.createApplication() method</h4>
<P>Creating a new application is accomplished by creating a new <a href="#application-class" class="apiRef">Application</a> object via the <a href="#application-createapplication" class="apiRef">Application.createApplication()</a> method. Calling this method will create a new application and add it to the application tree in the appropriate location.</p><pre class="javascript">
// Assumes that the application/oipfApplicationManager object has the ID 
// &ldquo;applicationmanager&rdquo;
var appMgr = document.getElementById("applicationmanager");
var self = appMgr.getOwnerApplication(Window.document);

// create the application as a child of the current application
var child = self.createApplication( url_of_application, true );
</pre>
<p>The URL passed to the <a href="#application-createapplication" class="apiRef">createApplication()</a> method SHALL be one of the following;</p><ul>
<li>An HTTP or HTTPS URL referring to an XHTML page as defined by section <a href="#web-standards-tv-profile" class="sectionRef"></a> of this specification.
<li>An HTTP or HTTPS URL referring to an XML AIT as defined by section <a href="#signalling-format-xml-encoding" class="sectionRef"></a> of this specification.
<li>The DVB URI for launching service provider related applications signalled through SD&amp;S as defined in section <a href="#uri-schemes" class="sectionRef"></a> of this specification
<li>The DVB URI for launching broadcast-related applications from the current service signalled through SD&amp;S as defined in section <a href="#uri-schemes" class="sectionRef"></a>  of this specification. Where an OITF supports the MPEG-2 encoding of the AIT as defined in section <a href="#mpeg-2-encoding" class="sectionRef"></a>, this form of the DVB URI SHALL also be supported for launching broadcast-related applications from the current service when that service includes an MPEG-2 AIT.
</ul>
</section>
<section id="creating-a-new-application-3rd-party-notifications">
<h4>CE-HTML third party notifications</h4>
<p>The lifecycle of these is defined by [[!CEA-2014-A]] and summarised in section <a href="#CEA2014-notifications" class="sectionRef"></a> of the present document.</p>
</section>
<section id="starting-applications-from-sdns">
<h4>Starting applications from SD&amp;S Signalling</h4>
<p>These are described in section <a href="#application-announcement-and-signalling" class="sectionRef"></a>, &ldquo;<a href="#application-announcement-and-signalling" class="sectionTitleRef"></a>&rdquo;. All applications started by SD&amp;S signalling are treated as siblings and are children of the hidden system root node (see section <a href="#application-tree" class="sectionRef"></a>).
</section>
<section id="starting-applications-from-drm-agent">
<h4>Applications started by the DRM agent</h4>
<p>These SHALL be considered as broadcast-independent applications.</p>
</section>
<section id="applications-provided-by-the-ag">
<h4>Applications provided by the AG through the remote UI</h4>
<p>OITFs MAY include the capability to start these applications from an embedded application. OITFs SHALL include the ability for applications to discover these as defined by the &ldquo;<a href="#application-oipfgatewayinfo" class="apiRef">application/oipfGatewayInfo</a>&rdquo; embedded object in section <a href="#application-oipfgatewayinfo" class="sectionRef"></a>.</p>
</section>
</section>
<section id="stopping-an-application">
<h3>Stopping an application</h3>
<p>The <a href="#application-destroyapplication" class="apiRef">destroyApplication()</a> method (as specified in section <a href="#application-class-methods" class="sectionRef"></a>) SHALL terminate the application. An application may register a listener on the <code>ApplicationDestroyRequest</code> event in order to perform any clean-up before being destroyed completely. After the <a href="#application-destroyapplication" class="apiRef">destroyApplication()</a> method returns, further execution of the specified application SHALL NOT occur.</p>
<p>When an application is terminated, all associated resources SHALL be freed (or marked available for garbage collection).  Any active network-related sessions will be terminated.  Any media content being presented by the application is stopped, although recordings or content downloads initiated by the application will not be affected.</p>
<p>Note that terminating an application does not imply any effect on the state of the DAE environment.</p>
<p>Additional requirements are defined for stopping selected service provider applications and applications part of scheduled content services in sections <a href="#service-provider-related-applications-stopping" class="sectionRef"></a> and <a href="#broadcast-related-applications-stopping" class="sectionRef"></a> respectively.</p>
</section>
<section id="application-boundaries">
<h3>Application Boundaries</h3>
<p>All of the pages that make up an application are contained within its application boundary. This is the &ldquo;fully qualified domain name&rdquo; (FQDN) of the initial page of the application in the absence of an application_boundary_descriptor. </p>
<p>If an <code>applicationBoundary</code> element is present in the SD&amp;S signalling for an application as defined in [[!TS102809]], the application boundary SHALL also include the FQDNs listed in the <code>applicationBoundary</code> element. If this element is not present, then the application boundary SHALL consist of the FQDN of the initial page of the application.</p>
<p>For files requested with XMLHttpRequest, the same origin policy SHALL be extended using the application domain; i.e. any domain in the application domain SHALL be considered of same origin.</p>
<p>The OITF SHALL remove any IP address in the application boundary which is within the private address space as defined in [[!RFC1918]], before launching the application.</p>
<p>Extending the origin of XMLHttpRequest is potentially dangerous, and may lead to undesired leaking of private information. To make sure that the integrity of the user is not compromised, the OITF SHOULD include a mechanism which allows the user to exclude domains from application boundaries of applications.</p>
</section>
</section>
<section id="application-announcement-and-signalling">
<h2>Application announcement &amp; signalling</h2>
<section id="application-announcement-and-signalling-introduction">
<h3>Introduction</h3>
<p>This specification defines 3 basic types of application;</p><ul>
<li>Applications related to one or more broadcast TV or radio channels. These MAY run while one of the channels which they are related to is being presented by the OITF. These are signalled through the SD&amp;S broadcast or package discovery records or included in an application discovery record which is referenced from the broadcast or package discovery record.
<li>Applications related to the service provider selected through the service selection process. These MAY run at any time until the service provider selection process is repeated and a different service provider selected. These are signalled through the SD&amp;S service provider discovery record or included in an application discovery record which is referenced from the service provider discovery record.
<li>Applications independent of either of the above. These MAY run at any time. These are started by other applications and are not signalled anywhere.
</ul>
<p>Each of these types is described in more detail below.</p>
</section>
<section id="application-announcement-and-signalling-general">
<h3>General</h3>
<p>Section <a href="#application-tree" class="sectionRef"></a> of this specification describes how one application may start another application either as a sibling or as a child. All applications started via SD&amp;S signalling as described in this section SHALL be started as children of the hidden system root node, as described in section <a href="#starting-applications-from-sdns" class="sectionRef"></a>.</p>
<p>Any application may be signalled as AUTOSTART or PRESENT (see &ldquo;Table <a href="#dae-application-control-codes" class="tableRef"></a>: <a href="#dae-application-control-codes" class="tableTitleRef"></a>&rdquo; below and section 5.2.4.3 of [[!TS102809]]). Applications signalled as AUTOSTART are intended to be automatically started by the OITF. Applications signalled as PRESENT are intended to be started only by other applications. Broadcast related applications may alternatively be signalled as KILL (see below) or PREFETCH.</p>
<p>It is up to the OITF manufacturer to ensure a good quality of experience concerning;</p><ul>
<li>Navigation within a DAE application. 
<li>Accessing the available DAE applications, both available for launch, and those already running.
<li>Managing the life cycles of all DAE applications able to be used concurrently.
</ul>
<p>It is outside the scope of this specification whether there are dedicated keys on a remote control (e.g. the "menu", "home" or "guide" key), there is an entry in an on-screen menu or there are some other mechanism.</p>
<p>It is OPTIONAL for the OITF to support an exit mechanism directly accessible by the end-user. If one is supported, it is outside the scope of this specification whether this mechanism is a button on a remote control, an item in an on-screen menu or something else. If such a mechanism is supported then it SHALL only stop the application the end-user is currently interacting with and any child applications of that application. The parent application and any siblings SHALL NOT be stopped. </p>
<p>Additionally any application MAY be stopped under the following circumstances;</p><ul>
<li>The application itself exits.
<li>Its parent application exits.
<li>It is stopped by the application which started it or another application which has a reference to its application object.
<li>In response to changes in the application signalling as defined below for broadcast related applications and service provider related applications.
</ul>
<p>In all these above cases except the first (when an application itself exits) when an application is stopped by the OITF, an ApplicationDestroyRequest event (as defined in section <a href="#new-dom-events-for-application-support" class="sectionRef"></a>) SHALL be raised on the application. In the following error conditions, an application being stopped SHOULD have an ApplicationDestroyRequest event raised if this is possible.</p><ul>
<li>The OITF runs out of resources for applications and has to stop some of them in order to keep operating correctly.
<li>The OITF has determined that an application is non-responsive or has crashed.
</ul>
</section>
<section id="broadcast-related-applications">
<h3>Broadcast related applications</h3>
<section id="broadcast-related-applications-general">
<h4>General</h4>
<p>Providers of broadcast TV channels may signal broadcast related applications as part of the SD&amp;S broadcast discovery record (see <a href="volume3.html#application-announcement-and-signalling" class="extRef">section 3.2.3</a> of [[.OIPF_META2]], as well as sections 4.2.1 and 5.4.3.2 of [[!TS102809]]). As an optimisation, broadcast related applications which are associated with a group of channels may be signalled as part of the SD&amp;S package discovery record (see <a href="volume3.html#application-announcement-and-signalling" class="extRef">section 3.2.3</a> of [[.OIPF_META2]], as well as section 5.4.3.1 of [[!TS102809]]). Broadcast related applications may be included in the SD&amp;S broadcast discovery or package discovery records or included in an application discovery record which is referenced from the broadcast discovery record.</p>
<p>Broadcast-related applications can also be signalled in-line in an MPEG-2 transport stream using the MPEG-2 encoding of the AIT as defined in section <a href="#mpeg-2-encoding" class="sectionRef"></a>.</p>
<p>When a broadcast TV channel starts being presented, the OITF SHALL follow the &ldquo;Procedure for Starting and Stopping Broadcast Related Applications on Channel Change&rdquo; defined in section <a href="#procedure-for-starting-and-stopping-broadcast-related-applications-on-channel-change" class="sectionRef"></a>.</p>
<p>While a broadcast TV channel is being presented, the OITF SHALL monitor for changes in the SD&amp;S information as defined by <a href="volume3.html#update-mechanism-for-sdns" class="extRef">section 4.1.1.2</a> of [[.OIPF_META2]]. </p>
<p>When changes are detected, the OITF SHALL follow the &ldquo;Procedure for Starting and Stopping Broadcast Related Applications When Signalling is Updated&rdquo; defined below.</p>
<p>NOTE: The typical &ldquo;red button&rdquo; behaviour can be achieved by having the first page of an AUTOSTART broadcast related application be full screen and transparent to video except for an image showing a red button. Only when the user generates a &ldquo;red&rdquo; key event does the application display more of its user interface.</p>
<p>OITFs MAY include the capability to start and stop a broadcast-related DAE application instead of analogue teletext services as part of a scheduled content service or channel. Typically this would re-purpose the same mechanism used to start an analogue teletext service &mdash; for example a &ldquo;text&rdquo; button on a remote control. These are identified using the application usage mechanism defined in [[!TS102809]] and section <a href="#signalling-format" class="sectionRef"></a> below.</p>
</section>
<section id="broadcast-related-applications-stopping">
<h4>Stopping</h4>
<p>In addition to what is stated in section <a href="#application-announcement-and-signalling-general" class="sectionRef"></a>, broadcast related applications are stopped when</p><ul>
<li>Changing between channels as defined in the &ldquo;Procedure for Starting and Stopping Broadcast Related Applications on Channel Change&rdquo; below.
<li>The OITF detects an update to the signalling for a currently presented channel as defined in &ldquo;Procedure for Starting and Stopping Broadcast Related Applications When Signalling is Updated&rdquo; below.
<li>The OITF stops presenting any broadcast channel.
</ul>
</section>
<section>
<h4>Procedure for starting and stopping broadcast related applications on channel change</h4>
<p>When a scheduled content service is selected, the following SHALL apply;</p><ul>
<li>The OITF shall determine if there are any applications signalled as part of the service as defined by sections <a href="volume3.html#service-provider-related-application-signalling" class="extRef">3.2.3.1</a> and <a href="volume3.html#broadcast-related-app-signalling" class="extRef">3.2.3.2</a> of [[.OIPF_META2]].
<li>Applications which are related to that scheduled content service and which are signalled with a control code of AUTOSTART SHALL be started if not still running from any previously presented linear TV service. They SHALL be started commencing with the highest priority application working downwards in priority while resources in the OITF permit. 
<li>Applications which are related to that scheduled content service, which are signalled with a control code of AUTOSTART and which are already running from a previously presented scheduled content service SHALL:<ol type="a">
<li>continue to run uninterrupted if the <code>serviceBound</code> element of the <code>ApplicationDescriptor</code> in their signalling has value <code>false</code>
<li>be stopped and re-started if the <code>serviceBound</code> element of the <code>ApplicationDescriptor</code> in their signalling has value <code>true</code></ol>
<li>Applications which are related to that scheduled content service and which are signalled with a control code of PRESENT SHALL continue to run if already running but SHALL NOT be started if not already running.
<li>Running applications from any previously presented scheduled content service which are not part of the new scheduled content service SHALL be stopped as part of the change of presented service.
</ul>
<p>The following flowchart shows the behaviour that SHALL apply when the selected channel changes:</p>
<figure>
<img alt="FIGURE 4" src="images/BehavoiurWhenSelectedChannelChanges.png" />
<figcaption>Figure ####: Behaviour when the selected channel changes</figcaption>
</figure>
</section>
<section>
<h4>Procedure for starting and stopping broadcast related applications when signalling is updated</h4>
<p>When the application signalling for a scheduled content service is updated, the following apply;</p><ul>
<li>Applications which are added to the service with a control code of AUTOSTART SHALL be automatically started when their addition is detected by the OITF.  They SHALL be started commencing with the highest priority application working downwards in priority while resources in the OITF permit. Applications added to the service with any other control code SHALL NOT be automatically started.
<li>Applications which are part of the service whose control code changes to AUTOSTART from some other value SHALL be automatically started unless already running.
<li>An application which is removed from the service or whose control code changes to KILL SHALL be stopped.
</ul>
<p>If application signalling is removed from a service, all running broadcast-related applications SHALL be stopped (i.e. the same behaviour as signalling an empty AIT).</p>
<p>The following flowchart shows the behaviour that SHALL apply when the application signalling for the currently selected service changes, or when a running broadcast-related application exits:</p>
<figure>
<img alt="FIGURE 5" src="images/BehaviourWhenTheApplicationSignallingForTheCurrentlySelectedChannelChanges.png" />
<figcaption>Figure ####: Behaviour when the application signalling for the currently selected channel changes or when a running broadcast-related application exits</figcaption>
</figure>
</section>
</section>
<section id="service-provider-related-applications">
<h3>Service provider related applications</h3>
<section id="service-provider-related-applications-signalling">
<h4>Signalling</h4>
<p>Service providers may signal service provider related applications as part of their SD&amp;S service provider discovery record (see  <a href="volume3.html#application-announcement-and-signalling" class="extRef">section 3.2.3</a> of [[.OIPF_META2]], also sections 4.2.3 and 5.4.3.3 of [[!TS102809]] where they are referred to as &ldquo;unbound applications&rdquo;). Service provider related applications may either be directly included in the SD&amp;S service provider discovery record or included in an application discovery record which is referenced from the service provider discovery record.</p> 
<p>Service providers MAY label one of the applications in their SD&amp;S service provider discovery record using the application usage values defined in <a href="volume3.html#applicationusage-in-applicationusagedescriptor" class="extRef">section 3.2.3.3.3</a> of [[.OIPF_META2]] as follows;</p><ul>
<li>A service discovery application  using the ApplicationUsage identifier <mark class="error">&ldquo;urn:oipf:cs:ApplicationUsageCS:2009:servicediscovery&rdquo;</mark>. An application labelled in this way SHOULD be the highest priority AUTOSTART application signalled. 
<li>An EPG application using the ApplicationUsage identifier <mark class="error">&ldquo;urn:oipf:cs:ApplicationUsageCS:2009:epg&rdquo;</mark>.
<li>A VoD application using the ApplicationUsage identifier <mark class="error">&ldquo;urn:oipf:cs:ApplicationUsageCS:2009:vod&rdquo;</mark>.
<li>A communication service application using the ApplicationUsage identifier <mark class="error">&ldquo;urn:oipf:cs:ApplicationUsageCS:2009:communication&rdquo;</mark>.
<li>An application implementing non-native HNI-IGI using the ApplicationUsage identifier <mark class="error">&ldquo;urn:oipf:cs:ApplicationUsageCS:2009:hni-igi&rdquo;</mark>.
</ul>
<div class="editor-note">The <a href="volume3.html#applicationusageCS">R2v2.3 version of the Metadata specification</a> defines these as :2010</div>
</section>
<section id="service-provider-related-applications-starting">
<h4>Starting</h4>
<p>Service provider related applications are started under the following circumstances;</p><ul>
<li>When a service provider is selected, the OITF SHALL start the AUTOSTART applications signalled by that service provider starting with the one with highest priority and working downwards in priority unless already running, while resources in the OITF permit. This process SHALL be repeated if an application previously launched by this process is closed for any reason. A consequence of this is that AUTOSTART service provider related applications are always running. Service provider related applications which are not required to be always running must not be signalled as AUTOSTART themselves but SHOULD be started by AUTOSTART applications.
<li>By the end-user using a mechanism provided by the OITF.
<li>By other service provider related applications.
</ul>
<p>The OITF SHALL include a mechanism to show the service discovery application and MAY include mechanisms to show the EPG, VoD and the communication service applications. These mechanisms;</p><ul>
<li>SHALL load the application into the browser if not already loaded.
<li>SHALL show this application to the end-user.
<li>SHALL work at all times when the currently selected service provider has an application labelled in this way. 
</ul>
<p>It is outside the scope of this specification whether these mechanisms are buttons on a remote control, items in an on-screen menu or something else. If a button is used, this mechanism SHALL work regardless of which application has focus and the key event corresponding to the button used SHALL NOT be delivered to DAE applications.</p>
</section>
<section id="service-provider-related-applications-stopping">
<h4>Stopping</h4>
<p>In addition to what is stated in section <a href="#application-announcement-and-signalling-general" class="sectionRef"></a>, service provider related applications are stopped when</p><ul>
<li>The service provider selection process is re-run and a different service provider is selected.
<li>The selected service provider updates the list of applications in their SD&amp;S service provider discovery record, an application is removed and the OITF detects this update (see <a href="volume3.html#update-mechanism-for-sdns" class="extRef">section 4.1.1.2</a> of [[.OIPF_META2]]).
</ul>
</section>
</section>
<section id="broadcast-independant-applications">
<h3>Broadcast independent applications</h3>
Applications which are independent of both broadcasters and the currently selected service provider are started and stopped as described in section <a href="#application-announcement-and-signalling-general" class="sectionRef"></a> &ldquo;<a href="#application-announcement-and-signalling-general" class="sectionTitleRef"></a>&rdquo;. They do not require any signalling. If they are signalled then this shall be done using the XML encoding of the AIT as defined in section 5.4 of [[!TS102809]]. The XML file shall contain an application discovery record containing exactly one application. The XML file shall be delivered with HTTP or HTTPS using the &ldquo;application/vnd.dvb.ait+xml&rdquo; MIME type as defined in section 5.4 of [[!TS102809]].
</section>
<section>
<h3>Switching between applications</h3>
<p>Two cases of switching between applications are relevant in this specification;</p><ul>
<li>Switching between visible applications and invisible ones.
<p>NOTE: Switching between a visible application and an invisible one is conceptually a little like changing between tabs in a PC browser however without any implication of a particular user interface.</p>
<li>Switching between simultaneously visible applications where this OPTIONAL feature is supported.
</ul>
<p>A number of possible mechanisms exist for switching between visible applications and invisible ones. Some examples include the following;</p><ul>
<li>Hard coded mechanisms in the terminal for switching to a specific application (e.g. to the service discovery application, the content guide, the communication service application).
<li>An OPTIONAL terminal specific UI showing available DAE applications which the user can switch to.
</ul>
</section>
<section id="signalling-format">
<h3>Signalling format</h3>
<section id="signalling-format-xml-encoding">
<h4>XML Encoding</h4>
<p>The following table defines how the signalling defined in [[!TS102809]] SHALL be interpreted when used  to signal DAE applications.</p>
<table class="simple" id="application-signalling">
<caption>Table ####: Application signalling</caption>
<thead><tr><th>Descriptor or Element</th><th>Summary</th><th>Status in this specification</th></tr>
<tr><td>5.4.4.1 ApplicationList</td><td>List of applications</td><td>Required</td></tr>
<tr><td>5.4.4.2 Application</td><td>Name, identifier, type specific descriptor</td><td>Required</td></tr>
<tr><td>5.4.4.3 ApplicationIdentifier</td><td>2 numbers</td><td>Required</td></tr>
<tr><td>5.4.4.4 ApplicationDescriptor</td><td>Numerous application attributes</td><td>Required<br />The serviceBound element is only applicable to broadcast related applications and SHALL be ignored for other applications.</td></tr>
<tr><td>5.4.4.5 VisibilityDescriptor</td><td>Attribute &mdash; indicate if application can be visible to users and/or other applications</td><td>Optional. If this element is not present, OITFs SHALL use a default value of <code>VISIBLE_ALL</code>.</td></tr>
<tr><td>5.4.4.6 IconDescriptor</td><td>Icon for application</td><td>The filename in the IconDescriptor SHALL be an HTTP URL. Use of the icon signalled here by the OITF is OPTIONAL.</td></tr>
<tr><td>5.4.4.7 AspectRatio</td><td>Preferred aspect ratio for icons</td><td>Only relevant if the OITF uses the IconDescriptor.</td></tr>
<tr><td>5.4.4.8 MhpVersion</td><td>Specification version</td><td>As defined in section <a href="volume3.html#mhpversion-element-of-applicationdescriptor" class="extRef">section 3.2.3.3.2</a> of [[.OIPF_META2]].</td></tr>
<tr><td>5.4.4.9 StorageCapabilities</td><td>Can the application be stored or cached</td><td>Ignored</td></tr>
<tr><td>5.4.4.10 StorageType</td><td>Enumeration used in section 5.4.4.9 of [[!TS102809]]</td><td>Ignored</td></tr>
<tr><td>5.4.4.11 ApplicationType</td><td>Application type</td><td>For DAE and PAE applications, the appropriate value from the <mark class="error">ApplicationTypeCS scheme from [[.OIPF_META2]]</mark> SHALL be used.<div class="editor-note">This classification scheme is only present in the following versions of the OIPF specifications (2.0, 2.1-void), its removal may have been in error</div></td></tr>
<tr><td>5.4.4.12 DvbApplicationType</td><td>Enumeration for section 5.4.4.11 of [[!TS102809]]</td><td>Ignored</td></tr>
<tr><td>5.4.4.13 ApplicationControlCode</td><td>Enumeration for 5.4.4.4 of [[!TS102809]]</td><td>See below</td></tr>
<tr><td>5.4.4.14 ApplicationSpecificDescriptor</td><td>Container</td><td>Ignored</td></tr>
<tr><td>5.4.4.15 AbstractIPService</td><td>Supports grouping of unbound applications</td><td>Only one group SHALL be signalled</td></tr>
<tr><td>5.4.4.16 ApplicationOfferingType</td><td>Used as part of application discovery record</td><td>Required</td></tr>
<tr><td>5.4.4.17 ServiceDiscovery</td><td>Used as part of application discovery record</td><td>Required</td></tr>
<tr><td>5.4.4.18 ApplicationUsageDescriptor</td><td>Indicates that an application provides a specific service</td><td>Required</td></tr>
<tr><td>5.4.4.19 TransportProtocolDescriptorType</td><td>Abstract base type</td><td>Required</td></tr>
<tr><td>5.4.4.20 HTTPTransportType</td><td>Type for applications accessed by HTTP</td><td>Required</td></tr>
<tr><td>5.4.4.21 OCTransportType</td><td>Type for applications accessed by DSM-CC object carousel</td><td>Required</td></tr>
<tr><td>5.4.4.22 ComponentTagType</td><td>Encodes a DVB component tag</td><td>Ignored</td></tr>
<tr><td>5.4.4.23 SimpleApplicationLocationDescriptorType</td><td>Encodes the location of the start page of an application relative to one of the transport types</td><td>Required</td></tr>
<tr><td>5.4.4.24 SimpleApplicationBoundaryDescriptorType</td><td>Encodes an application boundary</td><td>Required</td></tr>
<tr><td>FLUTESessionDescriptor as defined by <a href="volume3.html#sdns-FLUTESessionDescriptor-schema" class="extRef">Annex B.6</a> of [[.OIPF_META2]]</td><td>Support for distributing applications through multicast</td><td>SHALL be supported if OITFs support FLUTE.</td></tr>
</table>
<p>Elements and descriptors marked as 'Ignored' SHALL NOT be processed for DAE applications. Servers MAY include these in application signalling.</p>
<p>The application control code SHALL be interpreted as follows for DAE applications:</p>
<table class="simple" id='dae-application-control-codes'>
<caption>Table ####: DAE application control codes</caption>
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td><code>AUTOSTART</code></td><td>The application is eligible to be started automatically. Sections <a href="#broadcast-related-applications-general" class="sectionRef"></a> and <a href="#service-provider-related-applications-signalling" class="sectionRef"></a> above define the order in which AUTOSTART applications are started if more than one is signalled.</td></tr>
<tr><td><code>PRESENT</code></td><td>The OITF SHALL take no action. The OITF MAY provide a mechanism to allow the end-user to start applications signalled as PRESENT. However since there is no requirement for such a mechanism, an IPTV service provider who signals applications with this control code SHALL provide an application able to start them.</td></tr>
<tr><td><code>KILL</code></td><td>The application SHALL be terminated (see <code>ApplicationDestroyRequest</code> in section <a href="#new-dom-events-for-application-support" class="sectionRef"></a>).</td></tr>
<tr><td><code>PREFETCH</code></td><td>The OITF MAY start fetching files, data or other information needed to start the application but SHALL NOT start the application. Implementations MAY consider this control code to be the same as <code>PRESENT</code>.</td></tr>
</table>

<p>The other control codes from [[!TS102809]] are not defined for DAE applications. Other control codes are not required to be supported but MAY be supported if required by another specification.  The OITF SHALL discard any AIT entry containing an unsupported control code.</p>
</section>
<section>
<h4>MPEG-2 Encoding</h4>
<p>In a hybrid device where the broadcast channel is based on DVB network technologies and uses DVB-SI as specified in [[!EN300468]], the OITF SHALL support the MPEG-2 encoding of the AIT from [[!TS102809]] as defined in the following table. This encoding MAY be supported in other devices.</p>
<table class="simple" id="supported-application-signalling-features">
<caption>Table ####: Supported application signalling features</caption>
<thead><tr><th>Section</th><th>Status</th><th>Notes</th></tr></thead>
<tr><td>5.2.2 Application types</td><td>M</td><td>The application type shall be 0x0011.</td></tr>
<tr><td>5.2.3 Application identification</td><td>M</td><td>Applications which only need the default permissions SHALL be signalled using application_ids from the range for unsigned applications. <br />Applications which need more permissions than the default SHALL be signalled using application_ids from the range for signed applications.<br />The range of application_ids for privileged applications SHALL NOT be used.</td></tr>
<tr><td>5.2.4 Application control codes</td><td>M</td><td>
	The following control codes shall be supported: <table class="alignment">
	<tr><td style="border:0px none transparent;">0x01</td><td style="border:0px none transparent;">AUTOSTART</td></tr>
	<tr><td style="border:0px none transparent;">0x02</td><td style="border:0px none transparent;">PRESENT</td></tr>
	<tr><td style="border:0px none transparent;">0x04</td><td style="border:0px none transparent;">KILL</td></tr>
	<tr><td style="border:0px none transparent;">0x07</td><td style="border:0px none transparent;">DISABLED</td></tr>
	</table>
	The application life cycle shall follow the rules defined in TS 102 809 [[!TS102809]] and in this specification.
</td></tr>
<tr><td>5.2.5 Platform profiles</td><td>M</td><td>The encoding of the <code>application_profile</code> is not defined in this specification.<br />The version fields shall be set as follows:<br />
version.major = 2<br />
version.minor = 3<br />
version.macro = 0
</td></tr>
<tr><td>5.2.6 Application visibility</td><td>M</td><td></td></tr>
<tr><td>5.2.7 Application priority</td><td>M</td><td></td></tr>
<tr><td>5.2.8 Application icons</td><td>O</td><td>The icon locator information shall be relative to the base part (constructed from the URL_base_bytes) of the URL as signalled in the transport_protocol_descriptor.</td></tr>
<tr><td>5.2.9 Graphics constraints</td><td>-</td><td></td></tr>
<tr><td>5.2.10 Application usage</td><td>M</td><td>Usage type 0x01 shall be supported as described in section 5.2.10.2 of [[!TS102809]]</td></tr>
<tr><td>5.2.11 Stored applications</td><td>-</td><td></td></tr>
<tr><td>5.2.12 Application Description File</td><td>-</td><td></td></tr>
<tr><td>5.3.2 Program specific information</td><td>M</td><td></td></tr>
<tr><td>5.3.4 Application Information Table</td><td>M</td><td>See [[.OIPF_MEDIA2]] for MPEG-2 system related requirements and constraints.</td></tr>
<tr><td>5.3.5.1 Application signalling descriptor</td><td>M</td><td></td></tr>
<tr><td>5.3.5.2 Data broadcast id descriptor</td><td>O</td><td>The value to be used for the data_broadcast_id field of the data_broadcast_id_descriptor for OIPF carousels shall be 0x0150.<br />By supporting this optional feature, terminals can reduce the time needed to mount a carousel.</td></tr>
<tr><td>5.3.5.3 Application descriptor</td><td>M</td><td></td></tr>
<tr><td>5.3.5.4 Application recording descriptor</td><td>-</td><td></td></tr>
<tr><td>5.3.5.5 Application usage descriptor</td><td>M</td><td>Usage type 0x01 shall be supported as described in section 5.2.10.2 of [[!TS102809]].</td></tr>
<tr><td>5.3.5.6 User information descriptors</td><td>M</td><td></td></tr>
<tr><td>5.3.5.7 External application authorization descriptor</td><td>M</td><td></td></tr>
<tr><td>5.3.5.8 Graphics constraints descriptor</td><td>-</td><td></td></tr>
<tr><td>5.3.6 Transport protocol descriptors</td><td>M</td><td>The following protocol_ids shall be supported:
<table class="alignment">
<tr><td style="border:0px none transparent;">0x0001</td><td style="border:0px none transparent;">object carousel over broadcast channel (as defined in [[.OIPF_MEDIA2]])</td></tr>
<tr><td style="border:0px none transparent;">0x0003</td><td style="border:0px none transparent;">HTTP over broadband connection</td></tr>
</table>
</td></tr>
<tr><td>5.3.7 Simple application location descriptor</td><td>M</td><td></td></tr>
<tr><td>5.3.8 Simple application boundary descriptor</td><td>M</td><td>Only strict prefixes starting with "dvb://", "http://" or "https://" shall be supported.<br />Only prefixes forming at least a second-level domain shall be supported.<br />Path elements shall be ignored.
</td></tr>
<tr><td>5.3.9 Service information</td><td>-</td><td></td></tr>
<tr><td>5.3.10 Stored applications</td><td>-</td><td></td></tr>
</table>
<table class="simple" id="key-to-status-column">
<caption>Table ####: Key to status column</caption>
<thead><tr><th>Status</th><th>Description</th></tr></thead>
<tr><td>M</td><td>MANDATORY<br />The signalling may be restricted to a subset specified in the "Notes" column. In that case all additional signalling is optional.</td></tr>
<tr><td>O</td><td>OPTIONAL</td></tr>
<tr><td>-</td><td>NOT INCLUDED<br />The referenced signalling is not included in this specification.</td></tr>
</table>
</section>
</section>
<section id="widgets-lifecycle">
<h3>Widgets lifecycle</h3>
<p>As Widgets are packaged as ZIP archives, they only require a single download and installation on an OITF before being executed. Widgets can also be downloaded over non-HTTP distribution channels and even over off-network channels (USB drives, CD/DVD, etc.). </p>
<p>The Widget lifecycle has 3 main steps:</p><ol>
<li>Installation: The Widget is installed on the OITF 
<li>Execution: The Widget is executed (end eventually stopped)
<li>Removal: The Widget is uninstalled from the OITF 
</ol>
<p>Step 1, installation, is only needed before the first execution of the Widget or if its version is obsolete and the user or the OITF want to update it (see section <a href="#widget-updates" class="sectionRef"></a>).</p>
<p>Step 2, execution, may be performed at any time after the Widget has been installed. It can be triggered by an action from the user, or it may be done automatically by the OITF either through a DAE application or a native application in the OITF.  Note that it is not possible to have two running instances of a single Widget simultaneously.</p>
<p>Step 3, removal, is performed if the user wants to uninstall the Widget from the OITF. An uninstalled Widget needs to be reinstalled by a user to be executed again. </p>
<p>Detail descriptions of each step above are provided in the following sections.</p>
<section id="widget-installation">
<h4>Widget installation</h4>
<p>In order to be able to execute a Widget, the Widget package first needs to be acquired and installed on the OITF. Steps for acquiring and processing a Widget package and associated processing rules are described in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#steps-for-processing-a-widget-package" class="extRef">section 9</a> of [[!Widgets-Packaging]]. In this specification the expression &ldquo;Widget installation succeed&rdquo; means that the afore-mentioned procedure is completed successfully.</p>
<p>Although [[!Widgets-Packaging]] does not limit or mandate any specific data transfer protocol or distribution channel through which Widgets are delivered, an OITF SHALL support the use of HTTP and HTTPS as the transfer protocols. Support for other transfer protocols is OPTIONAL. Widget installation is done through the <a href="#oipfApplicationManager-installwidget" class="apiRef">ApplicationManager.installWidget()</a> API call. After a call to this function, if the installation succeeds, the installed Widget SHALL be available in the list of installed Widgets that can be retrieved using <a href="#oipfApplicationManager-widgets" class="apiRef">ApplicationManager.widgets</a>. The application installing the Widget is notified about the installation success/failure through the WidgetInstallation event as specified in section <a href="#application-oipfApplicationManager-properties" class="sectionRef"></a> and <a href="#application-oipfApplicationManager-events" class="sectionRef"></a>.</p>
<p>When installing a Widget, the OITF SHOULD notify the user if there is already an installed Widget with the same &ldquo;id&rdquo; value  (where &ldquo;id&rdquo; is defined in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#the-id-attribute" class="extRef">section 7.6.1</a> of [[!Widgets-Packaging]] along with the extension defined in section <a href="#widgets-packaging-and-configuration" class="sectionRef"></a> of this specification). In this case the OITF SHALL proceed as specified in the description of <a href="#oipfApplicationManager-installwidget" class="apiRef">installWidget()</a> method in section <a href="#application-oipfApplicationManager-methods" class="sectionRef"></a>.</p>
</section>
<section id="widget-execution">
<h4>Widget execution</h4>
<p>In order to be executed, a Widget needs to be installed as described in the previous section. After the installation, a Widget can be started either using the <a href="#application-createapplication" class="apiRef">Application.createApplication()</a> API call or through the <a href="#application-startwidget" class="apiRef">Application.startWidget()</a> API call. The behaviour of these two methods is equivalent. <a href="#application-startwidget" class="apiRef">startWidget()</a> is the preferred method; <a href="#application-createapplication" class="apiRef">createApplication()</a> is kept for consistency with other DAE applications. A list of installed Widgets can be retrieved using <a href="#oipfApplicationManager-widgets" class="apiRef">ApplicationManager.widgets</a>. Note that only one running instance per Widget at time is allowed. A Widget can be stopped using <a href="#application-stopwidget" class="apiRef">Application.stopWidget()</a> or <code>Application.destroyApplication().stopWidget()</code> is the preferred method; <a href="#application-destroyapplication" class="apiRef">destroyApplication()</a> is kept for consistency with other DAE applications.</p>
<p>If the installed Widget has been run on the OITF before, any &ldquo;storage areas&rdquo; associated with the Widget, as defined in [[!Widgets-APIs]], SHALL be restored. Saved data is accessible through the preferences attribute of the Widget object as defined in section <a href="#widgets-interface" class="sectionRef"></a> of this specification. </p>
<p>See related sections in section <a href="#dae-apis" class="sectionRef"></a> for more details about the above mentioned API calls.</p>
</section>
<section id="widget-uninstallation">
<h4>Uninstalling a Widget</h4>
<p>An installed Widget can be uninstalled from an OITF through the <a href="#oipfApplicationManager-uninstallwidget" class="apiRef">ApplicationManager.uninstallWidget()</a> API call. Calling this method on a running Widget will cause the Widget to be stopped before the Widget is uninstalled. The application uninstalling the Widget is notified about the uninstallation success/failure through the &ldquo;WidgetUninstallation&rdquo; event as specified in sections <a href="#application-oipfApplicationManager-properties" class="sectionRef"></a> and <a href="#application-oipfApplicationManager-events" class="sectionRef"></a>. Any storage areas associated with the uninstalled Widget  SHALL be deleted.</p>
</section>
<section id="widget-updates">
<h4>Widget updates</h4>
An installed Widget can be updated by installing a new version of it.
</section>
</section>
</section>
<section id="event-notifications">
<h2>Event Notifications</h2>
<p>This section describes 4 different notification frameworks (In-session notification based on the home network domain, In-session notification based on the Internet domain, 3<sup>rd</sup> Party notification based on home network domain, and 3<sup>rd</sup> Party notification based on the Internet domain) defined by [[!CEA-2014-A]]. Moreover, it defines a new notification framework for IMS based notifications such as CallerID, Incoming Call Message, and Chat Invite; not only when a DAE application is active but also inactive.</p>
<p>The event notification mechanism allows OITFs to receive important UI updates or information from IPTV service provider or home network devices such as IG, AG or DLNA RUI compatible devices. CEA 2014 mandates 4 unique notification models which are dependent on whether the  server exists on the internet domain or home network domain. Each of these domain models have two unique scenarios depending on whether or not a DAE application is running. If a DAE application is active, the in-session notifications are used to support dynamic UI interaction between the server and the DAE application without the need to reload the XHTML page. Otherwise, 3<sup>rd</sup> party event notifications should be used to receive and display a notification message outside of the current user session with a DAE application on the OITF, for example an event coming from another server, e.g. to receive emergency alerts, or events regarding news, weather, stock or other information. Generally, 3<sup>rd</sup> party event notification creates a new DAE application to display notification information.</p>
<p>IMS event notifications for Caller ID, Messaging and Chatting have different behaviour from general event notification defined by [[!CEA-2014-A]] because IMS communication service should be accessed by authorized users and devices within the approval of IPTV service provider. Considering the issue of user's privacy, the DAE specification not only adopts the general Event Notification Frameworks from [[!CEA-2014-A]] as defined in section <a href="#CEA2014-notifications" class="sectionRef"></a>, but also defines a new IMS Event Notification Framework in section <a href="#IMS-notifications" class="sectionRef"></a>.</p>
<section id="CEA2014-notifications">
<h3>Event notification framework based on CEA 2014</h3>
<p>An OITF must be capable of displaying various event notifications from both Internet domain and home network domain. Event notification can be conveyed through active UI interaction's channel or out of session. As described in the diagram below, in-session notification is associated with a running DAE application, whereas a 3<sup>rd</sup> party event notification is delivered through an independent communication channel. If an OITF receives a 3<sup>rd</sup> party event after subscribing to a certain internet url or the OITF receives a multicasted event notification message, the OITF needs to perform 3<sup>rd</sup> party event notification and display its information inside a new DAE application.</p>
<p>The diagram below describes a general overview of Event Notification architecture.</p>
<figure>
<img alt="FIGURE 6" src="images/GeneralEventNotificationArchitecture.png" />
<figcaption>Figure ####: General Event Notification Architecture on OITF and Remote UI Server</figcaption>
</figure>
<p>In-Session notifications are performed to update partial or whole DAE application UI through the NotifSocket object and/or the XMLHttpRequest object as defined by [[!CEA-2014-A]]. The NotifSocket object creates a persistent TCP connection between a DAE application and Remote UI server in order to support burst event notifications. In addition, a DAE application can create an XMLHttpRequest object to make asynchronous HTTP requests to a web server on the internet domain. This establishes an independent HTTP connection channel to support XML updates between the DAE application and the Remote UI server.
On the other hand, if the OITF receives an incoming notification outside of an active interaction (i.e. session) with the server, a 3<sup>rd</sup> Party Event Notification must be executed to invoke a DAE application to fetch and render the UI content using the url contained within the notification message. This allows servers to &ldquo;broadcast&rdquo; important messages, such as Emergency alert messages, to an OITF at any time, even when the DAE application would currently not be running. This should be done through a push-method with multicast message for the home network domain. and a pull-method for the internet case. 
The next two subsections describe the requirements for the event mechanisms in more detail.</p>
<section>
<h4>In-session event notification</h4>
<p>In-Session notification can be defined as &ldquo;Dynamic UI Update.&rdquo; With this mechanism, a server should be able to send a notification message during a UI interaction to update the UI dynamically without the need to reload the XHTML-page. The OITF SHALL support the two following scripting objects for In-session event notification: <ul>
<li><code>XMLHttpRequest</code> Scripting Object (as defined in the XMLHttpRequest specification as referenced in [[!OIPF_WSTVP2]])<ul>
<li>The <code>XMLHttpRequest</code> is an embedded object on the browser and enables scripts to make HTTP request to a web server without the need to reload the page. It can be used by JavaScript to transfer and manipulate XML data to and from a web server using HTTP, establishing an independent connection channel between a web server and DAE applications. Whenever a DAE application needs to update the UI, it sends a request to the UI server, IPTV service provider or 3<sup>rd</sup> Party Internet Server, to monitor the change of status or event. In case an event, the UI server sends an HTTP response to the XMLHttpRequest.</ul>
<li><code>NotifSocket</code> Scripting Object (as defined in section 5.5.1 of [[!CEA-2014-A]])<ul>
<li>Even though support for the <code>XMLHttpRequest</code> object has become more widespread on browsers and Internet Portal servers, it has a difficulty in supporting dynamic UI update on home domain's devices because it is required to be invoked by the request of <code>XMLHttpRequest</code> on DAE application side. <code>NotifSocket</code> creates a persistent TCP connection between DAE application and UI server in order to support burst event notifications. Whenever the UI server needs to notify the DAE application running on the OITF of a UI update, it sends any types of update message, such as encoded binary or string, through the <code>NotifSocket</code> connection. The <code>NotifSocket</code> object allows an UI server to push any event information through the independent TCP/IP channel at any time.</ul>
</ul>
</section>
<section>
<h4>Out of session event notification</h4>
<p>Out of session event notifications are defined as &ldquo;3<sup>rd</sup> Party Notifications&rdquo; in CEA-2014. Since these notifications are not part of an active remote UI interaction with a Remote UI Server, the OITF must launch a new DAE application to render the UI content using the url contained within the notification message.</p>
<p>The OITF SHALL support multicast notifications for 3<sup>rd</sup> party event notifications for the home network domain and  the internet domain respectively as defined below. Support for polling-based notifications as defined below is OPTIONAL and support can be indicated through the OITF's capability description by using element <code>&lt;pollingNotifications&gt;</code> as defined in section <a href="#third-party-notification-support" class="sectionRef"></a> or the <code>+POLLNOTIF</code> name fragment as defined in section <a href="#default-ui-profiles" class="sectionRef"></a>.<ul>
<li>Multicast Notifications (as defined in section 5.6.1 of [[!CEA-2014-A]])<ul>
<li>The OITF SHALL support receiving of Multicast Notifications over multicast UDP, with a UPnP event message format defined by CEA 2014 if the incoming message comes from home network domain. After interpreting the message, the OITF should create a new notification window with specified <code>&lt;ruiEventURL&gt;</code>. In order to ensure a reliable transmission of a multicast notification message, a Remote UI Server shall transmit the same notification message, with the same HTTP SEQ header value 2 or 3 times, where the time between transmissions should be a random time between 0 and 10 seconds.</ul>
<li>Polling-based Notification (as defined in section 5.6.2 of [[!CEA-2014-A]]) and Annex <a href="#changes-to-cea2014a-5-6-2" class="sectionRef"></a> &ldquo;<a href="#changes-to-cea2014a-5-6-2" class="sectionTitleRef"></a>&rdquo; in this specification<ul>
<li>The OITF SHALL support polling-based 3<sup>rd</sup> Party notifications from an IPTV Service Provider or a 3<sup>rd</sup> Party Internet Server. To this end, the OITF subscribes to certain URIs to display web contents such as news, weather, stock or other information from Internet side on executing the <b>subscribeToNotifications()</b> method. An OITF should poll for notifications even when the CE-HTML browser is not active. If a new notification is received, this MAY be notified to the user in a vendor defined way, including direct rendering on the display and using a non-intrusive prompt. 
</ul>
<p>Note that Annex <a href="#changes-to-cea2014a-5-6-2" class="sectionRef"></a> defines a <a href="#subscribetonotificationsasync" class="apiRef">subscribeToNotificationsAsync()</a> method to provide a way of subscribing to polling-based notifications that is non-blocking.</p>
</ul>
</section>
</section>
<section id="IMS-notifications">
<h3>IMS event notification framework</h3>
<p>This section covers the DAE interactions needed to drive the message exchanges on the HNI-IGI interface in the case where the Service Provider offers an IMS application.</p>
<p>The HNI-IGI framework defines how an OITF interacts with an IMS Gateway (IG) via the HNI-IGI interface ([[!OIPF_PROT2]] <a href="volume4.html#s5-2" class="extRef">section 5.2</a>).</p>
<p>Every message on the HNI-IGI interface SHALL be carried in a HTTP transaction where the OITF sends the HTTP request and the IG responds to the request. The HNI-IGI In-session framework, in the case of a DAE application, uses the XMLHttpRequest Script Object, as defined in the XMLHttpRequest specification as referenced in [[!OIPF_WSTVP2]].</p>
<p>There are two message directions on the HNI-IGI interface, corresponding to outgoing and incoming messages from and to the OITF.</p>
<section>
<h4>HNI-IGI transactions for in-session out-going request messages</h4>
<p>This message direction applies to outgoing messages from the OITF on the HNI-IGI interface. The OITF sends a request and the IG responds to the request. The following figure illustrates the sequences for in-session transactions for outgoing requests from DAE application to the IG.</p>
<figure>
<img alt="FIGURE 7" src="images/Outgoing_SIP_requests_from_a_DAE_application.png" />
<figcaption>Figure ####: HNI-IGI transaction for outgoing SIP requests from a DAE application</figcaption>
</figure>
<ol start="0">
<li>Prepare the Call-ID for a SIP request. The Call-ID SHALL be generated by the DAE application for an outgoing SIP request. This Call-ID SHALL be locally unique across all OITFs in a residential network. <br />
NOTE: How uniqueness is achieved is currently not defined.
<li>The DAE application SHALL create a new XMLHttpRequest object using the constructor &ldquo;<code>new XMLHttpRequest()</code>&rdquo;.
<li>The DAE application SHALL invoke the <code>open()</code> method to specify the HTTP method and Request-URI for the request. In this case, the HTTP POST method with the Request-URI  of &lt;IG_URL&gt;/SIP SHALL be used as specified in [[.OIPF_PROT2]].
<li>The DAE application SHALL invoke the <code>setRequestHeader()</code> method to specify the required HTTP headers as specified in [[.OIPF_PROT2]]. This method SHALL be invoked for each required HTTP header. For example, the X-OITF-Request-Line HTTP header specifies the SIP request line for the SIP request. The Call-ID is specified in the X-OITF-Call-ID header.
<li>The DAE application SHALL invoke the send() method to send the HTTP request. The SIP Message Request body is specified in a parameter of this method.
<li>When the HTTP response is received, the <code>onreadystatechange</code> callback function SHALL be invoked on the DAE application. 
<li>The DAE application SHALL invoke the <code>getRequestHeader()</code> method to retrieve each HTTP header. The SIP Response Line is specified in the X-OITF-Response-Line header.
<li>If the <code>readyState</code> property of the XMLHttpRequest object has the value 4, the HTTP response body SHALL be retrieved via the responseXML or responseText properties of the XMLHttpRequest object. The SIP response body is specified in the HTTP response body.
</ol>
</section>
<section id="in-session-incoming-request-messages">
<h4>HNI-IGI transaction for in-session incoming request messages</h4>
<p>This message direction applies to incoming messages to the OITF on the HNI-IGI interface which are related to an existing IMS session. An example of this is a SIP NOTIFY message received from the network in response to a previous SIP SUBSCRIBE sent from the IG. The OITF sends a HTTP request and the IG responds to the request when it receives an incoming message from the network related to an existing session. The following figure illustrates the sequences for in-session transactions for incoming requests from the IG to the DAE application.</p>
<figure>
<img alt="FIGURE 8" src="images/in-session_incoming_SIP_request.png" />
<figcaption>Figure ####: HNI-IGI transaction for in-session incoming SIP request</figcaption>
</figure>
<ol start="0">
<li>Prepare the Call-ID for this SIP session for which a message is expected. The Call ID SHALL be the same as the one created initially for this session.
<li>The DAE application SHALL create a new XMLHttpRequest object using the constructor  &ldquo;<code>new XMLHttpRequest()</code>&rdquo;.
<li>The DAE application SHALL invoke the <code>open()</code> method to specify the HTTP method and the Request-URI for the request. In this case, the POST method with a Request-URI of &lt;IG_URL&gt;/PENDING_IG SHALL be used as specified in [[.OIPF_PROT2]]. 
<li>The DAE application SHALL invoke the <code>setRequestHeader()</code> method to specify the required HTTP headers, as specified in [[.OIPF_PROT2]]. This method is invoked for each HTTP header that is required. In this case, the X-OITF-Request-Line, which specifies the SIP request line for the SIP request, is set to the value <code>null</code>. The SIP Call-ID is specified in the X-OITF-Call-ID header.
<li>The DAE application SHALL invoke the <code>send()</code> method to send the HTTP request. For the HTTP request that sets up the initial long poll, no X-OITF headers are allowed for the HTTP request to the PENDING_IG Request-URI.
<li>When the HTTP response is received, the specified <code>onreadystatechange()</code> callback function is invoked. 
<li>The DAE application SHALL invoke the <code>getResponseHeader()</code> method to retrieve each HTTP header. The SIP Request Line is specified in the X-OITF-Request-Line HTTP header.
<li>If the <code>readyState</code> property of the <code>XMLHttpRequest</code> object has the value 4, the HTTP response body SHALL be retrieved via the <code>responseXML</code> or <code>responseText</code> properties of the <code>XMLHttpRequest</code> object. The SIP response body is specified in the HTTP response body.
<li>The DAE application SHALL create a new <code>XMLHttpRequest</code> object using the constructor &ldquo;<code>new XMLHttpRequest()</code>&rdquo;.
<li>The DAE application SHALL invoke the <code>open()</code> method to specify the HTTP method and the Request-URI for the request. In this case, the POST method with a Request-URI of &lt;IG_URL&gt;/PENDING_IG SHALL be used as specified in [[.OIPF_PROT2]]. 
<li>The DAE application SHALL invoke the <code>setRequestHeader()</code> method to populate each HTTP header as specified in [[.OIPF_PROT2]]. This method SHALL be invoked for each required HTTP header. For example, the X-OITF-Response-Line specifies the SIP response line for the SIP response. The Call-ID is specified in the X-OITF-Call-ID header.
<li>The DAE application SHALL invoke the <code>send()</code> method to send the HTTP request. If there is a SIP response body, it is included as a parameter to the <code>send()</code> method. The SIP response body message is carried in the HTTP body for the HTTP request  to the PENDING_IG Request-URI.
</ol>
<p>In the case where the OITF does not need to receive any further incoming in-session SIP requests, the HTTP POST in step 11 SHALL be directed to the &lt;IG_URL&gt;/SIP Request-URI.</p>
</section>
<section>
<h4>HNI-IGI transaction for out of session incoming request messages</h4>
<p>This message direction applies to incoming messages on the HNI-IGI interface which are not related to an existing session. An example of this is a SIP MESSAGE message received from the network, coming e.g. from an IPTV application or from another user. The following figure illustrates the sequences of out-of-session transactions for in-coming requests from the IG to OITF.</p>
<p>Figure <a href="#OITF-first-turned-on" class="figureRef"></a> describes what happens when the OITF is first turned on.</p>
<figure id="OITF-first-turned-on">
<img alt="FIGURE 9" src="images/OIPF-is-first-turned-on.png" style="width:90%" />
<figcaption>Figure ####: What happens when the OITF is first turned on</figcaption>
</figure>
<ol>
<li>When the OITF is turned on the OITF SHALL send a HNI_IGI IG registration message to register the default user.
<li>The IG Registers the default user in the IMS network.
<li>The IMS network returns 200 OK.
<li>a 200 OK message SHALL be returned on the HNI_IGI.
<li>If there are native IMS applications that may receive unsolicited messages the OITF SHALL send a PENDING_IG message to the IG, for the default user and with the call_id set to <code>null</code>. The steps to send PENDING_IG are the same as steps 8-11 from section <a href="#in-session-incoming-request-messages" class="sectionRef"></a> &ldquo;<a href="#in-session-incoming-request-messages" class="sectionTitleRef"></a>&rdquo;.
<li>The OITF performs service selection and discovery and loads the initial DAE page.
<li>DAE IMS applications that desires to receive unsolicited notifications SHALL issue a <code>subscribeNotification()</code> method (as defined in section <a href="#oipfcommunicationservices-methods" class="sectionRef"></a>).
<li>When applicable the OITF SHALL send a HNI_IGI IG registration message to re-register the default user, including new applications.
<li>The IG re-registers the default user in the IMS network.
<li>The IMS network returns 200 OK.
<li>A 200 OK message SHALL be returned on the HNI_IGI.
</ol>
<p>Figure <a href="#user-login-via-dae-interface" class="figureRef"></a> describes what happens when a specific user logs in using the DAE interface.</p>
<figure id="user-login-via-dae-interface">
<img alt="FIGURE 10" src="images/User-login-via-DAE-interface.png" />
<figcaption>Figure ####: User logs in using the DAE interface</figcaption>
</figure>
<ol>
<li>When the user desires to login the DAE SHALL call the <code>registerUser()</code> method to register the user.
<li>The OITF SHALL send a HNI_IGI IG registration message to register the user.
<li>The IG Registers the user in the IMS network.
<li>The IMS network returns 200 OK.
<li>A 200 OK message SHALL be returned on the HNI_IGI.
<li>If there are native IMS applications that may receive unsolicited messages the OITF SHALL send a PENDING_IG message to the IG, for the default user and with the call_id set to <code>null</code>. The steps to send PENDING_IG are the same as steps 8-11 from section <a href="#in-session-incoming-request-messages" class="sectionRef"></a> &ldquo;<a href="#in-session-incoming-request-messages" class="sectionTitleRef"></a>&rdquo;
<li>DAE IMS applications for the user that desires to receive unsolicited notifications SHALL issue a <code>subscribeNotification(icsi)</code> method (as defined in section <a href="#oipfcommunicationservices-methods" class="sectionRef"></a>).
<li>When applicable the OITF SHALL send a HNI_IGI IG registration message to re-register the user, including new applications.
<li>The IG re-registers the default user in the IMS network.
<li>The IMS network returns 200 OK.
<li>a 200 OK message SHALL be returned on the HNI_IGI.
</ol>
<p>Figure <a href="#unsolidited-message-from-the-network" class="figureRef"></a> describes what happens when an unsolicited message arrives from the network. The precondition is that a DAE application is already running and subscribed to the IMS notifications (refer to previous sequence when user logs in).</p>
<figure id="unsolidited-message-from-the-network">
<img alt="FIGURE 11" src="images/unsolicited-message-from-the-network.png" style="width:90%" />
<figcaption>Figure ####: Unsolicited message from the network</figcaption>
</figure>
<ol>
<li>A SIP message arrives from the network.
<li>The IG responds to the PENDING_IG request.
<li>The OITF SHALL  immediately issue a new PENDING_IG request after receiving a response on a PENDING_IG request. The steps to send PENDING_IG are the same as steps 8-11 from section <a href="#in-session-incoming-request-messages" class="sectionRef"></a> &ldquo;<a href="#in-session-incoming-request-messages" class="sectionTitleRef"></a>&rdquo;.
<li>The OITF SHALL call the callback function <code>onNotification</code> for the corresponding application. This includes the IMS message.
<li>The OITF MAY respond to the network with a new outgoing message. The steps to send PENDING_IG are the same as steps 8-11 from section <a href="#in-session-incoming-request-messages" class="sectionRef"></a> &ldquo;<a href="#in-session-incoming-request-messages" class="sectionTitleRef"></a>&rdquo;.
<li>If the OITF sends a message the IG SHALL forward it to the network.
</ol>
</section>
</section>
</section>
</section>

<!-- section 6 -->
<section id='dae-formats'>
<h1>Formats</h1>
<section id="web-standards-tv-profile">
<h2>Web Standards TV Profile</h2>
<p>An OITF SHALL support the Web Standards TV Profile defined in [[.OIPF_WSTVP2]]. The MIME type used for DAE documents SHALL be one of the MIME types defined in the HTML5 specification as referenced by [[.OIPF_WSTVP2]] for HTML or XHTML documents, or the value '<code>application/cehtml+xml; charset="UTF8"</code>'.</p>

<section id="wstvp-additional-restrictions-and-requirements">

<h3>Additional restrictions and requirements</h3>
<ul>
<li>The following properties and methods SHALL be supported on the window object as defined in section &ldquo;The window Object&rdquo; of the HTML5 specification as referenced in [[.OIPF_WSTVP2]] with additional requirements relating to integration with APIs and mechanisms defined in this document:<ul>
<li>close(): calling this method on the Window object of a DAE application SHALL be equivalent to calling method <a href="#application-destroyapplication" class="apiRef">destroyApplication()</a> of the DAE application (as defined in section <a href="#application-class-methods" class="sectionRef"></a>).
<li>blur(): calling this method on the Window object of a DAE application SHALL not deactivate the application as defined in section <a href="#active-applications-list" class="sectionRef"></a>.
</ul>
<li>Window scripting object support for the additional methods defined in Annex <a href="#changes-to-cea2014a-5-6-2" class="sectionRef"></a> is indicated by the <code>&lt;pollingNotifications&gt;</code> element in the device capabilities as defined in section <a href="#third-party-notification-support" class="sectionRef"></a>.
<li>An OITF SHALL offer a means to set focus to the following elements in a HTML document by using key-based input: &lt;a&gt;, &lt;area&gt;, all form elements, &lt;iframe&gt;, and &lt;object&gt; elements of type &ldquo;video&rdquo;. These elements SHALL have the tabindex focus flag set (see section 7.4.1 of the HTML5 specification as referenced by [[.OIPF_WSTVP2]]).
<li>An OITF SHALL allow the user to manually trigger elements that have an activation behaviour, for instance using keyboard input.
<p>NOTE: Section 3.2.5.1.7 ("Interactive content") of the HTML5 specification as referenced by [[.OIPF_WSTVP2]] includes similar requirements however using "SHOULD" not "SHALL".</p>
</ul>
</section>
</section>
<section id="still-image-formats">

<h2>Still image formats</h2>
<p>The following still image formats SHALL be supported:</p><ul>
<li>GIF as defined in [[!GIF]]
<li>PNG as defined in [[!PNG]]
<li>JPEG as defined in [[!JFIF]] except that support for lossless and hierarchical modes and arithmetic coding of DCT coefficients is OPTIONAL. The thumbnail feature of [[!JFIF]] is OPTIONAL. OITFs not supporting thumbnails SHALL skip them if present and continue decoding the rest of the image.
</ul>
</section>

<section id="media-formats">
<h2>Media Formats</h2>
<p>This section describes the main requirements for the format and usage of codecs in media referred to by DAE applications. This section also describes memory audio.</p>
<section id="format-of-av-media">
<h3>Media format of A/V media except for audio from memory</h3>
<p>This section describes the format and usage of the A/V media codec except for audio from memory.</p><ul>
<li>Format and usage of video codecs SHALL adhere to <a href="volume2.html#video-section" class="extRef">section 5</a> of [[!OIPF_MEDIA2]].
<li>The format and usage of subtitle streams SHALL adhere to <a href="volume2.html#subtitles-section" class="extRef">section 6</a> of [[!OIPF_MEDIA2]].
<li>The format and usage of teletext information SHALL adhere to <a href="volume2.html#formats-section" class="extRef">section 7</a> of [[!OIPF_MEDIA2]].
<li>The format and usage of audio codecs SHALL adhere to <a href="volume2.html#audio-section" class="extRef">section 8</a> of [[!OIPF_MEDIA2]], except for sections 8.1.1.2, 8.1.5 and 8.2.1 which are covered in section <a href="#format-of-audio-from-memory" class="sectionRef"></a>.
</ul>
</section>
<section id="format-of-audio-from-memory">
<h3>Media format of A/V media for audio from memory</h3>
<p>This section describes the format and usage of the A/V media codec for audio from memory. Usage of corresponding A/V media object is described in section <a href="#media-playback-apis" class="sectionRef"></a> of this specification.</p>
<p>For the audio from memory format, HE-AAC SHALL be supported by the OITF and WAVE MAY be supported by the OITF.</p><ul>
<li>The format and usage of HE-AAC audio from memory SHALL adhere to sections <a href="volume2.html#audio-clips" class="extRef">8.1.1.2</a> and <a href="volume2.html#audible-notifications-clips" class="extRef">8.2.1</a> of [[!OIPF_MEDIA2]].
<li>The format and usage of WAVE audio from memory SHALL adhere to sections <a href="volume2.html#audio-mpeg1-l3" class="extRef">8.1.5</a> and <a href="volume2.html#audible-notifications-clips" class="extRef">8.2.1</a> of [[!OIPF_MEDIA2]].
</ul>
</section>
<section id="media-transport">
<h3>Media transport</h3>
<p>The format and usage of media transports referred to by DAE applications SHALL adhere to <a href="volume2.html#systems-layer-section" class="extRef">section 4</a> of [[!OIPF_MEDIA2]].</p>
</section>
</section>
<section id="svg">
<h2>SVG</h2>
<p>Integration between SVG and HTML is defined in the HTML5 specification as referenced in [[.OIPF_WSTVP2]].</p>
</section>

</section>

<!-- section 7 -->
<section id='dae-apis'>
<h1>APIs</h1>
<section id='object-factory-api'>
<h2>Object Factory API</h2>
<p>This section defines the methods to check and create an instance of the DAE defined embedded objects within JavaScript.</p>
<p>The OITF SHALL support a globally accessible object of type "<code><b>OipfObjectFactory</b></code>" as a static property "<code><b>oipfObjectFactory</b></code>" of the Window interface with the API as defined in this section. The object factory SHALL ensure that the referenced objects are correctly set up. This is an alternative to instantiating embedded objects (or plug-ins) outside of JavaScript.</p>
<p>The factory object can be accessed as a property of the window object (i.e. <code>window.oipfObjectFactory</code> or <code>oipfObjectFactory</code>).</p>
<section id='object-factory-api-methods'>
<h3>Methods</h3>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>isObjectSupported</b>( String mimeType )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">This method SHALL return <code>true</code> if and only if an object of the specified type is supported by the OITF. The method SHALL return <code>false</code> if the MIME type passed as a parameter is not supported by the client.</td></tr>
<tr>
<td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">mimeType</td>
<td><p>The mimeType may have any of the MIME types defined in tables <a href="volume2.html#av25" class="extRef">1</a> to <a href="volume2.html#pureaudio" class="extRef">4</a> of [[.OIPF_MEDIA2]] or any of the DAE defined mime types listed below.</p>
<table class="dae-api-left-values-table">
<tr><th>DAE MIME Type</th></tr>
<tr><td><code>application/notifsocket</code></td></tr>
<tr><td><code>application/oipfApplicationManager</code></td></tr>
<tr><td><code>application/oipfCapabilities</code></td></tr>
<tr><td><code>application/oipfCodManager</code></td></tr>
<tr><td><code>application/oipfCommunicationServices</code></td></tr>
<tr><td><code>application/oipfConfiguration</code></td></tr>
<tr><td><code>application/oipfDownloadManager</code></td></tr>
<tr><td><code>application/oipfDownloadTrigger</code></td></tr>
<tr><td><code>application/oipfDrmAgent</code></td></tr>
<tr><td><code>application/oipfGatewayInfo</code></td></tr>
<tr><td><code>application/oipfMDTF</code></td></tr>
<tr><td><code>application/oipfParentalControlManager</code></td></tr>
<tr><td><code>application/oipfRecordingScheduler</code></td></tr>
<tr><td><code>application/oipfRemoteManagement</code></td></tr>
<tr><td><code>application/oipfSearchManager</code></td></tr>
<tr><td><code>application/oipfStatusView</code></td></tr>
<tr><td><code>video/broadcast</code></td></tr>
</table>
</td>
</tr>
</table>

<section id='object-factory-api-visual-objects'>
<h4>Visual Objects</h4>
<p>The methods in this section all return <code>HTMLObjectElement</code> objects which can be inserted in the DOM tree. All objects in section <a href="#dae-apis" class="setionRef"></a> which have a visual representation on the screen can be created using methods in this section. Only for objects defined in section <a href="#dae-apis" class="setionRef"></a>, that are supported by the device (i.e. as indicated through the client capability description), a corresponding method name to instantiate the object through the <code>OipfObjectFactory</code> class can be assumed to be present on the <code>oipfObjectFactory</code> object. For any other object, a corresponding method name cannot be assumed to be present.</p>
<table class="dae-method-table">
<tr>
<td colspan="3" class="api-signature">
HTMLObjectElement <b>createVideoBroadcastObject</b>( <a href="#stringcollection-class" class="apiRef">StringCollection</a> requiredCapabilites )<br />
HTMLObjectElement <b>createVideoMpegObject</b>( <a href="#stringcollection-class" class="apiRef">StringCollection</a> requiredCapabilites )<br />
HTMLObjectElement <b>createStatusViewObject</b>()
</tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">
<p>If the object type is supported, each of these methods shall return an instance of the corresponding embedded object.</p>
<p>Since objects do not claim scarce resources when they are instantiated, instantiation shall never fail if the object type is supported. If the method name to create the object is not supported, the OITF SHALL throw an error with the error.name set to the value "<code>TypeError</code>".</p>
<p>If the object type is supported, the method shall return an HTMLObjectElement equivalent to the specified object. The value of the type attribute of the HTMLObjectElement SHALL match the mimetype of the instantiated object, for example "<code>application/oipfVideoBroadcast</code>" in case of method <code>oipfObjectFactory.createVideoBroadcastObject()</code>.</p>
</td>
</tr>
<tr>
<td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">requiredCapabilites</td>
<td><p>An optional argument indicating the formats to be supported by the resulting player. Each item in the argument SHALL be one of the formats specified in [[.OIPF_MEDIA2]]. Scarce resources will be claimed by the object at the time of instantiation. The <code>allocationMethod</code> property SHALL be set <code>STATIC_ALLOCATION</code>. If the OITF is unable to create the player object with the requested capabilities, the method SHALL return <code>null</code>. </p>
<p>If this argument is omitted, objects do not claim scarce resources so instantiation shall never fail if the object type is supported. The allocationMethod property SHALL be set to <code>DYNAMIC_ALLOCATION</code>.</p>
</td>
</table>
</section>


<section id='object-factory-api-non-visual-objects'>
<h4>Non-Visual Objects</h4>
<p>The methods in this section all return JavaScript objects which implement the interfaces of their corresponding objects. They can not be inserted in the DOM tree. All objects in chapter <a href="#dae-apis" class="sectionRef"></a> which do <b>not</b> have a visual representation on the screen can be created using methods in this section. Only for objects defined in chapter <a href="#dae-apis" class="sectionRef"></a>, that are supported by the device (i.e. as indicated through the client capability description), a corresponding method name to instantiate the object through the <code>OipfObjectFactory</code> class can be assumed to be present on the <code>oipfObjectFactory</code> object. For any other object, a corresponding method name cannot be assumed to be present.</p>

<table class="dae-method-table">
<tr>
<td colspan="2" class="api-signature">
Object <b>createApplicationManagerObject</b>()<br />
Object <b>createCapabilitiesObject</b>()<br />
ChannelConfig <b>createChannelConfig</b>()<br />
Object <b>createCodManagerObject</b>()<br />
Object <b>createConfigurationObject</b>()<br />
Object <b>createDownloadManagerObject</b>()<br />
Object <b>createDownloadTriggerObject</b>()<br />
Object <b>createDrmAgentObject</b>()<br />
Object <b>createGatewayInfoObject</b>()<br />
Object <b>createIMSObject</b>()<br />
Object <b>createMDTFObject</b>()<br />
Object <b>createNotifSocketObject</b>()<br />
Object <b>createParentalControlManagerObject</b>()<br />
Object <b>createRecordingSchedulerObject</b>()<br />
Object <b>createRemoteControlFunctionObject</b>()<br />
Object <b>createRemoteManagementObject</b>()<br />
Object <b>createSearchManagerObject</b>()
</td>
</tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td>
If the object type is supported, each of these methods SHALL return an instance of the corresponding embedded object. This may be a new instance or existing instance. For example, the object will likely be a global singleton object and calls to this method may return the same instance.
<p>Since objects do not claim scarce resources when they are instantiated, instantiation SHALL never fail if the object type is supported. If the method name to create the object is not supported, the OITF SHALL throw an error with name property set to the value "<code>TypeError</code>".</p>
<p>If the object is supported, the method SHALL return a JavaScript <code>Object</code> which implements the interface for the specified object.</p>
</td>
</tr>
</table>
</section>



</section>

<section id='object-factory-api-examples'>
<h3>Examples</h3>
<p>This section provides examples of the usage of the methods.</p>
<p>The first example shows how to query whether an instance of the A/V Control object for a specified MIME type can be created without the application having to attempt to instantiate the object.</p>
<pre class="javascript">
var videoPlayer;
if (window.oipfObjectFactory.isObjectSupported("video/mpeg")) {
  videoPlayer = window.oipfObjectFactory.createVideoMpegObject();
  // append object to document
  document.getElementById('playerDiv').appendChild(videoPlayer);
  videoPlayer.data = "rtsp://server/barker_channel";
}
</pre>
<p>If the OITF does not support the created object the OITF SHALL throw an error with the error.name set to the value "<code>TypeError</code>". The example below shows how this can be used by applications:</p>
<pre class="javascript">
try {
  configuration = window.oipfObjectFactory.createConfigurationObject();
}
catch (error) {
  alert("application/oipfConfiguration object could not be created - error name: " 
        + error.name + " - error message: " + error.message);
}
</pre>
</section>
</section>  <!-- object-factory-api -->

<section id='applications-management-apis'>
<h2>Applications Management APIs</h2>
<p>An OITF providing DAE application capability SHALL implement the behaviour of the classes defined in this section.</p>
<section id='application-oipfApplicationManager'>
<h3>The application/oipfApplicationManager embedded object</h3>
<p>An OITF SHALL support a non-visual embedded object of type "<code>application/oipfApplicationManager</code>", with the following JavaScript API, to enable applications to access the privileged functionality related to application lifecycle and management that is provided by the application model defined in this section.</p>
<p>If one of the methods on the <code>application/oipfApplicationManager</code> is called by a webpage that is not a privileged DAE application, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>.</p>
<section id='application-oipfApplicationManager-constants'>
<h4>Constants</h4>

<table class="dae-constant-table">
<thead><tr><th>Name</th><th>Value</th><th>Use</th></tr></thead>
<tr><td>WIDGET_INSTALLATION_STARTED</td><td>0</td><td>The Widget installation has started. This state SHALL be used to indicate that the download of the Widget package is completed (possibly because the Widget was already stored locally) and the OITF is ready to start the Widget installation process. This state SHALL NOT be signalled if the package download fails.</td></tr>
<tr><td>WIDGET_INSTALLATION_COMPLETED</td><td>1</td><td>The Widget installation has completed successfully</td></tr>
<tr><td>WIDGET_INSTALLATION_FAILED</td><td>2</td><td>The Widget installation has failed either because the Widget package download failed or because, after the download, the Widget installation process failed.</td></tr>
<tr><td>WIDGET_UNINSTALLATION_STARTED</td><td>3</td><td>The Widget uninstallation has started</td></tr>
<tr><td>WIDGET_UNINSTALLATION_COMPLETED</td><td>4</td><td>The Widget uninstallation has completed successfully</td></tr>
<tr><td>WIDGET_UNINSTALLATION_FAILED</td><td>5</td><td>The Widget uninstallation has failed</td></tr>
<tr><td>WIDGET_ERROR_STORAGE_AREA_FULL</td><td>10</td><td>The local storage device is full</td></tr>
<tr><td>WIDGET_ERROR_DOWNLOAD</td><td>11</td><td>The Widget cannot be downloaded</td></tr>
<tr><td>WIDGET_ERROR_INVALID_ZIP_ARCHIVE</td><td>12</td><td>The Widget package is corrupted or is an Invalid Zip Archive (as defined in [[!Widgets-Packaging]] )</td></tr>
<tr><td>WIDGET_ERROR_INVALID_SIGNATURE</td><td>13</td><td>Widget's Signature Validation failed</td></tr>
<tr><td>WIDGET_ERROR_GENERIC</td><td>14</td><td>Other reason</td></tr>
<tr><td>WIDGET_ERROR_SIZE_EXCEEDED</td><td>15</td><td>The Widget exceeded the maximum size for a single widget allowed by the platform, as defined in section <a href="#minimum-dae-capabilities" class="sectionRef"></a>.</td></tr>
<tr><td>WIDGET_ERROR_PERMISSION_DENIED</td><td>16</td><td>The user and/or the OITF denied the installation or update of a Widget</td></tr>
</table>

</section>
<section id='application-oipfApplicationManager-properties'>
<h4>Properties</h4>
<table class="dae-property-table" id="oipfApplicationManager-onlowmemory">
<tr><td class="api-signature">function <b>onLowMemory</b>( )</td></tr>
<tr><td>The function that is called when the OITF is running low on available memory for running DAE applications. The exact criteria when to generate such an event is implementation specific.</td></tr>
</table>
<table class="dae-property-table" id="oipfApplicationManager-onapplicationloaded">
<tr><td class="api-signature">function <b>onApplicationLoaded</b>( <a href="#application-class" class="apiRef">Application</a> appl )</td></tr>
<tr><td>The function that is called immediately prior to a <code>load</code> event being generated in the affected application. The specified function is called with one argument <code>appl</code>, which provides a reference to the affected application.</td></tr>
</table>
<table class="dae-property-table" id="oipfApplicationManager-onapplicationunloaded">
<tr><td class="api-signature">function <b>onApplicationUnloaded</b>( <a href="#application-class" class="apiRef">Application</a> appl )</td></tr>
<tr><td>The function that is called immediately prior to an <code>unload</code> event being generated in the affected application. The specified function is called with one argument <code>appl</code>, which provides a reference to the affected application.</td></tr>
</table>
<table class="dae-property-table" id="oipfApplicationManager-onapplicationloaderror">
<tr><td class="api-signature">function <b>onApplicationLoadError</b>( <a href="#application-class" class="apiRef">Application</a> appl )</td></tr>
<tr><td>The function that is called when the OITF fails to load either the file containing the initial HTML document of an application or an XML AIT file (e.g. due to an HTTP 404 error, an HTTP timeout, being unable to load the file from a DSM-CC object carousel or due to the file not being either an HTML file or a XML AIT file as appropriate),   All properties of the <a href="#application-class" class="apiRef">Application</a> object referred to by <code>appl</code> SHALL have the value <code>undefined</code> and calling any methods on that object SHALL fail.</td></tr>
</table>
<table class="dae-property-table" id="oipfApplicationManager-onwidgetinstallation">
<tr><td class="api-signature">function <b>onWidgetInstallation</b>( <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> wd, Integer state, Integer reason )</td></tr>
<tr><td>The callback function that is called during the installation process of a Widget. The function is called with three arguments:<ul>
<li><code><a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> wd</code> - the WidgetDescriptor for the installed Widget. Some attributes of this argument may not have been initialised and may be null when the function is called until the Widget is successfully installed.
<li><code>Integer state</code> - the state of the installation; valid values are:<ul>
<li><code>WIDGET_INSTALLATION_STARTED </code>
<li><code>WIDGET_INSTALLATION_COMPLETED </code>
<li><code>WIDGET_INSTALLATION_FAILED </code>
<p>as defined in section <a href="#application-oipfApplicationManager-constants" class="sectionRef"></a>.</p></ul>
<li><code>Integer reason</code> - indicates the reason for installation failure. This is only valid if the value of the state argument is <code>WIDGET_INSTALLATION_FAILED</code> otherwise this argument SHALL be null. Valid values for this field are:<ul>
<li><code>WIDGET_ERROR_STORAGE_AREA_FULL</code>
<li><code>WIDGET_ERROR_DOWNLOAD</code>
<li><code>WIDGET_ERROR_INVALID_ZIP_ARCHIVE</code>
<li><code>WIDGET_ERROR_INVALID_SIGNATURE</code>
<li><code>WIDGET_ERROR_GENERIC</code>
<li><code>WIDGET_ERROR_SIZE_EXCEEDED</code>
<li><code>WIDGET_ERROR_PERMISSION_DENIED</code>
<p>as defined in section <a href="#application-oipfApplicationManager-constants" class="sectionRef"></a>.</p>
</ul></ul>
</td></tr>
</table>

<table class="dae-property-table" id="oipfApplicationManager-onwidgetuninstallation">
<tr><td class="api-signature">function <b>onWidgetUninstallation</b>( <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> wd, Integer state )</td></tr>
<tr><td>The function that is called during the uninstallation process of a Widget. The function is called with two arguments, defined below:<ul>
<li><code><a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> wd</code> - the WidgetDescriptor of the Widget to be uninstalled.
<li><code>Integer state</code> - the state of the installation; valid values are:<ul>
<li><code>WIDGET_UNINSTALLATION_STARTED </code>
<li><code>WIDGET_UNINSTALLATION_COMPLETED </code>
<li><code>WIDGET_UNINSTALLATION_FAILED </code>
<p>as defined in section <a href="#application-oipfApplicationManager-constants" class="sectionRef"></a>.</p></ul>
</ul>
</td></tr>
</table>
<table class="dae-property-table" id="oipfApplicationManager-widgets">
<tr><td class="api-signature">readonly <a href="#widgetdescriptorcollection-class" class="apiRef">WidgetDescriptorCollection</a> <b>widgets</b></td></tr>
<tr><td>A collection of <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> objects for the Widgets currently installed on the OITF.</td></tr>
</table>


</section>

<section id='application-oipfApplicationManager-methods'>
<h4>Methods</h4>
<table class="dae-method-table" id="oipfApplicationManager-getapplicationvisualizationmode">
<tr><td colspan="2" class="api-signature">Integer <b>getApplicationVisualizationMode</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1">
Returns the current mode used by the OITF to visualize applications, whereby a return value:
<table class="dae-api-values-table">
<tr><td>1</td><td>corresponds to the application visualization mode as defined by bullet 1) of <a href="#use-of-the-display" class="sectionRef"></a>, i.e. multiple applications visible simultaneously with DAE applications managing their own size, position and visibility</td></tr>
<tr><td>2</td><td>corresponds to the application visualization mode as defined by bullet 2) of <a href="#use-of-the-display" class="sectionRef"></a>, i.e. multiple applications visible simultaneously with OITF managing the size, position, visibility of applications</td></tr>
<tr><td>3</td><td>corresponds to the application visualization mode as defined by bullet 3) of <a href="#use-of-the-display" class="sectionRef"></a>, i.e. only a single application visible at any time.</td></tr>

</table>
</td>
</table>

<table class="dae-method-table" id="oipfApplicationManager-getownerapplication">
<tr><td colspan="3" class="api-signature"><a href="#application-class" class="apiRef">Application</a> <b>getOwnerApplication</b>( Document document )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Get the application that the specified document is part of. If the document is not part of an application, or the calling application does not have permission to access that application, this method will return <code>null</code>.</td>
</tr>
<tr>
<td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">document</td>
<td>The document for which the Application object should be obtained.</td>
</tr>
</table>

<table class="dae-method-table" id="oipfApplicationManager-getchildapplications">
<tr><td colspan="3" class="api-signature"><a href="#applicationcollection-class" class="apiRef">ApplicationCollection</a> <b>getChildApplications</b>( <a href="#application-class" class="apiRef">Application</a> application )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Get the applications that are children of the specified application.</td>
</tr>
<tr>
<td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">application</td>
<td>The application whose children should be returned.</td>
</tr>
</table>

<table class="dae-method-table" id="oipfApplicationManager-gc">
<tr><td colspan="2" class="api-signature">void <b>gc</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Provide a hint to the execution environment that a garbage collection cycle should be initiated.  The OITF is not required to act upon this hint.</td>
</tr>
</table>

<table class="dae-method-table" id="oipfApplicationManager-installwidget">
<tr><td colspan="3" class="api-signature">void <b>installWidget</b>( String uri )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Attempts to install on the OITF a Widget located at the URI passed. If the Widget is stored on a remote server it SHALL first be downloaded. This specification does not specify where the OITF stores the Widget package, nor does it define what happens to the original package after the installation process has finished (regardless of whether it succeeded or failed).
<p>When trying to install a Widget with an &ldquo;id&rdquo; that collides with the id of an already installed Widget (where the &ldquo;id&rdquo; is defined in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#the-id-attribute" class="extRef">section 7.6.1</a> of [[!Widgets-Packaging]] along with the extension defined in section <a href="#widgets-packaging-and-configuration" class="sectionRef"></a> of this specification), the OITF SHOULD ask the user for confirmation before installing the Widget. The OITF SHOULD provide information about the conflict (e.g. the version numbers, if available) to allow the user to decide whether to proceed with the installation or to cancel it.</p> 
<p>If the user confirms the installation, then the new Widget  SHALL replace the  one already installed; any storage area associated with the replaced Widget SHALL be retained. Note that the user can also choose to downgrade a Widget, i.e. install an old version of the Widget to replace the installed, more recent, one.</p>
</td>
</tr>
<tr>
<td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">uri</td>
<td>The resource locator in form of a URI, which points to a Widget package to be installed.</td>
</tr>
</table>

<table class="dae-method-table" id="oipfApplicationManager-uninstallwidget">
<tr><td colspan="3" class="api-signature">void <b>uninstallWidget</b>( <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> wd )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Uninstalls a Widget. If this Widget is running it will be stopped. Any storage areas associated with the uninstalled Widget SHALL be deleted.</td>
</tr>
<tr>
<td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">wd</td>
<td>A <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> object for a Widget installed on the OITF.</td>
</tr>
</table>
</section>

<section id='application-oipfApplicationManager-events'>
<h4>Events</h4>
<p>For the intrinsic events listed in the table below a corresponding DOM event SHALL be generated in the following manner:</p>
<table class="dae-event-table">
<thead><tr><th>Intrinsic Event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr></thead>
<tr><td><a href="#oipfApplicationManager-onlowmemory" class="apiRef">onLowMemory</a></td><td>LowMemory</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
<tr><td><a href="#oipfApplicationManager-onapplicationloaded" class="apiRef">onApplicationLoaded</a></td><td>ApplicationLoaded </td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>appl</code></td></tr>
<tr><td><a href="#oipfApplicationManager-onapplicationunloaded" class="apiRef">onApplicationUnloaded</a></td><td>ApplicationUnloaded </td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>appl</code></td></tr>
<tr><td><a href="#oipfApplicationManager-onapplicationloaderror" class="apiRef">onApplicationLoadError</a></td><td>ApplicationLoadError</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>appl</code></td></tr>
<tr><td><a href="#oipfApplicationManager-onwidgetinstallation" class="apiRef">onWidgetInstallation</a></td><td>WidgetInstallation</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>wd</code>, <code>state</code>, <code>reason</code></td></tr>
<tr><td><a href="#oipfApplicationManager-onwidgetuninstallation" class="apiRef">onWidgetUninstallation</a></td><td>WidgetUninstallation</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>wd</code>, <code>state</code></td></tr>
</table>

<p>NOTE: the above DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving the events listed above during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>application/oipfApplicationManager</code> object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>
</section>

<section id='application-class'>
<h3>The Application class</h3>
<p>The <code>Application</code> class is used to implement the characteristics of a DAE application.</p>
<p>If the document of an application is modified (or even replaced entirely), the <code>Application</code> object SHALL be retained. This means that the permission set granted when the application is created applies to all &ldquo;edits&rdquo; of the document or other pages in the application, until the application is destroyed.</p>
<section id="application-class-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="application-visible">
<tr><td class="api-signature">readonly Boolean <b>visible</b></td></tr>
<tr><td><code>true</code> if the application is visible, <code>false</code> otherwise. The value of this property is not affected by the application's Z-index or position relative to other applications. Only calls to the <a href="#application-show" class="apiRef">show()</a> and <a href="#application-hide" class="apiRef">hide()</a> methods will affect its value.</td></tr>
</table>
<table class="dae-property-table" id="application-active">
<tr><td class="api-signature">readonly Boolean <b>active</b></td></tr>
<tr><td><code>true</code> if the application is in the list of currently active applications, <code>false</code> otherwise (as defined in section <a href="#active-applications-list" class="sectionRef"></a>).</td></tr>
</table>
<table class="dae-property-table" id="application-permissions">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>permissions</b></td></tr>
<tr><td><a href="#stringcollection-class" class="apiRef">StringCollection</a> object containing the names of the permissions granted to this application.</td></tr>
</table>
<table class="dae-property-table" id="application-isprimaryreceiver">
<tr><td class="api-signature">readonly Boolean <b>isPrimaryReceiver</b></td></tr>
<tr><td><code>true</code> if the application receives cross application events before any other application, <code>false</code> otherwise.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Window <b>window</b></td></tr>
<tr><td>A strict subset of the DOM Window object representing the application. No symbols from the Window object are accessible through this property except the following:<ul>
<li><code>void <b>postMessage</b>( <i>any message</i>, String targetOrigin )</code></ul>
</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#applicationprivatedata-class" class="apiRef">ApplicationPrivateData</a> <b>privateData</b></td></tr>
<tr><td><p>Access the current application's private data object.</p>
<p>If an application attempts to access the privateData property of an Application object for a different application, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>.</p>
</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">
function <b>onApplicationActivated</b><br />
function <b>onApplicationDeactivated</b><br />
function <b>onApplicationShown</b><br />
function <b>onApplicationHidden</b><br />
function <b>onApplicationPrimaryReceiver</b><br />
function <b>onApplicationNotPrimaryReceiver</b><br />
function <b>onApplicationTopmost</b><br />
function <b>onApplicationNotTopmost</b><br />
function <b>onApplicationDestroyRequest</b><br />
function <b>onApplicationHibernateRequest</b><br />
function <b>onKeyPress</b><br />
function <b>onKeyUp</b><br />
function <b>onKeyDown</b><br />
</td></tr>
<tr><td>Each of these event handlers represents a DOM 0 event handler that corresponds to one of the events listed in sections <a href="#cross-application-event-handling" class="sectionRef"></a> and <a href="#new-dom-events-for-application-support" class="sectionRef"></a></td></tr>
</table>

</section>
<section id="application-class-methods">
<h4>Methods</h4>

<table class="dae-method-table" id="application-show">
<tr><td colspan="2" class="api-signature">void <b>show</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">If the application visualization mode as defined by method <a href="#oipfApplicationManager-getapplicationvisualizationmode" class="apiRef">getApplicationVisualizationMode()</a> in section <a href="#application-oipfApplicationManager-methods" class="sectionRef"></a>, is:<ol class="manual">
<li>1: Make the application visible. 
<li>2: Make the application visible. Calling this method from the application itself may have no effect.
<li>3: Request to make the application visible.</ol>
<p>This method only affects the visibility of an application. In the case where more than one application is visible, calls to this method will not affect the z-index of the application with respect to any other visible applications.</p>
</td>
</tr>
</table>

<table class="dae-method-table" id="application-hide">
<tr><td colspan="2" class="api-signature">void <b>hide</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">If the application visualization mode as defined by method <a href="#oipfApplicationManager-getapplicationvisualizationmode" class="apiRef">getApplicationVisualizationMode()</a> in section <a href="#application-oipfApplicationManager-methods" class="sectionRef"></a>, is:<ol class="manual">
<li>1: Make the application invisible. 
<li>2: Make the application invisible. Calling this method from the application itself may have no effect.
<li>3: Request to make the application invisible. </ol>
<p>Calling this method has no effect on the lifecycle of the application.</p>
<p>Note: Broadcast independent applications should not call this method. Doing so may result in only the background being visible to the user.</p>
</td>
</tr>
</table>

<table class="dae-method-table" id="application-activateinput">
<tr><td colspan="2" class="api-signature">void <b>activateInput</b>( Boolean gainFocus )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Move the application to the front of the active applications list. If the application has been hidden using <a href="#application-hide" class="apiRef">Application.hide()</a>, this method does not cause the application to be shown.
If the application visualization mode as defined by method <a href="#oipfApplicationManager-getapplicationvisualizationmode" class="apiRef">getApplicationVisualizationMode()</a> in section <a href="#application-oipfApplicationManager-methods" class="sectionRef"></a>, is:<ol class="manual">
<li>1: The application's <code>Window</code> object SHALL be moved to the top of the stack of visible applications. In addition, the application's Window object SHALL gain input focus if argument <code>gainFocus</code> has value <code>true</code>.
<li>2: The application's <code>Window</code> object SHALL be moved to the top of the stack of visible applications. In addition, the application's Window object SHALL gain input focus if argument <code>gainFocus</code> has value <code>true</code>. Calling this method from the application itself MAY have no effect. 
<li>3: Request to make the application's <code>Window</code> object visible. Once visible, the application SHALL be given input focus, irrespective of the value for argument <code>gainFocus</code>.
</ol>
</td>
</tr>
</table>

<table class="dae-method-table" id="application-deactivateinput">
<tr><td colspan="2" class="api-signature">void <b>deactivateInput</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Remove the application from the active applications list. This has no effect on the lifecycle of the application and MAY have no effect on the resources it uses. Applications which are not active will receive no cross-application events, unless their <a href="#application-class" class="apiRef">Application</a> object is the target of the event (as for the events defined in section <a href="#new-dom-events-for-application-support" class="sectionRef"></a>). Applications may still be manipulated via their <a href="#application-class" class="apiRef">Application</a> object or their DOM tree.

</td>
</tr>
</table>

<table class="dae-method-table" id="application-createapplication">
<tr><td colspan="3" class="api-signature">Application <b>createApplication</b>( String uri, Boolean createChild )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Create a new application and add it to the application tree. Calling this method does not automatically show the newly-created application.</p>
<p>This call is asynchronous and may return before the new application is fully loaded.  An <code>ApplicationLoaded</code> event will be targeted at the <a href="#application-class" class="apiRef">Application</a> object when the new application has fully loaded.</p>
<p>If the application cannot be created, this method SHALL return <code>null</code>.</p>
</td>
</tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">uri</td><td>The URI of the first page of the application to be created or the <code>localURI</code> of a Widget as defined in section <a href="#widgetdescriptor-properties" class="sectionRef"></a></td></tr>
<tr><td class="dae-method-table-argument">createChild</td><td>Flag indicating whether the new application is a child of the current application.  A value of <code>true</code> indicates that the new application should be a child of the current application; a value of <code>false</code> indicates that it should be a sibling. </td></tr>
</table>

<table class="dae-method-table" id="application-destroyapplication">
<tr><td colspan="2" class="api-signature">void <b>destroyApplication</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Terminate the application, detach it from the application tree, and make any resources used available to other applications.  When an application is terminated, any child applications shall also be terminated.
</td>
</tr>
</table>

<table class="dae-method-table" id="application-startwidget">
<tr><td colspan="3" class="api-signature"><a href="#application-class" class="apiRef">Application</a> <b>startWidget</b>( <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> wd, Boolean createChild )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Create a Widget installed on the OITF. The behaviour of this method is equivalent to that of <a href="#application-createapplication" class="apiRef">Application.createApplication()</a>.</p>
<p>The Widget is identified by its <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a>. To get a list of the <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> objects for the installed Widgets one can check <a href="#oipfApplicationManager-widgets" class="apiRef">ApplicationManager.widgets</a> property. If the Widget is already running or fails to start this call will return <code>null</code>.</p>
</td>
</tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">wd</td><td>a <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> object for a Widget installed on the OITF.</td></tr>
<tr><td class="dae-method-table-argument">createChild</td><td>Flag indicating whether the new application is a child of the current application.  A value of <code>true</code> indicates that the new application should be a child of the current application; a value of <code>false</code> indicates that it should be a sibling. </td></tr>
</table>

<table class="dae-method-table" id="application-stopwidget">
<tr><td colspan="3" class="api-signature"><a href="#application-class" class="apiRef">Application</a> <b>stopWidwet</b>( <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> wd )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Terminate a running Widget. The behaviour of this method is equivalent to that of <code>Application.destroyApplication()</code>.</p>
<p>Calling this method will detach the Widget from the application tree, and make any resources used available to other applications. When a Widget is terminated, any child applications shall also be terminated.
</p>
</td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">wd</td><td>a <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> object for a Widget installed on the OITF.</td></tr>
</table>
</section>
</section>

<section id="applicationcollection-class">
<h3>The ApplicationCollection class</h3>
<pre>
typedef Collection&lt;<a href="#application-class" class="apiRef">Application</a>&gt; ApplicationCollection
</pre>
<p>The <code>ApplicationCollection</code> class represents a collection of <a href="#application-class" class="apiRef">Application</a> objects.  See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>

<section id="applicationprivatedata-class">
<h3>The ApplicationPrivateData class</h3>

<section id="applicationprivatedata-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#keyset-class" class="apiRef">Keyset</a> <b>keyset</b></td></tr>
<tr><td>The object representing the user input events sent to the DAE application.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#channel-class" class="apiRef">Channel</a> <b>currentChannel</b></td></tr>
<tr><td>For a broadcast-related application, the value of the property contains the channel whose AIT is currently controlling the lifecycle of this application. If no channel is being presented, or if the application is not broadcast-related, the value of this property shall be <code>null</code>.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>wakeupApplication</b></td></tr>
<tr><td>The <code>wakeupApplication</code> property is set if there has been a <a href="#applicationprivatedata-preparewakeupapplication" class="apiRef">prepareWakeupApplication()</a> request by that application.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>wakeupOITF</b></td></tr>
<tr><td>The <code>wakeupOITF</code> property is set if there has been a call to the <a href="#applicationprivatedata-preparewakeupoitf" class="apiRef">prepareWakeupOITF()</a> method.</td></tr>
</table>
</section>
<section id="applicationprivatedata-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="2" class="api-signature">Integer <b>getFreeMem</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Let application developer query information about the current memory available to the application. This is used to help during application development to find application memory leaks and possibly allow an application to make decisions related to its caching strategy (e.g. for images).</p>
<p>Returns the available memory to the application or -1 if the information is not available.</p>
<p>For example:</p><pre class="javascript">
var app = appman.getOwnerApplication(window.document);
debug("[APP] free mem = " + app.privateData.getFreeMem() + "\n");
</pre>
</td>
</tr>
</table>

<table class="dae-method-table" id="applicationprivatedata-preparewakeupapplication">
<tr><td colspan="3" class="api-signature">Boolean <b>prepareWakeupApplication</b>( String URI, String token, Date time )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">The <code>prepareWakeupApplication()</code> method allows the DAE application to set-up the OITF to wake-up at a specified time. The wake-up is limited to the OITF being in the <code>PASSIVE_STANDBY</code> state at the specified time. If the timer expires while the DAE application is in a different state it is silently ignored.
<p>Only one wake-up is to be supported for a DAE application. If a previous wake-up request had been registered it SHALL be overwritten.</p>
<p>If the wake-up fails to be set-up this operation SHALL return <code>false</code>. Failure may be due to OITF expecting to change to an <code>OFF</code> power state which would not allow the wake-up request to survive.</p>

</td>
</tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">URI</td><td>The URI from which the content can be fetched.</td></tr>
<tr><td class="dae-method-table-argument">token</td><td>The token is a string which the application may retrieve with <a href="#applicationprivatedata-clearwakeuptoken" class="apiRef">clearWakeupToken()</a>.</td></tr>
<tr><td class="dae-method-table-argument">time</td><td>The time when the wake-up is to occur.</td></tr>
</table>

<table class="dae-method-table" id="applicationprivatedata-preparewakeupoitf">
<tr><td colspan="3" class="api-signature">Boolean <b>prepareWakeupOITF</b>( Date time )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">The <code>prepareWakeupOITF()</code> method allows the DAE application to set-up the OITF to wake-up at a specified time. The wake-up is limited to the OITF being in the <code>PASSIVE_STANDBY</code> or <code>PASSIVE_STANDBY_HIBERNATE</code> state at the specified time. If the timer expires while the DAE application is in a different state it is silently ignored.
<p>Unlike <a href="#applicationprivatedata-preparewakeupapplication" class="apiRef">prepareWakeupApplication()</a> this method applies to all the DAE applications and not limited to a single DAE application.</p>
<p>If the wake-up fails to be set-up this operation SHALL return <code>false</code>. Failure may be due to OITF expecting to change to an <code>OFF</code> power state which would not allow the wake-up request to survive.</p>

</td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">time</td><td>The time when the wake-up is to occur.</td></tr>
</table>

<table class="dae-method-table" id="applicationprivatedata-clearwakeuptoken">
<tr><td colspan="2" class="api-signature">String <b>clearWakeupToken</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>The <code>clearWakeupToken()</code> method shall return the token set in <a href="#applicationprivatedata-preparewakeupapplication" class="apiRef">prepareWakeupApplication()</a> method.  The wake-up token should be cleared once it is read in order to limit usage to only when the DAE application starts up.</p>
</td>
</tr>
</table>
</section>
</section>

<section id="keyset-class">
<h3>The Keyset class</h3>
<p>The <code>Keyset</code> object permits applications to define which key events they request to receive. There are two means of defining this. Common key events are represented by constants defined in this class which are combined in a bit-wise mask to identify a set of key events. Less common key events are not included in one of the defined constants and form part of an array.</p>
<p>The supported key events indicated through the capability mechanism in section <a href="#client-capability-description" class="sectionRef"></a> SHALL be the same as the maximum set of key events available to the browser as indicated through this object.</p>
<p>The default set of key events available to broadcast-related applications shall be none. The default set of key events available to broadcast-independent or service provider related applications which do not call <code>Keyset.setValue()</code> SHALL be all those indicated by the constants in this class which are supported by the OITF excluding those indicated by <code>OTHER</code>.</p>

<section id="keyset-class-constants">
<h4>Constants</h4>
<table class="dae-constant-table">
<tr><th>Constant name</th><th>Numeric Value</th><th>Use</th></tr>
<tr><td>RED</td><td>0x1</td><td>Used to identify the <code>VK_RED</code> key event.</td></tr>
<tr><td>GREEN</td><td>0x2</td><td>Used to identify the <code>VK_GREEN</code> key event.</td></tr>
<tr><td>YELLOW</td><td>0x4</td><td>Used to identify the <code>VK_YELLOW</code> key event.</td></tr>
<tr><td>BLUE</td><td>0x8</td><td>Used to identify the <code>VK_BLUE</code> key event.</td></tr>
<tr><td>NAVIGATION</td><td>0x10</td><td>Used to identify the <code>VK_UP</code>, <code>VK_DOWN</code>, <code>VK_LEFT</code>, <code>VK_RIGHT</code>, <code>VK_ENTER</code> and <code>VK_BACK</code> key events.</td></tr>
<tr><td>VCR</td><td>0x20</td><td>Used to identify the <code>VK_PLAY</code>, <code>VK_PAUSE</code>, <code>VK_STOP</code>, <code>VK_NEXT</code>, <code>VK_PREV</code>, <code>VK_FAST_FWD</code>, <code>VK_REWIND</code>, <code>VK_PLAY_PAUSE</code> key events.</td></tr>
<tr><td>SCROLL</td><td>0x40</td><td>Used to identify the <code>VK_PAGE_UP</code> and <code>VK_PAGE_DOWN</code> key events.</td></tr>
<tr><td>INFO</td><td>0x80</td><td>Used to identify the <code>VK_INFO</code> key event.</td></tr>
<tr><td>NUMERIC</td><td>0x100</td><td>Used to identify the number events, 0 to 9.</td></tr>
<tr><td>ALPHA</td><td>0x200</td><td>Used to identify all alphabetic events.</td></tr>
<tr><td>OTHER</td><td>0x400</td><td>Used to indicate key events not included in one of the other constants in this class.</td></tr>

</table>
</section>
<section id="keyset-class-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>value</b></td></tr>
<tr><td>The value of the keyset which this DAE application will receive.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>otherKeys</b>[ ]</td></tr>
<tr><td>If the <code>OTHER</code> bit in the value property is set then this indicates those key events which are available to the browser which are not included in one of the constants defined in this class, If the <code>OTHER</code> bit in the value property is not set then this property is meaningless.</td></tr>
</table>
<table class="dae-property-table" id="keyset-maximumvalue">
<tr><td class="api-signature">readonly Integer <b>maximumValue</b></td></tr>
<tr><td>In combination with <a href="#keyset-maximumotherkeys" class="apiRef">maximumOtherKeys</a>, this indicates the maximum set of key events which are available to the browser. When a bit in this <code>maximumValue</code> has value 0, the corresponding key events are never available to the browser.</td></tr>
</table>
<table class="dae-property-table" id="keyset-maximumotherkeys">
<tr><td class="api-signature">readonly Integer <b>maximumOtherKeys</b>[ ]</td></tr>
<tr><td>If the <code>OTHER</code> bit in the <a href="#keyset-maximumvalue" class="apiRef">maximumValue</a> property is set then, in combination with <a href="#keyset-maximumvalue" class="apiRef">maximumValue</a>, this indicates the maximum set of key events which are available to the browser. For key events which are not included in one of the constants defined in this class, if they are not listed in this array then they are never available to the browser. If the <code>OTHER</code> bit in the value property is not set then this property is meaningless.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">Boolean <b>supportsPointer</b></td></tr>
<tr><td><p>Applications that have been designed to handle Mouse Events can express it by using this property.</p>
<p>Applications SHALL set this property to <code>true</code> to indicate that they support a pointer based interaction model, i.e. that they listen to and handle Mouse Events as included in the Web Standards TV profile [[!OIPF_WSTVP2]]. They SHALL set it to false otherwise. If not set, an OITF SHALL assume that the application does not support a pointer based interaction model.</p>
<p>Based on the value of this property, an OITF MAY decide to enable or disable the rendering of a free moving cursor.</p>
<p>Note: OITFs are not required to support a pointer based input device even though they are recommended to do so. If pointer based input devices are supported, this is expressed via the <code>+POINTER</code> UI Profile fragment as described in section <a href="#default-ui-profiles" class="sectionRef"></a></p>
</td></tr>
</table>

</section>
<section id="keyset-class-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Integer <b>setValue</b>( Integer value, Integer otherKeys[ ] )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Sets the value of the keyset which this DAE application requests to receive. Where more than one DAE application is running, the events delivered to the browser SHALL be the union of the events requested by all running DAE applications. Under these circumstances, applications may receive events which they have not requested to receive.</p>
<p>The return value indicates which keys will be delivered to this DAE application encoded as bit-wise mask of the constants defined in this class.</p>
</td>
</tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">value</td><td>The value is a number which is a bit-wise mask of the constants defined in this class. For example;<pre class="javascript">
myKeyset = myApplication.privateData.keyset;

myKeyset.setValue(0x00000013);
myKeyset.setValue(myKeyset.INFO | myKeyset.NUMERIC);
</pre></td></tr>
<tr><td class="dae-method-table-argument">otherkeys</td><td>This parameter is optional. If the value parameter has the OTHER bit set then it is used to indicate the key events that the application wishes to receive which are not represented by constants defined in this class.</td></tr>
</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">String <b>getKeyIcon</b>( Integer code )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Return the URI of the icon representing the physical key or other mechanism that is used by the terminal to generate the key event for the given keycode passed. It SHALL return <code>null</code> if the key has no icon associated with it.</td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">code</td><td>The <code>VK_</code> constant for the key whose icon should be returned.</td></tr>
</table>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">String <b>getKeyLabel</b>( Integer code )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Return the textual label representing the physical key or other mechanism that is used by the terminal to generate the key event for the given keycode passed. It SHALL return <code>null</code> if the key has no icon associated with it.</td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">code</td><td>The <code>VK_</code> constant for the key whose textual label should be returned.</td></tr>
</table>
</section>
</section>

<section id="new-dom-events-for-application-support">
<h3>New DOM events for application support</h3>
<p>New events have been created that are raised on the Application objects in the application tree. These are normal events, not cross-application events, and are used to indicate changes in the state of an application.</p>
<table class="simple" id="new-dom-events-for-application-support-table">
<caption>Table ####: New DOM events for application support</caption>
<thead><tr><th>Event</th><th>Description</th></tr></thead>
<tr><td><code>ApplicationActivated</code></td><td>Issued when an application focus change occurs to inform the recipient of the event that the application is now focussed.</td></tr>
<tr><td><code>ApplicationDeactivated</code></td><td>Issued when an application focus change occurs to inform the recipient of the event that the application is now no longer focussed.</td></tr>
<tr><td><code>ApplicationShown</code></td><td>Issued when an application has become visible.</td></tr>
<tr><td><code>ApplicationHidden</code></td><td>Issued when an application has become hidden.</td></tr>
<tr><td><code>ApplicationPrimaryReceiver</code></td><td>This event is issued to indicate that the target is now at the front of the active application list.</td></tr>
<tr><td><code>ApplicationNotPrimaryReceiver</code></td><td>This event is issued to indicate that the target is no longer at the front of the active application list.</td></tr>
<tr><td><code>ApplicationTopmost</code></td><td>This event is issued to indicate that the target is now the topmost (i.e. it has the highest Z-index and is not obscured by any other visible applications, for OITFs where multiple applications are visible simultaneously.</td></tr>
<tr><td><code>ApplicationNotTopmost</code></td><td>This event is issued to indicate that the target is no longer at the topmost application. For OITFs where only one application is visible at a time, this event indicates that the application is no longer visible to the user.</td></tr>
<tr><td><code>ApplicationDestroyRequest</code></td><td><p>This event is issued to indicate that the target application is about to be terminated. It is not issued when an application calls <a href="#application-destroyapplication" class="apiRef">destroyApplication()</a> method for itself (i.e. to exit itself).</p>
<p>Non-responsive applications SHOULD be forcibly terminated by the OITF, including the case where listeners for ApplicationDestroyRequest events do not return promptly.  The determination of when an application is "non-responsive" is terminal-specific.</p>
<p>If an application does not register a listener for this event and there is a need for the system to terminate the application, then the application SHALL be terminated immediately.</p>
</td></tr>
<tr><td><code>ApplicationHibernateRequest</code></td><td><p>This event is issued to indicate that the OITF is about to enter a hibernate mode.</p>
<p>The OITF SHALL start a short watchdog timer (e.g. 2 seconds). During this period the application may take any actions (for example to store the currently viewed channel in case of an unsuccessful start-up).</p>
</td></tr>
</table>

<p>These events do not bubble and cannot be cancelled. Each of these events has a corresponding DOM 0 event handler property on the <a href="#application-class" class="apiRef">Application</a> object.</p>
</section>

<section id="application-management-examples">
<h3>Examples (informative)</h3>
<p>The examples below illustrate some aspects of the application model.</p>
<section><h4>Locating the Application object</h4>
<p>The <a href="#application-oipfApplicationManager" class="apiRef">ApplicationManager</a> class provides the <a href="#oipfApplicationManager-getownerapplication" class="apiRef">getOwnerApplication()</a> method, which returns the document's owning application node:</p><pre class="javascript"> 
// Assumes that the application/oipfApplicationManager object has the ID 
// &ldquo;applicationmanager&rdquo;
var appMgr = document.getElementById( "applicationmanager" );
var self = appMgr.getOwnerApplication( Window.document );</pre>
<p>All other application functionality is available from this object.</p>
</section>
<section><h4>Creating a new application</h4>
<p>Creating a new application is a simple matter of creating a new <a href="#application-class" class="apiRef">Application</a> object. </p><pre class="javascript">
// Assumes that the application/oipfApplicationManager object has the ID 
// &ldquo;applicationmanager&rdquo;
var appMgr = document.getElementById( "applicationmanager" );
var self = appMgr.getOwnerApplication( Window.document );
var child = self.createApplication( url_of_application, true );</pre>
<p>A typical requirement on an application is to only become visible once it has fully loaded. To do this, it can take advantage of load events. Here is an example from a clock application, which wants to load an image to become the background of the clock, upon which it can write the text of the clock. </p><pre class="javascript">
&lt;script&gt;
function loaded() {

    var screen = document.defaultView.screen;
    var clock = document.getElementById( 'clock' );

    setup_clock( clock.width, clock.height );

    // Assumes that the application/oipfApplicationManager object has the ID 
    // &ldquo;applicationmanager&rdquo;
    var appMgr = document.getElementById( "applicationmanager" );
    var self = appMgr.getOwnerApplication( Window.document );
    self.show();
}
&lt;/script&gt;

&lt;style&gt; * { margin: 0cm } &lt;/style&gt;

&lt;body onload="loaded()"&gt;
   &lt;img id="clock" src="clockbackground.png" style="position: absolute; 
     top: 0px; left=0px"&gt;
&lt;/body&gt;
</pre>
</section>
</section>

<section id="widget-apis">
<h3>Widget APIs</h3>
<p>This section defines APIs an author can use to interact with Widgets installed on the OITF. Note that the Widget lifecycle is managed through the application manager as defined in the previous sections.</p>
<section id="widgetdescriptor-class">
<h4>The WidgetDescriptor class</h4>
<p>The WidgetDescriptor class is used to implement the characteristics of a DAE Widget.  It extends the Widget interface defined in section <a href="#widgets-interface" class="sectionRef"></a> of this specification with the properties below. </p>
<section id="widgetdescriptor-properties">
<h5>Properties</h5>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>localURI</b></td></tr>
<tr><td>The URI of the installed Widget. It can be used as an argument to <a href="#application-createapplication" class="apiRef">ApplicationManager.createApplication()</a> to run the Widget. The value of this property SHOULD NOT represent the actual location of the Widget on the OITF's local storage.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>downloadURI</b></td></tr>
<tr><td>The URI of the location from where the Widget package was downloaded. This property SHALL match the URI used as argument of <a href="#application-createapplication" class="apiRef">createApplication()</a> or <a href="#oipfApplicationManager-installwidget" class="apiRef">installWidget()</a> when installing the Widget.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>defaultIcon</b></td></tr>
<tr><td>A collection of URI strings for all the available default icons. Default icons are defined in [[!Widgets-Packaging]]. This collection only contains URIs for the icons currently available in the Widget package.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>customIcons</b></td></tr>
<tr><td>A collection of URI strings for all the custom icons of the current Widget. Custom icons are defined in [[!Widgets-Packaging]]. </td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>running</b></td></tr>
<tr><td>This flag indicates the running state of the Widget.</td></tr>
</table>

</section>
<section id="widgetdescriptor-clarifications">
<h5>Clarifications</h5>
The <code>WidgetDescriptor</code> class is used to identify an installed Widget regardless of whether it is running or not, and so some clarification on the attribute values defined for the Widget interfaces [[!Widgets-APIs]] is needed.  The attributes <a href="http://www.w3.org/TR/2011/CR-widgets-apis-20111213/#the-height-attribute" class="extRef">height</a> and <a href="http://www.w3.org/TR/2011/CR-widgets-apis-20111213/#the-width-attribute" class="extRef">width</a> are defined in [[!Widgets-APIs]] on the "Widget instance's viewport". When the Widget is not running those attributes SHALL take the value defined in the Widget Manifest (if any) otherwise they SHALL be <code>null</code>. When the Widget is running these attributes SHALL adhere to what is defined in [[!Widgets-APIs]].
</section>

</section>
<section id="widgetdescriptorcollection-class">
<h4>The WidgetDescriptorCollection class</h4>
<pre>
typedef Collection&lt;<a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a>&gt; WidgetDescriptorCollection
</pre>
The <code>WidgetDescriptorCollection</code> class represents a collection of <a href="#widgetdescriptor-class" class="apiRef">WidgetDescriptor</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>

</section>
</section> <!-- applications-management-apis -->

<section id="configuration-and-setting-apis">
<h2>Configuration and setting APIs</h2>
<p>This section defines the interface to configuration and user settings information. Hardware configuration of the OITF is managed via an instance of the <code>LocalSystem</code> object.  This provides access to hardware information and provides an entry point to configure the outputs and network interfaces of the OITF.  Settings relating to the user interface and behaviour of the platform software are managed via an instance of the <a href="#configuration-class" class="apiRef">Configuration</a> object.</p>
<p>This section is subject to security control, (see section <a href="#security-requirements-for-configuration-and-settings" class="sectionRef"></a>) and only applies if <code>&lt;configurationChanges&gt;</code> has value <code>true</code>.

<section id="application-oipfconfiguration">
<h3>The application/oipfConfiguration embedded object</h3>
<p>The OITF SHALL implement the &ldquo;<code>application/oipfConfiguration</code>&rdquo; object as defined below.  This object provides an interface to the configuration and user settings facilities within the OITF.</p>
<section id="application-oipfconfiguration-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#configuration-class" class="apiRef">Configuration</a> <b>configuration</b></td></tr>
<tr><td>Accesses the configuration object that sets defaults and shows system settings.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#localsystem-class" class="apiRef">LocalSystem</a> <b>localSystem</b></td></tr>
<tr><td>Accesses the object representing the platform hardware.</td></tr>
</table>
<table class="dae-property-table" id="oipfconfiguration-onipaddresschange">
<tr><td class="api-signature">function <b>onIpAddressChange</b>( <a href="#networkinterface-class" class="apiRef">NetworkInterface</a> item, String ipAddress )</td></tr>
<tr><td>The function that is called when the IP address of a network interface has changed. The specified function is called with two arguments <code>item</code> and <code>ipAddress</code>. The <code>ipAddress</code> may have the value <code>undefined</code> if a previously assigned address has been lost.</td></tr>
</table>
</section>
<section id="application-oipfconfiguration-events">
<h4>Events</h4>
<p>For the intrinsic event &ldquo;<a href="#oipfconfiguration-onipaddresschange" class="apiRef">onIpAddressChange</a>&rdquo;, a corresponding DOM event SHALL be generated, in the following manner:</p>
<table class="dae-event-table">
<thead><tr><th>Intrinsic Event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr></thead>
<tr><td><a href="#oipfconfiguration-onipaddresschange" class="apiRef">onIpAddressChange</a></td><td>IpAddressChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>item</code>, <code>ipAddress</code></td></tr>
</table>
<p>NOTE: the above DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD not rely on receiving an <code>IpAddressChange</code> event during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>application/oipfConfiguration</code> object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>
</section>

<section id="configuration-class">
<h3>The Configuration class</h3>
<p>The <code>Configuration</code> object allows configuration items within the system to be read and modified. This includes settings such as audio and subtitle languages, display aspect ratios and other similar settings. Unlike the <code><a href="#localsystem-class" class="apiRef">LocalSystem</a></code> object, this is concerned with software- and application-related settings rather than hardware configuration and control.</p>
<section id="configuration-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="configuration-preferredaudiolanguage">
<tr><td class="api-signature">String <b>preferredAudioLanguage</b></td></tr>
<tr><td><p>A comma-separated set of languages to be used for audio playback, in order of preference. </p>
<p>Each language SHALL be indicated by its ISO 639-2 language code as defined in [[!ISO639-2]].</p></td></tr>
</table>
<table class="dae-property-table" id="configuration-preferredsubtitlelanguage">
<tr><td class="api-signature">String <b>preferredSubtitleLanguage</b></td></tr>
<tr><td><p>A comma-separated set of languages to be used for subtitle playback, in order of preference. The subtitle component (see section <a href="#avsubtitlecomponent-class" class="sectionRef"></a>) that matches the highest ordered language SHALL be activated (equivelant to the selectComponent method) and all other subtitle components SHALL be deactivated (equivelant to the unselectComponent method).</p>
<p>Each language SHALL be indicated by its ISO 639-2 language code as defined in [[!ISO639-2]] or as a wildcard specifier "<code>***</code>".</p>
<p>If the wildcard is included it SHALL be the last item in the set. If no subtitle component in the content matches a language in this property and the wildcard is included then the first (lowest) subtitle component SHALL be selected.</p></td></tr>
</table>
<table class="dae-property-table" id="configuration-preferredUILanguage">
<tr><td class="api-signature">String <b>preferredUILanguage</b></td></tr>
<tr><td><p>A comma-separated set of languages to be used for the user interface of a service, in order of preference.</p>
<p>Each language SHALL be indicated by its ISO 639-2 language code as defined in [[!ISO639-2]].</p>
<p>If present, the HTTP <code>Accept-language</code> header shall contain the same languages as the preferredUILanguage property with the same order of preference. NOTE: The order of preference in the <code>Accept-language</code> header is indicated using the quality factor.</p></td></tr>
</table>
<table class="dae-property-table" id="configuration-countryId">
<tr><td class="api-signature">String <b>countryId</b></td></tr>
<tr><td>An ISO-3166 three character country code identifying the country in which the receiver is deployed.</td></tr>
</table>
<table class="dae-property-table" id="configuration-regionId">
<tr><td class="api-signature">Integer <b>regionId</b></td></tr>
<tr><td><p>An integer indicating the time zone within a country in which the receiver is deployed.  A value of 0 SHALL represent the eastern-most time zone in the country, a value of 1 SHALL represent the next time zone to the west, and so on.</p>
<p>Valid values are in the range 0 &mdash; 60.</p></td></tr>
</table>
<table class="dae-property-table" id="configuration-pvrpolicy">
<tr><td class="api-signature">Integer <b>pvrPolicy</b></td></tr>
<tr><td><p>The policy dictates what mechanism the system should use when storage space is exceeded. </p>
<p>Valid values are shown in the table below.</p>
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>Indicates a recording management policy where no recordings are to be deleted.</td></tr>
<tr><td>1</td><td>Indicates a recording management policy where only watched recordings MAY be deleted.</td></tr>
<tr><td>2</td><td>Indicates a recording management policy where only recordings older than the specified threshold (given by the <a href="#configuration-pvrsavedays" class="apiRef">pvrSaveDays</a> and <a href="#configuration-pvrsaveepisodes" class="apiRef">pvrSaveEpisodes</a> properties) MAY be deleted.</td></tr>
</table>
</td></tr>
</table>
<table class="dae-property-table" id="configuration-pvrsaveepisodes">
<tr><td class="api-signature">Integer <b>pvrSaveEpisodes</b></td></tr>
<tr><td>When the <a href="#configuration-pvrpolicy" class="apiRef">pvrPolicy</a> property is set to the value 2, this property indicates the minimum number of episodes that SHALL be saved for series-link recordings.</td></tr>
</table>
<table class="dae-property-table" id="configuration-pvrsavedays">
<tr><td class="api-signature">Integer <b>pvrSaveDays</b></td></tr>
<tr><td>When the <a href="#configuration-pvrpolicy" class="apiRef">pvrPolicy</a> property is set to the value 2, this property indicates the minimum save time (in days) for individual recordings.  Only recordings older than the save time MAY be deleted.</td></tr>
</table>

<table class="dae-property-table" id="pvrstartpadding">
<tr><td class="api-signature">Integer <b>pvrStartPadding</b></td></tr>
<tr><td>The default padding (measured in seconds) to be added at the start of a recording.</td></tr>
</table>
<table class="dae-property-table" id="pvrendpadding">
<tr><td class="api-signature">Integer <b>pvrEndPadding</b></td></tr>
<tr><td>The default padding (measured in seconds) to be added at the end of a recording.</td></tr>
</table>

<table class="dae-property-table" id="configuration-preferredtimeshiftmode">
<tr><td class="api-signature">Integer <b>preferredTimeShiftMode</b></td></tr>
<tr><td>The time shift mode indicates the preferred mode of operation for support of timeshift playback in the <a href="#video-broadcast" class="apiRef">video/broadcast</a> object.  Valid values are defined in the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property in section <a href="#video-broadcast-extensions-recording-timeshift-properties" class="sectionRef"></a>. The default value is 0, timeshift is turned off.</td></tr>
</table>

</section>
<section id="configuration-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">String <b>getText</b>( String key )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Get the system text string that has been set for the specified key.</td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">key</td><td>A key identifying the system text string to be retrieved.</td></tr>
</table>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">String <b>setText</b>( String key, String value )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Set the system text string that has been set for the specified key.  System text strings are used for automatically-generated messages in certain cases, e.g. parental control messages.</td>
</tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">key</td><td>A key identifying the system text string to be retrieved.
<table class="dae-api-left-values-table">
<thead><tr><th>Key</th><th>Description</th></tr></thead>
<tr><td>no_title</td><td><p>Text string used as the title for programmes and channels where no guide information is available.</p><p>Defaults to &ldquo;No information&rdquo;</p></td></tr>
<tr><td>no_synopsis</td><td><p>Text string used as the synopsis for programmes where no guide information is available.</p><p>Defaults to &ldquo;No further information available&rdquo;</p></td></tr>
<tr><td>manual_recording</td><td><p>Text string used to identify a manual recording.</p><p>Defaults to &ldquo;Manual Recording&rdquo;</p></td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-argument">value</td><td>The new value for the system text string.</td></tr>
</table>

</section>
</section>

<section id="localsystem-class">
<h3>The LocalSystem class</h3>
<p>The <code>LocalSystem</code> object allows hardware settings related to the local device to be read and modified.</p>
<p>Note: The <code>standbyState</code> property has been removed from this class.</p>
<section id="localsystem-constants">
<h4>Constants</h4>
<p>The following values are defined for the standby state of the OITF:</p>
<table class="dae-constant-table">
<thead><tr><th>Name</th><th>Value</th><th>Use</th></tr></thead>
<tr><td>OFF</td><td>0</td><td>The OITF is in the off state and no power is consumed. This is the case of a power outage or if the OITF has the ability to be completely turned off. Scheduled recording is not expected to work.</td></tr>
<tr><td>ON</td><td>1</td><td>The OITF is in normal working mode with user interaction. The DAE applications may render any presentation graphically.</td></tr>
<tr><td>PASSIVE_STANDBY</td><td>2</td><td>The OITF is in the lowest possible power consumption state (meeting regulations and certifications). The OITF may support wake-up from a passive standby in order, for example, to perform a scheduled recording.</td></tr>
<tr><td>ACTIVE_STANDBY</td><td>3</td><td>The OITF is in an intermediate power consumption state. The output to the display shall be inactive. In this state DAE applications may continue to operate.</td></tr>
<tr><td>PASSIVE_STANDBY_HIBERNATE</td><td>4</td><td>The OITF is in the lowest possible power consumption state (meeting regulations and certifications). If the platform supports hibernate mode then the OITF stores all applications in volatile memory to allow for quick startup.</td></tr>
<tr><td>RESTART</td><td>5</td><td>The OITF shall restart and return to a ON state.</td></tr>
<tr><td>FACTORY_RESET</td><td>6</td><td>Restart the OITF and reset all settings and data to an initial/factory state. The exact settings and data to be reset are implementation dependant. The use of the this operation with the <a href="#localsystem-setpowerstate" class="apiRef">setPowerState</a> method is subject to security control defined in section <a href="#security-requirements-for-service-provider-controlled-oitf" class="sectionRef"></a></td></tr>
</table>
<p>The following values are defined for the startup URL of the OITF:</p>
<table class="dae-constant-table" id="localsystem-urlsource-constants">
<thead><tr><th>Name</th><th>Value</th><th>Use</th></tr></thead>
<tr><td>STARTUP_URL_NONE</td><td>0</td><td>No startup URL is known.</td></tr>
<tr><td>STARTUP_URL_DHCP</td><td>1</td><td>The startup URL is derived from DHCP procedures.</td></tr>
<tr><td>STARTUP_URL_TR069</td><td>2</td><td>The startup URL is derived through TR-069 procedures.</td></tr>
<tr><td>STARTUP_URL_PRECONFIGURED</td><td>3</td><td>The startup URL is that which is configured through the OITF firmware.</td></tr>
<tr><td>STARTUP_URL_OTHER</td><td>9</td><td>The startup URL is obtained through other (perhaps non-standardized) procedures.</td></tr>
</table>
</section>
<section id="localsystem-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="localsystem-deviceid">
<tr><td class="api-signature">readonly String <b>deviceID</b></td></tr>
<tr><td><p>Private OITF Identifier. This property SHALL take the value undefined except when accessed by applications meeting either of the following criteria:</p><ul>
<li>The application is signalled in an SD&amp;S service provider discovery record with an application usage of <code>urn:oipf:cs:ApplicationUsageCS:2009:hni-igi</code> where the SD&amp;S service provider discovery record was obtained by the OITF through the procedure defined in <a href="volume4.html#s5-4-1-2" class="extRef">section 5.4.1.2</a> of [[!OIPF_PROT2]].
<div class="editor-note">The <a href="volume3.html#applicationusageCS">R2v2.3 version of the Metadata specification</a> defines these as :2010</div>
<li>The URL of the application was discovered directly through the procedure defined in <a href="volume4.html#s5-4-1-2" class="extRef">section 5.4.1.2</a> of [[!OIPF_PROT2]].
</ul>
<p>In these two cases, it SHALL take the same value as defined for the DHCP client identifier in DHCP option 61 in <a href="volume4.html#s12-1-1-1" class="extRef">section 12.1.1.1</a> of [[!OIPF_PROT2]].</p>
</td></tr>
</table>

<table class="dae-property-table" id="localsystem-systemready">
<tr><td class="api-signature">readonly Boolean <b>systemReady</b></td></tr>
<tr><td>Indicates whether the system has finished initialising. A value of <code>true</code> indicates that the system is ready.</td></tr>
</table>

<table class="dae-property-table" id="localsystem-vendorname">
<tr><td class="api-signature">readonly String <b>vendorName</b></td></tr>
<tr><td>String identifying the vendor name of the device.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-modelname">
<tr><td class="api-signature">readonly String <b>modelName</b></td></tr>
<tr><td>String identifying the model name of the device.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-familyname">
<tr><td class="api-signature">readonly String <b>familyName</b></td></tr>
<tr><td>String identifying the name of the family that the device belongs to. Devices in a family differ only by details that do not impact the behaviour of the OITF aspect of the device, e.g. screen size, remote control, number of HDMI ports, size of hard disc. Family names are allocated by the vendor and the combination of <a href="#localsystem-vendorname" class="apiRef">vendorName</a> and <code>familyName</code> should uniquely identify a family of devices. Different vendors may use the same <code>familyName</code>, although they are recommended to use conventions that avoid this. </td></tr>
</table>
<table class="dae-property-table" id="localsystem-softwareversion">
<tr><td class="api-signature">readonly String <b>softwareVersion</b></td></tr>
<tr><td>String identifying the version number of the platform firmware.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-hardwareversion">
<tr><td class="api-signature">readonly String <b>hardwareVersion</b></td></tr>
<tr><td>String identifying the version number of the platform hardware.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-serialnumber">
<tr><td class="api-signature">readonly String <b>serialNumber</b></td></tr>
<tr><td>String containing the serial number of the platform hardware.</td></tr>
</table>

<table class="dae-property-table" id="localsystem-releaseversion">
<tr><td class="api-signature">readonly Integer <b>releaseVersion</b></td></tr>
<tr><td><p>Release version of the OIPF specification implemented by the OITF. </p>
<p>For instance, if the OITF implements release 2 version &ldquo;1.0&rdquo;, this property should be set to 2.</p></td></tr>
</table>
<table class="dae-property-table" id="localsystem-majorversion">
<tr><td class="api-signature">readonly Integer <b>majorVersion</b></td></tr>
<tr><td><p>Major version of the OIPF specification implemented by the OITF.</p>
<p>For instance, if the OITF implements release 2 version &ldquo;2.0&rdquo;, this property should be set to 2. </p></td></tr>
</table>
<table class="dae-property-table" id="localsystem-minorversion">
<tr><td class="api-signature">readonly Integer <b>minorVersion</b></td></tr>
<tr><td><p>Minor version of the OIPF specification implemented by the OITF.<p>
<p>For instance, if the OITF implements release 2 version &ldquo;2.0&rdquo;, this property should be set to 0. </p></td></tr>
</table>
<table class="dae-property-table" id="localsystem-oipfprofile">
<tr><td class="api-signature">readonly String <b>oipfProfile</b></td></tr>
<tr><td>Profile of the OIPF specification implemented by the OITF. Values of this field are not defined in this specification. </td></tr>
</table>
<table class="dae-property-table" id="localsystem-pvrenabled">
<tr><td class="api-signature">readonly Boolean <b>pvrEnabled</b></td></tr>
<tr><td><p>Flag indicating whether the platform has PVR capability (local PVR).</p><p>Note: This property is deprecated in favour of the <a href="#localsystem-pvrsupport" class="apiRef">pvrSupport</a> property.</p></td></tr>
</table>
<table class="dae-property-table" id="localsystem-ciplusenabled">
<tr><td class="api-signature">readonly Boolean <b>ciplusEnabled</b></td></tr>
<tr><td>Flag indicating whether the platform has CI+ capability.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-powerstate">
<tr><td class="api-signature">readonly Integer <b>powerState</b></td></tr>
<tr><td>The <code>powerState</code> property provides the DAE application the ability to determine the current state of the OITF. The property is limited to the <code>ACTIVE_STANDBY</code> or <code>ON</code> states.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-previouspowerstate">
<tr><td class="api-signature">readonly Integer <b>previousPowerState</b></td></tr>
<tr><td>The <code>previousPowerState</code> property provides the DAE application the ability to retrieve the previous state.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-timecurrentpowerstate">
<tr><td class="api-signature">readonly Integer <b>timeCurrentPowerState</b></td></tr>
<tr><td>The time that the OITF entered the current power state. The time is represented in seconds since midnight (GMT) on 1/1/1970.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-onpowerstatechange">
<tr><td class="api-signature">function <b>onPowerStateChange</b>( Integer powerState )</td></tr>
<tr><td>The function that is called when the power state has changed. The specified function is called with the argument powerState:<ul>
<li><code>Integer powerState</code> &mdash; the new power state.</ul>
</td></tr>
</table>
<table class="dae-property-table" id="localsystem-volume">
<tr><td class="api-signature">Integer <b>volume</b></td></tr>
<tr><td>Get or set the overall system volume.  Valid values for this property are in the range 0 - 100. The OITF SHALL store this setting persistently.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-mute">
<tr><td class="api-signature">Boolean <b>mute</b></td></tr>
<tr><td>Get or set the mute status of the default audio output(s).  A value of <code>true</code> indicates that the default output(s) are currently muted.</td></tr>
</table>

<table class="dae-property-table" id="localsystem-outputs">
<tr><td class="api-signature">readonly <a href="#avoutputcollection-class" class="apiRef">AVOutputCollection</a> <b>outputs</b></td></tr>
<tr><td>A collection of <a href="#avoutput-class" class="apiRef">AVOutput</a> objects representing the audio and video outputs of the platform.  Applications MAY use these objects to configure and control the available outputs.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-networkinterfaces">
<tr><td class="api-signature">readonly <a href="#networkinterfacecollection-class" class="apiRef">NetworkInterfaceCollection</a> <b>networkInterfaces</b></td></tr>
<tr><td>A collection of <a href="#networkinterface-class" class="apiRef">NetworkInterface</a> objects representing the available network interfaces.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-tuners">
<tr><td class="api-signature">readonly <a href="#tunercollection-class" class="apiRef">TunerCollection</a> <b>tuners</b></td></tr>
<tr><td>A collection of <a href="#tuner-class" class="apiRef">Tuner</a> objects representing the physical tuners available in the OITF.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-tvstandardssupported">
<tr><td class="api-signature">readonly Integer <b>tvStandardsSupported</b></td></tr>
<tr><td><p>Get the TV standard(s) which are supported on the analogue video outputs.</p><p>This property can take one or more of the following values:</p>
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>1</td><td>Indicates platform support for the NTSC TV standard.</td></tr>
<tr><td>2</td><td>Indicates platform support for the PAL-BGH TV standard.</td></tr>
<tr><td>4</td><td>Indicates platform support for the SECAM TV standard.</td></tr>
<tr><td>8</td><td>Indicates platform support for the PAL-M TV standard.</td></tr>
<tr><td>16</td><td>Indicates platform support for the PAL-N TV standard.</td></tr>
</table>

<p>Values are stored as a bitfield.</p>
</td></tr>
</table>
<table class="dae-property-table" id="localsystem-tvstandard">
<tr><td class="api-signature">readonly Integer <b>tvStandard</b></td></tr>
<tr><td><p>Get the TV standard for which the analogue video outputs are currently configured.</p><p>This property can take one or more of the following values:</p>
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>Indicates there are no analogue video outputs.</td></tr>
<tr><td>1</td><td>Indicates platform support for the NTSC TV standard.</td></tr>
<tr><td>2</td><td>Indicates platform support for the PAL-BGH TV standard.</td></tr>
<tr><td>4</td><td>Indicates platform support for the SECAM TV standard.</td></tr>
<tr><td>8</td><td>Indicates platform support for the PAL-M TV standard.</td></tr>
<tr><td>16</td><td>Indicates platform support for the PAL-N TV standard.</td></tr>
</table>

<p>Values are stored as a bitfield.</p>
</td></tr>
</table>
<table class="dae-property-table" id="localsystem-pvrsupport">
<tr><td class="api-signature">readonly Integer <b>pvrSupport</b></td></tr>
<tr><td><p>Flag indicating the type of PVR support used by the application. This property may take zero or more of the following values:</p>
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>PVR functionality is not supported. This is the default value if <code>&lt;recording&gt;</code> as specified in section <a href="#pvr-capability" class="sectionRef"></a> has value <code>false</code>.</td></tr>
<tr><td>1</td><td>PVR functionality is supported in the OITF. This is the default value if <code>&lt;recording&gt;</code> as specified in section <a href="#pvr-capability" class="sectionRef"></a> has value <code>true</code>.</td></tr>
</table>

<p>Values are stored as a bitfield.</p>
</td></tr>
</table>

<table class="dae-property-table" id="localsystem-startupinformation">
<tr><td class="api-signature">readonly <a href="#startupinformation-class" class="apiRef">StartupInformation</a> <b>startupInformation</b></td></tr>
<tr><td>Indicates any information used at startup time of the OITF.</td></tr>
</table>
<table class="dae-property-table" id="localsystem-onstartupinfochange">
<tr><td class="api-signature">function <b>onStartupInfoChange</b>( <a href="#startupinformation-class" class="apiRef">StartupInformation</a> startupInfo )</td></tr>
<tr><td><p>The function that is called when any property in the startup information is changed.</p><p>The specified function is called with the argument startupInfo:</p><ul>
<li><code><a href="#startupinformation-class" class="apiRef">StartupInformation</a> startupInfo</code> &mdash; the new startup information.</ul>
</td></tr>
</table>
</section>
<section id="localsystem-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="localsystem-setscreensize">
<tr><td colspan="3" class="api-signature">Boolean <b>setScreenSize</b>( Integer width, Integer height )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Set the resolution of the graphics plane. If the specified resolution is not supported by the OITF, this method SHALL return <code>false</code>. Otherwise, this method SHALL return <code>true</code>. </td>
</tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">width</td><td>The width of the display, in pixels.</td></tr>
<tr><td class="dae-method-table-argument">height</td><td>The height of the display, in pixels.</td></tr>
</table>

<table class="dae-method-table" id="localsystem-settvstandard">
<tr><td colspan="3" class="api-signature">Boolean <b>setTVStandard</b>( Integer tvStandard )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Set the TV standard to be used on the analogue video outputs. Returns <code>false</code> if the requested mode cannot be set.</td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">tvStandard</td><td>The TV standard to be set.  Valid values are defined in the description of the <a href="#localsystem-tvstandard" class="apiRef">tvStandard</a> property in section <a href="#localsystem-properties" class="sectionRef"></a>.</td></tr>
</table>

<table class="dae-method-table" id="localsystem-setpvrsupport">
<tr><td colspan="3" class="api-signature">Integer <b>setPvrSupport</b>( Integer state )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Set the type of PVR support used by the application.  The types of PVR supported by the receiver MAY not be supported by the application; in this case, the return value indicates the pvr support that has been set. </td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">state</td><td><p>The type of PVR support desired by the application.  More than one type of PVR functionality MAY be specified, allowing the receiver to automatically select the appropriate mechanism. Valid values are:</p>
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>PVR functionality is not supported. This is the default value if <code>&lt;recording&gt;</code> as specified in section <a href="#pvr-capability" class="sectionRef"></a> has value <code>false</code>.</td></tr>
<tr><td>1</td><td>PVR functionality is supported in the OITF. This is the default value if <code>&lt;recording&gt;</code> as specified in section <a href="#pvr-capability" class="sectionRef"></a> has value <code>true</code>.</td></tr>
</table>
<p>Values are stored as a bitfield.</p>
</td></tr>
</table>

<table class="dae-method-table" id="localsystem-setpowerstate">
<tr><td colspan="3" class="api-signature">Boolean <b>setPowerState</b>( Integer type )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>The <code>setPowerState()</code> method allows the DAE application to modify the OITF state.</p>
<p>The power state change may be restricted for some values of <code>type</code>, for example <code>OFF</code>, <code>PASSIVE_STANDBY</code>, <code>RESTART</code> and <code>FACTORY_RESET</code>. A call to <code>setPowerState()</code> with a restricted value of <code>type</code> SHALL return <code>false</code>.</p></td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">type</td><td>The type values that may be specified are defined in section <a href="#localsystem-constants" class="sectionRef"></a></td>
</tr>
</table>

<table class="dae-method-table" id="localsystem-setdigestcredentials">
<tr><td colspan="3" class="api-signature">Boolean <b>setDigestCredentials</b>( String protocol, String domain, String username, String password )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Set the credentials for the specified protocol to use for digest authentication negotiation for all subsequent requests to the specified domain. The credentials are persistently stored overwriting any previous set credentials. If domain is null the provided credentials SHALL apply for all domains. Returns <code>true</code> if credentials are successfully set, <code>false</code> otherwise.</p>
<p>If digest authentication is not supported for the specified protocol then return <code>false</code>. The valid values are the strings &ldquo;<code>http</code>&rdquo; and &ldquo;<code>https</code>&rdquo;.</p>
<p>Setting of Digest Credentials on the same protocol and domain SHALL update the username and password.</p>
<p>If the credentials, when used, are incorrect then the behaviour SHALL be the same as any other time that stored credentials are incorrect, e.g. saved values from a user prompt.</p>
<p>The credentials SHALL be used (if necessary) in all requests made by DAE applications. The credentials MAY be used in requests made by other components such as media players, DLNA clients, etc.</p></td>
</tr>
<tr><td class="dae-method-table-label" rowspan="4">Arguments</td>
<td class="dae-method-table-argument">protocol</td><td>The protocol to apply the credentials.</td></tr>
<tr><td class="dae-method-table-argument">domain</td><td>The domain to which the credentials apply.</td></tr>
<tr><td class="dae-method-table-argument">username</td><td>The username to be used in the digest authentication.</td></tr>
<tr><td class="dae-method-table-argument">password</td><td>The password to be used in the digest authentication.</td></tr>

</table>

<table class="dae-method-table" id="localsystem-cleardigestcredentials">
<tr><td colspan="3" class="api-signature">Boolean <b>clearDigestCredentials</b>( String protocol, String domain )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Clear any previously set digest credentials for the specified domain. If domain is <code>null</code> all set credentials are cleared.</p>
<p>Returns <code>true</code> if the digest credentials for the given <code>protocol</code> and <code>domain</code> were cleared or do not exist, or <code>false</code> if credentials failed to be cleared.</p></td>
</tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">protocol</td><td>The protocol to apply the credentials. The value should be the same as one of those specified for the <a href="#localsystem-setdigestcredentials" class="apiRef">setDigestCredentials()</a> method.</td></tr>
<tr><td class="dae-method-table-argument">domain</td><td>The domain to which the credentials apply.</td></tr>
</table>

<table class="dae-method-table" id="localsystem-hasdigectcredentials">
<tr><td colspan="3" class="api-signature">Boolean <b>hasDigestCredentials</b>( String protocol, String domain )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Check if digest credentials are currently defined for the specified protocol and domain.</p>
<p>Returns <code>true</code> if credentials have been set by a previous call to <a href="#localsystem-setdigestcredentials" class="apiRef">setDigestCredentials()</a>, otherwise returns <code>false</code>.</p></td>
</tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">protocol</td><td>The protocol to apply the credentials. The value should be the same as one of those specified for the <a href="#localsystem-setdigestcredentials" class="apiRef">setDigestCredentials()</a> method.</td></tr>
<tr><td class="dae-method-table-argument">domain</td><td>The domain to which the credentials apply.</td></tr>
</table>
</section>
<section id="localsystem-events">
<h4>Events</h4>
<p>For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:</p>
<table class="dae-event-table">
<thead><tr><th>Intrinsic Event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr></thead>
<tr><td>onPowerStateChange</td><td>PowerStateChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>powerState</code></td></tr>
<tr><td>onStartupInfoChange</td><td>StartupInfoChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>startupInfo</code></td></tr>
</table>

<p>NOTE: the above DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving the events listed above during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <a href="#localsystem-class" class="apiRef">LocalSystem</a> object.</p>
</section>
</section>


<section id="networkinterface-class">
<h3>The NetworkInterface class</h3>
<p>The <code>NetworkInterface</code> class represents a physical or logical network interface in the receiver.  </p>
<section id="networkinterface-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>ipAddress</b></td></tr>
<tr><td>The IP address of the network interface, in dotted-quad notation for IPv4 or colon-hexadecimal notation for IPv6. This property SHALL take the value undefined if no IP address has been assigned. The IP address may be link local, private or global, depending on which address block it belongs to, as reserved by IANA.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>macAddress</b></td></tr>
<tr><td>The colon-separated MAC address of the network interface.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>connected</b></td></tr>
<tr><td>Flag indicating whether the network interface is currently connected.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">Boolean <b>enabled</b></td></tr>
<tr><td>Flag indicating whether the network interface is enabled.  Setting this property SHALL enable or disable the network interface.</td></tr>
</table>
</section>
</section>

<section id="avoutput-class">
<h3>The AVOutput class</h3>
<p>The <code>AVOutput</code> class represents an audio or video output on the local platform.</p>
<section id="avoutput-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="avoutput-name">
<tr><td class="api-signature">readonly String <b>name</b></td></tr>
<tr><td>The name of the output. Each output SHALL have a name that is unique on the local system.  At least one of the outputs SHALL have the name "<code>all</code>" and SHALL represent all available outputs on the platform. The results of reading properties from the "<code>all</code>" <code>AVOutput</code> are implementation specific.</td></tr>
</table>
<table class="dae-property-table" id="avoutput-type">
<tr><td class="api-signature">readonly String <b>type</b></td></tr>
<tr><td>The type of the output.  Valid values are &ldquo;<code>audio</code>&rdquo;, &ldquo;<code>video</code>&rdquo;, or &ldquo;<code>both</code>&rdquo;.</td></tr>
</table>
<table class="dae-property-table" id="avoutput-enabled">
<tr><td class="api-signature">Boolean <b>enabled</b></td></tr>
<tr><td>Flag indicating whether the output is enabled.  Setting this property SHALL enable or disable the output.</td></tr>
</table>
<table class="dae-property-table" id="avoutput-subtitleenabled">
<tr><td class="api-signature">Boolean <b>subtitleEnabled</b></td></tr>
<tr><td>Flag indicating whether the subtitles are enabled.  The language of the displayed subtitles is determined by a combination of the value of the <a href="#configuration-preferredsubtitlelanguage" class="apiRef">Configuration.preferredSubtitleLanguage</a> property (see section <a href="#configuration-class" class="sectionRef"></a>) and the subtitles available in the stream. For audio outputs, setting this property will have no effect.</td></tr>
</table>

<table class="dae-property-table" id="avoutput-videomode">
<tr><td class="api-signature">String <b>videoMode</b></td></tr>
<tr><td><p>Read or set the video format conversion mode, for which hardware support MAY be available on the device. Valid values are:</p><ul class="allowed-values-list">
<li>normal
<li>stretch
<li>zoom
</ul>
<p>The following table provides guidance as to the relationship between <code>videoMode</code>, <code>aspectRatio</code> (output) and the <code>aspectRatio</code> (input) of the <a href="#avvideocomponent-class" class="apiRef">AVVideoComponent</a> class.</p>
<table class="dae-api-left-values-table">
<thead>
<tr><th rowspan="2">aspectRatio (input/output) value</th><th colspan="3">videoMode value</th></tr>
<tr><th>Normal</th><th>Stretch</th><th>Zoom</th></tr>
</thead>
<tr><td>16:9 input / 4:3 output</td><td>Black bars at top and bottom, all video visible</td><td>No black bars, picture stretched vertically</td><td>No black bars, picture clipped on left and right sides</td></tr>
<tr><td>4:3 input / 16:9 output</td><td>Black bars on left and right, all video visible</td><td>No black bars, picture stretched horizontally</td><td>No black bars, picture clipped top and bottom</td></tr>
<tr><td>4:3 input / 4:3 output</td><td>No change</td><td>No change</td><td>No change</td></tr>
<tr><td>16:9 input / 16:9 output</td><td>No change</td><td>No change</td><td>No change</td></tr>
</table>
<p>The DAE application graphical layer is unaffected by the <code>videoMode</code>. </p>
<p>For audio-only outputs, setting this property SHALL have no effect.</p>
</td></tr>
</table>

<table class="dae-property-table" id="avoutput-digitalAudioMode">
<tr><td class="api-signature">String <b>digitalAudioMode</b></td></tr>
<tr><td>Read or set the output mode for digital audio outputs for which hardware support MAY be available on the device. Valid values are shown below.
<table class="dae-api-left-values-table">
<thead>
<tr><th>Value</th><th>Behaviour</th></tr>
</thead>
<tr><td><code>ac3</code></td><td>Output AC-3 audio.</td></tr>
<tr><td><code>uncompressed</code></td><td>Output uncompressed PCM audio.</td></tr>
</table>
<p>For video-only outputs, setting this property SHALL have no effect.</p>
</td></tr>
</table>

<table class="dae-property-table" id="avoutput-audiorange">
<tr><td class="api-signature">String <b>audioRange</b></td></tr>
<tr><td>Read or set the range for digital audio outputs for which hardware support MAY be available on the device. Valid values are shown below
<table class="dae-api-left-values-table">
<thead>
<tr><th>Value</th><th>Behaviour</th></tr>
</thead>
<tr><td><code>normal</code></td><td>Use the normal audio range.</td></tr>
<tr><td><code>narrow</code></td><td>Use a narrow audio range.</td></tr>
<tr><td><code>wide</code></td><td>Use a wide audio range.</td></tr>
</table>
<p>For video-only outputs, setting this property SHALL have no effect.</p>
</td></tr>
</table>

<table class="dae-property-table" id="avoutput-hdvideoformat">
<tr><td class="api-signature">String <b>hdVideoFormat</b></td></tr>
<tr><td>Read or set the video format for HD and 3D video outputs for which hardware support MAY be available on the device. Valid values are:<ul class="allowed-values-list">
<li>480i
<li>480p
<li>576i
<li>576p
<li>720i
<li>720p 
<li>1080i
<li>1080p
<li>720p_TaB
<li>720p_SbS
<li>1080i_SbS
<li>1080p_TaB
<li>1080p_SbS
</ul>
For audio-only or standard-definition outputs, setting this property SHALL have no effect.
</td></tr>
</table>

<table class="dae-property-table" id="avoutput-tvaspectratio">
<tr><td class="api-signature">String <b>tvAspectRatio</b></td></tr>
<tr><td>Indicates the output display aspect ratio of the display device connected to this output for which hardware support MAY be available on the device. Valid values are:<ul class="allowed-values-list">
<li>4:3
<li>16:9
</ul>
For audio-only, setting this property SHALL have no effect.
</td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>supportedVideoModes</b></td></tr>
<tr><td><p>Read the video format conversion modes that may be used when displaying a 4:3 input video on a 16:9 output display or 16:9 input video on a 4:3 output display. The assumption is that the hardware supports conversion from either format and there is no distinction between the two.  See the definition of the <a href="#avoutput-videomode" class="apiRef">videoMode</a> property for valid values.</p>
<p>For audio outputs, this property will have the value <code>null</code>.</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>supportedDigitalAudioModes</b></td></tr>
<tr><td><p>Read the supported output modes for digital audio outputs.  See the definition of the <a href="#avoutput-digitalAudioMode" class="apiRef">digitalAudioMode</a> property for valid values.</p>
<p>For video outputs, this property will have the value <code>null</code>.</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>supportedAudioRanges</b></td></tr>
<tr><td><p>Read the supported ranges for digital audio outputs.  See the definition of the <a href="#avoutput-audiorange" class="apiRef">audioRange</a> property for valid values.</p>
<p>For video outputs, this property will have the value <code>null</code>.</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>supportedHdVideoFormats</b></td></tr>
<tr><td><p>Read the supported HD and 3D video formats.  See the definition of the <a href="#avoutput-hdvideoformat" class="apiRef">hdVideoFormat</a> property for valid values.</p>
<p>For audio outputs, this property will have the value <code>null</code>.</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>supportedAspectRatios</b></td></tr>
<tr><td><p>Read the supported TV aspect ratios.  See the definition of the <a href="#avoutput-tvaspectratio" class="apiRef">tvAspectRatio</a> property for valid values.</p>
<p>For audio outputs, this property will have the value <code>null</code>.</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>current3DMode</b></td></tr>
<tr><td>Read whether the display is currently in a 2D or 3D mode. Return values are:
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>The display is in a 2D video mode</td></tr>
<tr><td>1</td><td>The display is in a 3D video mode</td></tr>
</table>
</td></tr>
</table>

<table class="dae-property-table" id="avoutput-on3dmodechange">
<tr><td class="api-signature">function <b>on3DModeChange</b>( Integer action )</td></tr>
<tr><td>This function is the DOM 0 event handler for events relating to actions carried out on an item in a content catalogue. The specified function is called with the following arguments:<ul>
<li><code>Integer action</code> - The type of action that the event refers to.  Valid values are:
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>The display changed from a 3D to a 2D video mode</td></tr>
<tr><td>1</td><td>The display changed from a 2D to a 3D video mode</td></tr>
</table>
</ul>
</td></tr>
</table>
</section>

<section id="avoutput-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated, in the following manner:
<table class="dae-event-table">
<thead><tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr></thead>
<tr><td><a href="#avoutput-on3dmodechange" class="apiRef">on3DModeChange</a></td><td>3DModeChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>action</code></td></tr>
</table>
NOTE: the above DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD not rely on receiving an <code>IpAddressChange</code> event during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>application/oipfConfiguration</code> object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>

<section id="networkinterfacecollection-class">
<h3>The NetworkInterfaceCollection class</h3>
<pre>
typedef Collection&lt;<a href="#networkinterface-class" class="apiRef">NetworkInterface</a>&gt; NetworkInterfaceCollection
</pre>
The <code>NetworkInterfaceCollection</code> class represents a collection of <a href="#networkinterface-class" class="apiRef">NetworkInterface</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>

<section id="avoutputcollection-class">
<h3>The AVOutputCollection class</h3>
<pre>
typedef Collection&lt;<a href="#avoutput-class" class="apiRef">AVOutput</a>&gt; AVOutputCollection
</pre>
The <code>AVOutputCollection</code> class represents a collection of <a href="#avoutput-class" class="apiRef">AVOutput</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>

<section id="tunercollection-class">
<h3>The TunerCollection class</h3>
<pre>
typedef Collection&lt;<a href="#tuner-class" class="apiRef">Tuner</a>&gt; TunerCollection
</pre>
The <code>TunerCollection</code> class represents a collection of <a href="#tuner-class" class="apiRef">Tuner</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.</section>

<section id="tuner-class">
<h3>The Tuner class</h3>
<p>A <code>Tuner</code> object represents the source of broadcast content provided through a physical tuner in the OITF. Each <code>Tuner</code> object is represented by a <code>&lt;video_broadcast&gt;</code> element in the capability description as defined in section <a href="#tuner-broadcast-capability" class="sectionRef"></a>.</p>
<p>A <code>Tuner</code> object that is capable of tuning at the same time to multiple transponders SHALL have the <i>nrstreams</i> attribute of the <code>&lt;video_broadcast&gt;</code> element set to a value equal to the number of transponders.</p>
<p>A <code>Tuner</code> object that is capable of tuning to transponders of different types SHALL include all those types in the types attribute of the <code>&lt;video_broadcast&gt;</code> element.</p>
<p>NOTE: An OITF may contain a physical tuner that has its capabilities split into multiple <code>Tuner</code> objects to fit the restrictions on the <code>&lt;video_broadcast&gt;</code> element outlined above and in section <a href="#tuner-broadcast-capability" class="sectionRef"></a>.</p>

<section id="tuner-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>id</b></td></tr>
<tr><td>A unique identifier of the tuner.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>name</b></td></tr>
<tr><td>The name of the tuner as designated in OITF.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#integercollection-class" class="apiRef">IntegerCollection</a> <b>idTypes</b></td></tr>
<tr><td>Returns a collection of the types supported by the tuner. The types are according to the ID types in section <a href="#channel-constants" class="sectionRef"></a> under <a href="#channel-class" class="apiRef">Channel</a> object.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">Boolean <b>enableTuner</b></td></tr>
<tr><td><p>The property enables (true) and disables (false) the tuner. Reading the property provides the current state, enabled or disabled. Attempting to disable the tuner while the resource is in use has no effect and the tuner SHALL continue to be enabled. While disabled:</p><ul>
<li>any external power feed (if applicable) SHALL be turned off;
<li>the value of the <a href="#tuner-signalinfo" class="apiRef">signalInfo</a> property is not defined;
<li>the value of the <a href="#tuner-lnbinfo" class="apiRef">lnbInfo</a> property is not defined;
<li>the tuner SHALL NOT be available for use by any JavaScript object (e.g. the video/broadcast object) or by the underlying OITF system (e.g. to perform a scheduled recording). Note the property enableTuner is available in order to re-enable the tuner and get access to the tuner again.
</ul>
<p>The set value of the property SHALL persist after OITF restarts.</p></td></tr>
</table>

<table class="dae-property-table" id="tuner-signalinfo">
<tr><td class="api-signature">readonly <a href="#signalinfo-class" class="apiRef">SignalInfo</a> <b>signalInfo</b></td></tr>
<tr><td>The property returns a <a href="#signalinfo-class" class="apiRef">SignalInfo</a> object with signal information for example signal strength.</td></tr>
</table>
<table class="dae-property-table" id="tuner-lnbinfo">
<tr><td class="api-signature">readonly <a href="#signalinfo-class" class="apiRef">LNBInfo</a> <b>lnbInfo</b></td></tr>
<tr><td>The property returns a <a href="#lnbinfo-class" class="apiRef">LNBInfo</a> object with information regarding the LNB associated with the tuner.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>frontEndPosition</b></td></tr>
<tr><td>Indicates the physical interface associated with the tuner.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">Boolean <b>powerOnExternal</b></td></tr>
<tr><td><p>The property turns on (true) and off (false) the power applied to the external interface of the tuner unless the tuner is disabled. Reading the property provides the current value, on or off. Attempting to modify the property while the resource is in use has no effect. The value of the property SHALL persist after OITF restarts. </p>
<p>For DVB-S/S2 power is supplied to the LNB(s) and if present the DiSEqC switch. </p>
<p>For DVB-T/T2 a supply +5V is supplied to the antenna with built in amplifier. Note that applying power may have adverse effects to the external equipment if it has its own power supply. It is a strong recommendation to indicate to the end user a possible adverse effect before using this method.</p>
<p>For DVB-C/C2 there is no effect.</p>
<p>Reading the property provides the current value.</p></td></tr>
</table>
</section>
</section>

<section id="signalinfo-class">
<h3>The SignalInfo class</h3>
The <code>SignalInfo</code> object provides details on the signal strength of the tuner. If the tuner is not tuned to a transponder the all properties SHALL have the value <code>undefined</code>.
<section id="signalinfo-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Number <b>strength</b></td></tr>
<tr><td>Signal strength measured in dBm, for example -31.5dBm.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>quality</b></td></tr>
<tr><td>Signal quality with range from 0 to 100. Calculation of quality is a function of <a href="#signalinfo-ber" class="apiRef">ber</a> and <a href="#signalinfo-snr" class="apiRef">snr</a>. The specification remains silent as to how the calculation is made.</td></tr>
</table>
<table class="dae-property-table" id="signalinfo-ber">
<tr><td class="api-signature">readonly Integer <b>ber</b></td></tr>
<tr><td>Bit error rate.</td></tr>
</table>
<table class="dae-property-table" id="signalinfo-snr">
<tr><td class="api-signature">readonly Number <b>snr</b></td></tr>
<tr><td>Signal to noise ratio (dB), for example 22.3dB.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>lock</b></td></tr>
<tr><td><code>True</code> if the tuner is locked to a transponder.</td></tr>
</table>
</section>
</section>

<section id="lnbinfo-class">
<h3>The LNBInfo class</h3>
The <code>LNBInfo</code> object provides details on the LNB attached to a tuner. Setting any of the properties in this class results in an immediate update of the LNB configuration that is active for the associated <a href="#tuner-class" class="apiRef">Tuner</a>. The LNB configuration is stored persistently.
<section id="lnbinfo-constants">
<h4>Constants</h4>
The following constants are defined in the LNBInfo class:
<table class="dae-constant-table">
<thead><tr><th>Name</th><th>Value</th><th>Use</th></tr></thead>
<tr><td>DUAL_LO_FREQ_LNB</td><td>30</td><td>A universal LNB that has two local oscillator frequency settings available. The selection between the frequencies is done by the presence of a 22 kHz control signal.</td></tr>
<tr><td>SINGLE_LO_FREQ_LNB</td><td>31</td><td>Only a single local oscillator frequency is available in the LNB.</td></tr>
</table>
</section>

<section id="lnbinfo-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">Integer <b>lnbType</b></td></tr>
<tr><td>The type of LNB connected to the frontend. Valid values are listed in section <a href="#lnbinfo-constants" class="sectionRef"></a>.</td></tr>
</table>
<table class="dae-property-table" id="lnbinfo-lnblowfreq">
<tr><td class="api-signature">Number <b>lnbLowFreq</b></td></tr>
<tr><td>The low or only, if a single local oscillator frequency LNB is used, LNB local oscillator frequency in MHz.</td></tr>
</table>
<table class="dae-property-table" id="lnbinfo-lnbhighfreq">
<tr><td class="api-signature">Number <b>lnbHighFreq</b></td></tr>
<tr><td>If a dual local oscillator frequency LNB is used this is the high LNB local oscillator frequency in MHz. If a single local oscillator frequency LNB is used this argument shall be set to 0.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">Number <b>crossoverFrequency</b></td></tr>
<tr><td>Indicates the frequency (in MHz) when to switch between the high- and low-band oscillator frequencies (<a href="#lnbinfo-lnblowfreq" class="apiRef">lnbLowFreq</a> and <a href="#lnbinfo-lnbhighfreq" class="apiRef">lnbHighFreq</a> respectively).</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">Number <b>lnbStartFrequency</b></td></tr>
<tr><td>Indicates the lowest frequency, in MHz, that the LNB can be used for.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">Number <b>lnbStartFrequency</b></td></tr>
<tr><td>Indicates the highest frequency, in MHz, that the LNB can be used for.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">Number <b>orbitalPosition</b></td></tr>
<tr><td><p>Indicates the orbital position of the satellite in degrees, negative value for west, positive value for east. For example, Astra 19.2 East would have orbitalPosition 19.2. Thor 0.8 West would have orbitalPosition -0.8. </p>
<p>This property, if provided, will be used to select a Tuner instance (when scanning and tuning). Setting any value which is not a valid orbital position (an absolute value greater than 180) indicates that the orbital position need not be considered when using the associated tuner.</p></td></tr>
</table>
</section>
</section>

<section id="startupinformation-class">
<h3>The StartupInformation class</h3>
This class contains information pertaining to the startup characteristics and configuration of the OITF.
<section id="startupinformation-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="startupinformation-urlsource">
<tr><td class="api-signature">readonly Integer <b>urlSource</b></td></tr>
<tr><td>The mechanism used to obtain the <a href="#startupinformation-url" class="apiRef">url</a> property. Any of the STARTUP_URL_* values defined in section <a href="#localsystem-constants" class="sectionRef"></a> are valid.</td></tr>
</table>
<table class="dae-property-table" id="startupinformation-url">
<tr><td class="api-signature">readonly String <b>url</b></td></tr>
<tr><td><p>The URL used at startup of the OITF. </p>
<p>If the <a href="#startupinformation-urlsource" class="apiRef">urlSource</a> property is <a href="#localsystem-urlsource-constants" class="apiRef">STARTUP_URL_NONE</a> then the value of this property SHALL be <code>NULL</code>.</p>
<p>If the <a href="#startupinformation-urlsource" class="apiRef">urlSource</a> property is <a href="#localsystem-urlsource-constants" class="apiRef">STARTUP_URL_PRECONFIGURED</a> then the value of this property SHALL be <code>undefined</code>.</p></td></tr>
</table>
</section>
</section>
</section> <!-- configuration-and-setting-apis -->

<section id="content-download-apis">
<h2>Content Download APIs</h2>
<p>This section defines the content-on-demand download interfaces for both DRM-protected and non-DRM protected content. </p>
<p>An OITF and a DAE application which have indicated support for downloading content by providing value &ldquo;true&rdquo; for element <code>&lt;download&gt;</code> in their capability profile as specified in section <a href="#download-cod-capability" class="sectionRef"></a> SHALL adhere to the following requirements.</p>
<p>NOTE: Annex <a href="#cod-clarification" class="sectionRef"></a> clarifies the purpose and the use of these interfaces in more detail.</p>

<section id="application-oipfdownloadtrigger">
<h3>The application/oipfDownloadTrigger embedded object</h3>
<p>An OITF SHALL support a non-visual embedded object of type <code>application/oipfDownloadTrigger</code>, with the following JavaScript API to enable passing a content-access descriptor to an underlying download manager using JavaScript.</p>
<p>The functionality as described in this section is subject to the security model of section <a href="#dae-security" class="sectionRef"></a>.</p>
<section id="downloadtrigger-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="downloadtrigger-registerdownload">
<tr><td colspan="3" class="api-signature">String <b>registerDownload</b>( String contentAccessDownloadDescriptor, Date downloadStart, Integer priority )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Send <code>contentAccessDownloadDescriptor</code> to the underlying download manager as a String formatted according to the Content Access Download Descriptor XML Schema as specified in Annex <a href="#content-access-descriptor-formats" class="sectionRef"></a>. </p>
<p>Returns a <code>String</code> value representing a unique identifier to identify the download, if the <code>contentAccessDownloadDescriptor</code> is valid and is accepted for triggering a download. If the OITF supports the <a href="#application-oipfdownloadmanager" class="apiRef">application/oipfDownloadManager</a> as specified in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a>, this SHALL be the value of the &ldquo;<a href="#download-id" class="apiRef">id</a>&rdquo; attribute of the associated <a href="#download-class" class="apiRef">Download</a> object. Note that if the Content Access Download Descriptor contains multiple content items to be downloaded, the associated Download objects for each of these content items SHALL have the same value for the &ldquo;<a href="#download-id" class="apiRef">id</a>&rdquo; value. The associated Download objects can be retrieved through the method getDownloads() as defined in section <a href="#downloadmanager-methods" class="sectionRef"></a>.</p>
<p>The OITF SHALL guarantee that download identifiers are unique in relation to recording identifiers and <code>CODAsset</code>identifiers.</p>
<p>The method returns <code>undefined</code> if the <code>contentAccessDownloadDescriptor</code> is not accepted for triggering a download.</p></td>
</tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">contentAccessDownloadDescriptor</td><td>String formatted according to the Content Access Download Descriptor XML Schema as specified in Annex <a href="#content-access-descriptor-formats" class="sectionRef"></a>.</td></tr>
<tr><td class="dae-method-table-argument">downloadStart</td><td>Optional argument indicating the time at which the download should be started. If the argument is not included, or takes a value of <code>null</code> then the download should start as soon as possible.</td></tr>
<tr><td class="dae-method-table-argument">priority</td><td>Optional argument indicating the relative priority of the download with respect to other downloads registered by the same organisation as the calling application. Higher values indicate a higher priority. If the argument is not included then a priority of 0 shall be assigned.</td></tr>

</table>

<table class="dae-method-table" id="downloadtrigger-registerdownloadurl">
<tr><td colspan="3" class="api-signature">String <b>registerDownloadURL</b>( String URL, String contentType, Date downloadStart, Integer priority )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>This method triggers the OITF to initiate a download of the content pointed to by the URL and the given content type.</p>
<p>The <code>contentType</code> attribute SHALL reflect the expected type of content returned by the content server when connecting to the URL. The <code>contentType</code> can be used to evaluate if the content type is part of the list of accepted content types of the OITF. For example, if the OITF does not support content type &ldquo;<code>video/MP2T</code>&rdquo;, then the <code>registerDownloadURL</code> method could return undefined to indicate this to the application in advance of the download.</p> 
<p>If <code>contentType</code> has value &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo;, the method SHALL return a download identifier, after which the OITF SHALL immediately fetch the Content Access Download Descriptor, after which the same SHALL happen as if <a href="#downloadtrigger-registerdownload" class="apiRef">registerDownload()</a> as defined in section <a href="#using-the-registerdownload-method" class="sectionRef"></a> with the given Content Access Download Descriptor as argument was called. The downloadStart argument only applies to the individual Download objects described by the Content Access Download Descriptor and SHALL NOT apply to the retrieval of the Content Access Download Descriptor itself.</p>
<p>Note that if the Content Access Download Descriptor contains multiple content items to be downloaded, the associated <a href="#download-class" class="apiRef">Download</a> objects for each of these content items SHALL have the same value for the &ldquo;<a href="#download-id" class="apiRef">id</a>&rdquo; value. The associated <a href="#download-class" class="apiRef">Download</a> objects can be retrieved through method <a href="#downloadmanager-getdownloads" class="apiRef">getDownloads()</a> as defined in section <a href="#downloadmanager-methods" class="sectionRef"></a>.</p>
<p>Returns a String value representing a unique identifier to identify the download, if the given arguments are acceptable by the OITF to trigger a download. If the OITF supports the <a href="#application-oipfdownloadmanager" class="apiRef">application/oipfDownloadManager</a> as specified in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a>, this SHALL be the value of the &ldquo;<a href="#download-id" class="apiRef">id</a>&rdquo; attribute of the associated <a href="#download-class" class="apiRef">Download</a> object(s).<p>
<p>The OITF SHALL guarantee that download identifiers are unique in relation to recording identifiers and <code>CODAsset</code> identifiers.</p>
<p>The method returns <code>undefined</code> if the given arguments are not acceptable by the OITF to trigger a download.</p>
</td>
</tr>
<tr><td class="dae-method-table-label" rowspan="4">Arguments</td>
<td class="dae-method-table-argument">URL</td><td>The URL from which the content can be fetched. </td></tr>
<tr><td class="dae-method-table-argument">contentType</td><td>The type of content referred to by the URL attribute. The <code>contentType</code> can be used to evaluate if the content type is part of the list of supported content types of the OITF.</td></tr>
<tr><td class="dae-method-table-argument">downloadStart</td><td>Optional argument indicating the time at which the download should be started. If the argument is not included, or takes a value of <code>null</code> then the download should start as soon as possible.</td></tr>
<tr><td class="dae-method-table-argument">priority</td><td>Optional argument indicating the relative priority of the download with respect to other downloads registered by the same organisation as the calling application. Higher values indicate a higher priority. If the argument is not included then a priority of 0 shall be assigned.</td></tr>

</table>

<table class="dae-method-table" id="downloadtrigger-checkdownloadpossible">
<tr><td colspan="3" class="api-signature">Integer <b>checkDownloadPossible</b>( Integer sizeInBytes )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Checks whether a download of a given <code>sizeInBytes</code> would be possible at this moment in time. The value is application specific. For an application whose organization has a reservation, only the free space in the reservation SHALL be considered when making the check.</p>
<p>Possible return values are:</p>
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>Successful, i.e. the download could be successfully completed if it would be started at this moment in time.</td></tr>
<tr><td>1</td><td>Insufficient Storage, i.e. the download could be started, but is unlikely to complete successfully, since insufficient storage capacity is available to fully store the content to be downloaded.</td></tr>
<tr><td>2</td><td>Storage not available, i.e. the download would fail, since the storage is currently unavailable, e.g. in case of removable storage.</td></tr>
</table></td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">sizeInBytes</td><td>Integer value with the given size of the download in bytes.</td></tr>
</table>
</section>
</section>
<section id="extensions-to-application-oipfdownloadtrigger">
<h3>Extensions to application/oipfDownloadTrigger</h3>
<p>If an OITF has indicated support for both BCG metadata (i.e. by giving element <code>&lt;clientMetadata&gt;</code> value &ldquo;<code>true</code>&rdquo; and a &ldquo;<code>type</code>&rdquo; attribute with value &ldquo;<code>bcg</code>&rdquo;), and the download management APIs defined in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> (i.e. by giving attribute &ldquo;<code>manageDownloads</code>&rdquo; of the <code>&lt;download&gt;</code> element a value unequal to &ldquo;<code>none</code>&rdquo;) in the client capability description, then the following additional method SHALL be supported by the <a href="#application-oipfdownloadtrigger" class="apiRef">application/oipfDownloadTrigger</a> object defined in section <a href="#application-oipfdownloadtrigger" class="sectionRef"></a>.
<p>The functionality as described in this section is subject to the security model of section <a href="#dae-security" class="sectionRef"></a></p>.

<table class="dae-method-table" id="downloadtrigger-registerdownloadfromcrid">
<tr><td colspan="3" class="api-signature">String <b>registerDownloadFromCRID</b>( String CRID, String IMI, Date downloadStart, Integer priority )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Send <code>(CRID,IMI)</code> to underlying download manager. Returns a <code>String</code> value representing a unique identifier to identify the download if the <code>(CRID,IMI)</code> tuple is valid and is accepted for triggering a download. If the OITF supports the <a href="#application-oipfdownloadmanager" class="apiRef">application/oipfDownloadManager</a> as specified in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a>, this SHALL be the value of the &ldquo;<a href="#download-id" class="apiRef">id</a>&rdquo; attribute of the associated <a href="#download-class" class="apiRef">Download</a> object(s), which corresponds to the <code>CRID</code> in this case.</p> 
<p>The OITF SHALL guarantee that download identifiers are unique in relation to recording identifiers and <code>CODAsset</code> identifiers.</p>
<p>The method returns <code>undefined</code> if the given <code>(CRID,IMI)</code> tuple is not accepted for triggering a download.</p> 
<p>The values of the <code>name</code>, <code>description</code>, <code>parentalRating</code> and <code>DRMControl</code> properties SHALL be based on the metadata provided for the item matching that CRID.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="4">Arguments</td>
<td class="dae-method-table-argument">CRID</td><td>The TV-Anytime Content reference ID that points to the general information about the item to download that does not change regardless of how the content is published or broadcast.</td></tr>
<tr><td class="dae-method-table-argument">IMI</td><td>The TV-Anytime Instance Metadata ID that points to the specific information related to the item to download, such as content location, usage rules (pay-per-view, etc.) and delivery parameters (e.g. video format).</td></tr>
<tr><td class="dae-method-table-argument">downloadStart</td><td>Optional argument indicating the time at which the download should be started. If the argument is not included, or takes a value of <code>null</code> then the download should start as soon as possible.</td></tr>
<tr><td class="dae-method-table-argument">priority</td><td>Optional argument indicating the relative priority of the download with respect to other downloads registered by the same organisation as the calling application. Higher values indicate a higher priority. If the argument is not included then a priority of 0 shall be assigned.</td></tr>

</table>
</section>



<section id="application-oipfdownloadmanager">
<h3>The application/oipfDownloadManager embedded object</h3>
<p>In a managed deployment, privileged applications may need access to the download management functionality in a CoD system. This access may be required to implement a UI to the download manager, to queue a download or to display the progress of a specific download. OITFs SHOULD support an &ldquo;<code>application/oipfDownloadManager</code>&rdquo; object with the following interface.</p>
<p>Clients supporting the download management APIs as specified in this section SHALL indicate this by adding the attribute &ldquo;<code>manageDownloads</code>&rdquo; to the <code>&lt;download&gt;</code> element with a value unequal to &ldquo;<code>none</code>&rdquo; in the client capability description as defined in section <a href="#download-cod-capability" class="sectionRef"></a>.</p>
<p>The functionality as described in this section is subject to the security model of section <a href="#dae-security" class="sectionRef"></a>.</p>
<section id="downloadmanager-statediagram">
<h4>State diagram of the application/oipfDownloadManager object</h4>
<p>The following state machine provides an overview of the state changes that are possible in the download manager. The states reflect the changes signalled to applications via the <a href="#downloadmanager-ondownloadstatechange" class="apiRef">onDownloadStateChange</a> event handler.</p>
<figure>
<img alt="FIGURE 12" src="images/oipfDownloadManager-state-diagram.png" />
<figcaption>Figure ####: State diagram for embedded application/oipfDownloadManager objects (normative)</figcaption>
</figure>
<p>Note that newly-registered downloads may pre-empt downloads which are currently in progress, if they have a higher priority than in-progress downloads.  This may cause downloads to be paused or resumed without application intervention.</p>
</section>
<section id="downloadmanager-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="downloadmanager-ondownloadstatechange">
<tr><td class="api-signature">function <b>onDownloadStateChange</b>( <a href="#download-class" class="apiRef">Download</a> item, Integer state, Integer reason )</td></tr>
<tr><td>The function that is called when the status of a download has changed. The specified function is called with three arguments item, state and reason, which are defined as follows:<ul>
<li><code>Download item</code> &mdash; the Download object whose state has changed.
<li><code>Integer state</code> &mdash; the new state of the download. Valid values include: 
<table class="dae-api-values-table">
<thead><tr><th>Status</th><th>Semantics</th></tr>
<tr><td>1</td><td>The download has completed successfully.</td></tr>
<tr><td>2</td><td>The download is in progress.</td></tr>
<tr><td>4</td><td>The download has been paused (either by an application or automatically by the OITF).</td></tr>
<tr><td>8</td><td>The download has failed.</td></tr>
<tr><td>16</td><td>The download has been queued but has not yet started.</td></tr>
<tr><td>32</td><td>The download has stalled due to a transient failure and the Download Manager is attempting to recuperate and re-establish the download.</td></tr>
</table>
<li><code>Integer reason</code> - Extended reason code. This is only valid if the value of the state argument is 8.
<table class="dae-api-values-table">
<thead><tr><th>Reason</th><th>Semantics</th></tr>
<tr><td>0</td><td>The local storage device is full.</td></tr>
<tr><td>1</td><td>The item cannot be downloaded (e.g. because it has not been purchased).</td></tr>
<tr><td>2</td><td>The item is no longer available for download.</td></tr>
<tr><td>3</td><td>The item is invalid due to bad checksum or length.</td></tr>
<tr><td>4</td><td>Other reason.</td></tr>
</table>
If no error has occurred, this argument SHALL take the value undefined.
</ul></td></tr>
</table>

<table class="dae-property-table" id="downloadmanager-discinfo">
<tr><td class="api-signature">readonly <a href="#discinfo-class" class="apiRef">DiscInfo</a> <b>discInfo</b></td></tr>
<tr><td>Get information about the status of the local storage device. The <a href="#discinfo-class" class="apiRef">DiscInfo</a> class is defined in section <a href="#discinfo-class" class="sectionRef"></a>.</td></tr>
</table>

<table class="dae-property-table" id="downloadmanager-hasreserved">
<tr><td class="api-signature">readonly Integer <b>hasReserved</b></td></tr>
<tr><td>Returns the size (in megabytes) of any current reservation for the applications from the same organisation as the calling application otherwise -1.</td></tr>
</table>

<table class="dae-property-table" id="downloadmanager-allocated">
<tr><td class="api-signature">readonly Integer <b>allocated</b></td></tr>
<tr><td>Returns the size (in megabytes) of any current reservation for the applications from the same organisation as the calling application otherwise -1.</td></tr>
</table>
</section>
<section id="downloadmanager-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>pause</b>( <a href="#download-class" class="apiRef">Download</a> download )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Pause an in-progress, queued or stalled download and return <code>true</code>. For in-progress downloads, more data SHALL NOT be downloaded until the download is resumed. The HTTP request and TCP socket are interrupted and closed.</p>
<p>For completed or failed downloads, this operation SHALL return <code>false</code>.</p>
</td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">download</td><td>The download to be paused.</td></tr>

</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>resume</b>( <a href="#download-class" class="apiRef">Download</a> download )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Resume a paused download. If the download is not paused, this operation SHALL return <code>false</code>.</td>
</tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">download</td><td>The download to be resumed.</td></tr>

</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>remove</b>( <a href="#download-class" class="apiRef">Download</a> download )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Remove the download and any data and media content associated with it and return <code>true</code>. Return <code>false</code> if the download attribute does not refer to a valid download.</p>
<p>As a side effect of this method, all properties on download SHALL be set to undefined. Any method calls subsequently performed by an application which pass download as an argument SHALL return <code>false</code>.</p>
<p>If an A/V Control object is referring to the indicated download for playback then the state of the A/V Control object SHALL be automatically changed to state 6 (the error state).</p></td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">download</td><td>The download to be deleted.</td></tr>

</table>

<table class="dae-method-table" id="downloadmanager-getdownloads">
<tr><td colspan="3" class="api-signature"><a href="#downloadcollection-class" class="apiRef">DownloadCollection</a> <b>getDownloads</b>( String id )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Returns a collection of downloads, for which the value of the <a href="#download-id" class="apiRef">Download.id</a> property corresponds to the given <code>id</code> parameter. The downloads returned in the collection SHALL be filtered according to the value of the manageDownloads attribute of the <code>&lt;download&gt;</code> element in the OITF's capability description (i.e. from the same application, same domain or from all applications).</p>
<p>For downloads initiated from <a href="#downloadtrigger-registerdownloadurl" class="apiRef">registerDownloadURL(</a>) with a contentType value &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo; SHALL return <code>null</code> until the Content Access Download Descriptor has been retrieved and parsed.</p>
<p>If the value of <code>id</code> is <code>null</code>, it returns all downloads for the scope indicated by the <code>manageDownloads</code> attribute. </p>
</td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">id</td><td>Optional argument identifying the downloads to be retrieved. If present and not <code>null</code>, this is an identifier corresponding to the &ldquo;<a href="#download-id" class="apiRef">id</a>&rdquo; attribute of zero or more <a href="#download-class" class="apiRef">Download</a> objects. If the value of <code>id</code> is <code>null</code>, or the argument is not included, all downloads for the scope indicated by the <code>manageDownloads</code> attribute in the capability description are returned.</td></tr>

</table>

<table class="dae-method-table" id="downloadmanager-createfilteredlist">
<tr><td colspan="3" class="api-signature"><a href="#downloadcollection-class" class="apiRef">DownloadCollection</a> <b>createFilteredList</b>( Boolean currentDomain, Integer states )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Create a filtered list of downloads. Returns a subset of downloads that are managed by the receiver.</p>
<p>The <code>currentDomain</code> flag indicates whether downloads from FQDNs other than the current page are included in the returned collection. This flag MAY be set to one of three values:</p>
<table class="dae-api-left-values-table">
<thead><tr><th>Value</th><th>Meaning</th></tr></thead>
<tr><td>true</td><td><p>The download is added if and only if it was initiated from the FQDN of the calling document.</p><p>If the application has the permission <i>permission_downloadmanager</i> (see section <a href="#permission-names" class="sectionRef"></a>), only downloads initiated by the calling application shall be added.</p></td></tr>
<tr><td>false</td><td><p>The download is added if and only if it was not initiated from the FQDN of the calling document. </p> <p>If the application does not have the permission <i>permission_downloadmanager_all</i> (see section <a href="#permission-names" class="sectionRef"></a>), the OITF SHALL return an empty collection.</p></td></tr>
<tr><td>undefined</td><td><p>The download is added regardless of the domain that the download was initiated from.</p><p>If the application has the permission <i>permission_downloadmanager</i> (see section <a href="#permission-names" class="sectionRef"></a>), only downloads initiated by the calling application shall be added.</p><p>If the application has the permission <i>permission_downloadmanager_samedomain</i> (see section <a href="#permission-names" class="sectionRef"></a>), only downloads initiated by applications from the same FQDN shall be added.</p></td></tr>
</table>

<p>The <code>states</code> flag indicates which state(s) of downloads that should be included in the list. The value of this flag is the arithmetic sum of one or more possible values of the <a href="#download-state" class="apiRef">state</a> property of the <a href="#download-class" class="apiRef">Download</a> object; only downloads whose state matches one of the values included in this sum are included in the returned collection.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">currentDomain</td><td>Flag indicating whether downloads from other domains SHALL be added to the list.</td></tr>
<tr><td class="dae-method-table-argument">states</td><td>Indicates that states of downloads that should be included in the returned list.</td></tr>

</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>updateRegisteredDownload</b>( <a href="#download-class" class="apiRef">Download</a> download, String newURL )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>The method <code>updateRegisteredDownload()</code> provides a way to update the URL to be used for a download. The OITF SHALL use the new URL for any future retrieval.</p>
<p>If the download is already in progress or paused (indicated by a <a href="#download-state" class="apiRef">state</a> property value of 4), it SHALL be stopped. The download SHALL continue from the last byte received during the previous download.</p>
<p>If the <a href="#download-state" class="apiRef">state</a> property of the <code>download</code> argument has the value 8 (download failed) or 32 (download stalled) then the OITF SHALL resume the download from the last byte received during the previous download but using the new URL.</p>
<p>If the <a href="#download-state" class="apiRef">state</a> property of the <code>download</code> argument has the value 16 (download not started) no further action is taken until the download is started or resumed.</p>
<p>If the <a href="#download-state" class="apiRef">state</a> property of the <code>download</code> argument has the value 1 (download completed) then this method SHALL return <code>false</code>. Otherwise it SHALL return <code>true</code>.  
</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">download</td><td>The download object to be updated.</td></tr>
<tr><td class="dae-method-table-argument">newURL</td><td>The new URL from which the content can be retrieved.</td></tr>

</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Integer <b>reserve</b>( Integer bytes )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Requests the reservation of space for downloads to be made by applications from the same organization as the calling application. Reservation is OPTIONAL for applications to use and applications may use the Download API without reserving space in advance.</p>
<p>If there is already a reservation for the calling application's organization, this requests adjusting the reservation to the new value. If a call to reserve shrinks an already existing reservation then the application SHOULD ensure that the new size is sufficient for all the completed, in progress and requested downloads by applications from the calling application's organization. The OITF SHALL refuse to shrink the reservation if this has not been done.</p>
<p>This specification intentionally does not define the criteria that are used in deciding whether or not to make or adjust a reservation.</p>
<p>Either the OITF or the end-user MAY cancel a reservation completely, shrink one to recover some or all of the free space in the reservation or expand it. This specification intentionally does not define circumstances when this may happen. If a request to reserve space is granted to an organisation then applications from that organisation SHALL have the reserved space available to them for downloads. Attempts to use more than the reserved space SHALL fail.</p>
<p>A reservation is cancelled by calling this method with size zero.</p>
<p>Returns one of the RESERVE_ constants defined in section <a href="#downloadmanager-constants" class="sectionRef"></a> below.
</p></td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">bytes</td><td>The number of bytes to reserve.</td></tr>
</table>
</section>
<section id="downloadmanager-events">
<h4>Events</h4>
<p>For the intrinsic event &ldquo;<a href="#downloadmanager-ondownloadstatechange" class="apiRef">onDownloadStateChange</a>&rdquo;, a corresponding DOM event SHALL be generated, in the following manner:</p>
<table class="dae-event-table">
<thead><tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#downloadmanager-ondownloadstatechange" class="apiRef">onDownloadStateChange</a></td><td>DownloadStateChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>item</code>, <code>state</code>, <code>reason</code>
</table>

<p>NOTE: the above DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving a <code>DownloadStateChange</code> event during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <a href="#application-oipfdownloadmanager" class="apiRef">application/oipfDownloadManager</a> object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>
<section id="downloadmanager-constants">
<h4>Constants</h4>
<table class="dae-constant-table-novalue">
<thead><tr><th>Name</th><th>Use</th></thead>
<tr><td>RESERVE_OK</td><td>Reservation succeeded.</td></tr>
<tr><td>RESERVE_NEVER</td><td>Reservations by the calling application will never succeed.</td></tr>
<tr><td>RESERVE_USER_INTERVENTION_REQD</td><td>Reservation failed and user intervention is required. This result SHALL only be returned by OITFs that include a platform provided UI enabling end-users to manage storage. RESERVE_TOO_LARGE SHALL be returned in preference to this if both apply.</td></tr>
<tr><td>RESERVE_USER_DECLINED</td><td>Reservation failed as the user was asked to approve this request and declined.</td></tr>
<tr><td>RESERVE_TOO_LARGE</td><td>Reservation failed as the size requested was larger than what is permitted by the OITF.</td></tr>
<tr><td>RESERVE_SMALLER_THAN_USED</td><td>Request to shrink an already existing reservation failed as the requested size is smaller than the space currently used from the reservation.</td></tr>
<tr><td>RESERVE_UNKNOWN</td><td>Reservation failed for another reason.</td></tr>
</table>
</section>


</section>
<section id="download-class">
<h3>The Download class</h3>
<p>A <code>Download</code> object being made available by the <a href="#application-oipfdownloadmanager" class="apiRef">application/oipfDownloadManager</a> embedded object represents a content item that has either been downloaded from a remote server or is in the process of being downloaded.</p>
<p>If the ID of a download is a TV-Anytime CRID, then the values of the <a href="#download-name" class="apiRef">name</a>, <a href="#download-description" class="apiRef">description</a> and <a href="#download-parentalratings" class="apiRef">parentalRatings</a> properties SHALL be set by the OITF based on the metadata provided for the item matching that CRID.</p>
<p>In order to preserve backwards compatibility with already existing DAE content the JavaScript toString() method SHALL return the <a href="#download-id" class="apiRef">Download.id</a> for Download objects.</p>

<section id="download-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="download-totalsize">
<tr><td class="api-signature">readonly Integer <b>totalSize</b></td></tr>
<tr><td>The total size (in bytes) of the download.</td></tr>
</table>
<table class="dae-property-table" id="download-state">
<tr><td class="api-signature">readonly Integer <b>state</b></td></tr>
<tr><td>The current state of the download.  When this changes, a DownloadStateChange event SHALL be generated.  Valid values are:
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>1</td><td>The download has completed.</td></tr>
<tr><td>2</td><td>The download is in progress.</td></tr>
<tr><td>4</td><td>The download has been paused (either by an application or automatically by the platform).</td></tr>
<tr><td>8</td><td>The download has failed.</td></tr>
<tr><td>16</td><td>The download is queued but has not yet started.</td></tr>
<tr><td>32</td><td>The download has stalled due to a transient failure and the Download Manager is attempting to recuperate and re-establish the download.</td></tr>
</table>
<p>Note: these values are used as a bitfield in the <a href="#downloadmanager-createfilteredlist" class="apiRef">DownloadManager.createFilteredList()</a> method.</p>
</td></tr>
</table>
<table class="dae-property-table" id="download-reason">
<tr><td class="api-signature">readonly Integer <b>reason</b></td></tr>
<tr><td>The <code>reason</code> property is only valid if the value of the <a href="#download-state" class="apiRef">state</a> property is 8 (download failed).
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>The local storage device is full.</td></tr>
<tr><td>1</td><td>The item cannot be downloaded (e.g. because it has not been purchased).</td></tr>
<tr><td>2</td><td>The item is no longer available for download.</td></tr>
<tr><td>3</td><td>The item is invalid due to bad checksum or length.</td></tr>
<tr><td>4</td><td>Other reason.</td></tr>
</table>
<p>If no error has occurred, this argument SHALL take the value <code>undefined</code>.</p>
</td></tr>
</table>

<table class="dae-property-table" id="download-amountdownloaded">
<tr><td class="api-signature">readonly Integer <b>amountDownloaded</b></td></tr>
<tr><td>The amount of data that has been downloaded returned in bytes, or zero if no data has been downloaded.</td></tr>
</table>
<table class="dae-property-table" id="download-currentbitrate">
<tr><td class="api-signature">readonly Integer <b>currentBitRate</b></td></tr>
<tr><td>The bitrate (in bits per second) at which the download is currently transferred. This value is non-zero only when the <code>Download</code> object is in state 2 (in progress). If this is unknown the value of this property SHALL be <code>undefined</code>.</td></tr>
</table>

<table class="dae-property-table" id="download-name">
<tr><td class="api-signature">String <b>name</b></td></tr>
<tr><td><p>The name of the download or <code>undefined</code> if this information is not present. In case the download is triggered through a Content Access Download Descriptor, this corresponds to the value for the <code>&lt;Title&gt;</code> element in the Content Access Download Descriptor.</p>
<p>If the Content Access Download Descriptor is not specified then the property may be set by the origin site. Note that the property may only be set by the site that initiated the download. The DAE application may store data related to the Download. The OITF SHALL support a minimum of 200 bytes for the property. If DAE application attempts to store a string larger than the available size the OITF SHALL set the property to NULL. The maximum length of the property value is implementation dependent.
</p></td></tr>
</table>

<table class="dae-property-table" id="download-id">
<tr><td class="api-signature">readonly String <b>id</b></td></tr>
<tr><td>The ID of the download as determined by the OITF.</td></tr>
</table>

<table class="dae-property-table" id="download-uri">
<tr><td class="api-signature">readonly String <b>uri</b></td></tr>
<tr><td>A uri identifying the content item in local storage according to [[!RFC3986]]. The format of the URI is outside the scope of this specification except that:<ul>
<li>the scheme SHALL NOT be one that is included in this specification
<li>the URI SHALL NOT include a fragment</ul>
</td></tr>
</table>

<table class="dae-property-table" id="download-contenturl">
<tr><td class="api-signature">readonly String <b>contentURL</b></td></tr>
<tr><td>The URL the content is being fetched from, or <code>undefined</code> if this information is not available.</td></tr>
</table>

<table class="dae-property-table" id="download-description">
<tr><td class="api-signature">readonly String <b>contentURL</b></td></tr>
<tr><td><p>A description of the download  or undefined if this information is not present. In case the download is triggered through a Content Access Download Descriptor, this corresponds to the value for the <code>&lt;Synopsis&gt;</code> element in the Content Access Download Descriptor, or undefined if this element is not present.</p>
<p>If the Content Access Download Descriptor is not specified the property may be set by the origin site. Note that the property may only be set by the site that initiated the download. The DAE application may store data related to the Download. The OITF SHALL support a minimum of 2000 bytes for the property. If DAE application attempts to store a string larger than the available size the OITF SHALL set the property to NULL. The maximum length of the property value is implementation dependent.</p>
</td></tr>
</table>

<table class="dae-property-table" id="download-parentalratings">
<tr><td class="api-signature">readonly <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> <b>parentalRatings</b></td></tr>
<tr><td>The parental rating collection related  to the downloaded content item, or undefined if this information is not present. In case the download is triggered through a Content Access Download Descriptor, this corresponds to the value for the <code>&lt;ParentalRating&gt;</code> element in the Content Access Download Descriptor, or undefined if this element is not present.</td></tr>
</table>

<table class="dae-property-table" id="download-drmcontrol">
<tr><td class="api-signature">readonly <a href="#drmcontrolinfocollection-class" class="apiRef">DRMControlInfoCollection</a> <b>drmControl</b></td></tr>
<tr><td>The <a href="#drmcontrolinformation-class" class="apiRef">DRMControlInformation</a> object corresponding to the DRM Control information of the downloaded content item, or <code>undefined</code> if this information is not present. In case the download is triggered through a Content Access Download Descriptor, this corresponds to the value for the <code>&lt;DRMControlInformation&gt;</code> element associated with the same <code>DRMSystemID</code> of the selected <code>&lt;ContentURL&gt;</code>, or is undefined if this information is not present.
The related <a href="#drmcontrolinformation-class" class="apiRef">DRMControlInformation</a> object is defined in section <a href="#drmcontrolinformation-class" class="sectionRef"></a>. 
</td></tr>
</table>

<table class="dae-property-table" id="download-starttime">
<tr><td class="api-signature">readonly Date <b>startTime</b></td></tr>
<tr><td>The time that the download is scheduled to start (in the case of scheduled downloads) or <code>undefined</code> if no start time was set.</td></tr>
</table>
<table class="dae-property-table" id="download-timeelapsed">
<tr><td class="api-signature">readonly Integer <b>timeElapsed</b></td></tr>
<tr><td>The time (in seconds) that has elapsed since the download of the item was started. The elapsed time SHALL be based on the time spent in the in-progress and stalled download states. This SHALL NOT include any time the item spent queued for download.</td></tr>
</table>
<table class="dae-property-table" id="download-timeremaining">
<tr><td class="api-signature">readonly Integer <b>timeRemaining</b></td></tr>
<tr><td>The estimated time remaining (in seconds) for the download to complete. The estimated time SHALL be based on the time spent in the in-progress and stalled download states. The estimate SHALL NOT include any time the item spent queued for download or paused. If an estimate cannot be calculated, the value of this property SHALL be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="download-transfertype">
<tr><td class="api-signature">readonly String <b>transferType</b></td></tr>
<tr><td>In case the download was triggered through a Content Access Download Descriptor, this is the value of property <code>TransferType</code> of the selected <code>&lt;ContentURL&gt;</code>. In the case where the download was not triggered through a Content Access Download Descriptor, the OITF is responsible for returning either the value &ldquo;<code>playable_download</code>&rdquo; or &ldquo;<code>full_download</code>&rdquo;, based on criteria defined by the OITF.</td></tr>
</table>
<table class="dae-property-table" id="download-originsite">
<tr><td class="api-signature">readonly String <b>originsite</b></td></tr>
<tr><td>In the case where the download was triggered through a Content Access Download Descriptor, this is the value of element <code>&lt;OriginSite&gt;</code>. In case the download was not triggered through a Content Access Download Descriptor, this is the FQDN of the site that initiated the download.</td></tr>
</table>
<table class="dae-property-table" id="download-originsitename">
<tr><td class="api-signature">readonly String <b>originSiteName</b></td></tr>
<tr><td>In case the download is triggered through a Content Access Download Descriptor, this is the value of element <code>&lt;OriginSiteName&gt;</code>, or <code>undefined</code> if this information is not present. In case the download is not triggered through a Content Access Download Descriptor, this property is <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="download-contentid">
<tr><td class="api-signature">String <b>contentID</b></td></tr>
<tr><td><p>A unique identification of the content item relative to originSite.  In case the download is triggered through a Content Access Download Descriptor, and a <code>&lt;ContentID&gt;</code> element has been defined for the given content item, this is the value of element <code>&lt;ContentID&gt;</code>.  If the download is started using <a href="#downloadtrigger-registerdownloadfromcrid" class="apiRef">registerDownloadFromCRID()</a>, this is the TV Anytime CRID. This property shall take the value undefined if no content ID is available.</p>
<p>If the Content Access Download Descriptor is not specified the property may be set by the originSite. Note that the property may only be set by the site that initiated the download. The DAE application may store data related to the Download. The OITF SHALL support a minimum of 2000 bytes for the property. If DAE application attempts to store a string larger than the available size the OITF SHALL set the property to NULL. The maximum length of the property value is implementation dependent.</p></td></tr>
</table>
<table class="dae-property-table" id="download-iconurl">
<tr><td class="api-signature">String <b>iconURL</b></td></tr>
<tr><td>The URL of an image that provides a visual representation of the item that is being downloaded. In the case where the download was triggered a Content Access Download Descriptor, this is the value of element <code>&lt;IconURL&gt;</code>, or <code>undefined</code> if this element is not present.  In the case where the download was not triggered through a content access descriptor document, this property is <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="download-metadata">
<tr><td class="api-signature">readonly Document <b>metadata</b></td></tr>
<tr><td><p>For downloads registered through a Content Access Download Descriptor, this function SHALL return the contents of the Content Access Download Descriptor as an XML Document object using the syntax as defined in section <a href="#content-access-download-descriptor-format" class="sectionRef"></a> without using any namespace definitions.</p>
<p>For downloads registered using a URL, the value of this property SHALL be null.</p></td></tr>
</table>
<table class="dae-property-table" id="download-priority">
<tr><td class="api-signature">readonly Integer <b>priority</b></td></tr>
<tr><td>The relative priority of the download with respect to other downloads registered by that application.  Higher values indicate a higher priority.</td></tr>
</table>
<table class="dae-property-table" id="download-suspendedbyterminal">
<tr><td class="api-signature">readonly Integer <b>suspendedByTerminal</b></td></tr>
<tr><td>Flag indicating whether the download has been paused automatically by the OITF, either because the download has been pre-empted by higher priority downloads or because the number of simultaneous downloads supported by the OITF has been exceeded.</td></tr>
</table>
</section>
</section>

<section id="downloadcollection-class">
<h3>The DownloadCollection class</h3>
<pre>
typedef Collection&lt;<a href="#download-class" class="apiRef">Download</a>&gt; DownloadCollection
</pre>
The <code>DownloadCollection</code> class represents a collection of <a href="#download-class" class="apiRef">Download</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>

<section id="drmcontrolinformation-class">
<h3>The DRMControlInformation class</h3>
A <code>DRMControlInformation</code> object represents the DRM Control information structure defined in <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]].
<section id="drmcontrolinformation-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="drmcontrolinformation-drmtype">
<tr><td class="api-signature">readonly String <b>drmType</b></td></tr>
<tr><td>URN containing the decimal number format of the DVB CASystemID, prefixed with the string "<code>urn:dvb:casystemid:</code>". For example, the hexadecimal value 0x4AF4 is assigned as the CASystemID for Marlin by DVB, and so for Marlin the value of this property would be &ldquo;<code>urn:dvb:casystemid:19188</code>&rdquo;.</td></tr>
</table>
<table class="dae-property-table" id="drmcontrolinformation-rightsissuerurl">
<tr><td class="api-signature">readonly String <b>rightsIssuerURL</b></td></tr>
<tr><td>A URL used by OITF to obtain rights for this content item.</td></tr>
</table>
<table class="dae-property-table" id="drmcontrolinformation-silentrightsurl">
<tr><td class="api-signature">readonly String <b>silentRightsURL</b></td></tr>
<tr><td>A URL used by OITF to obtain rights silently, e.g. a Marlin Action Token.</td></tr>
</table>
<table class="dae-property-table" id="drmcontrolinformation-drmcontentid">
<tr><td class="api-signature">readonly String <b>drmContentID</b></td></tr>
<tr><td>DRM Content ID for CoD or scheduled content item, e.g. the Marlin Content ID.</td></tr>
</table>
<table class="dae-property-table" id="drmcontrolinformation-previewrightsurl">
<tr><td class="api-signature">readonly String <b>previewRightsURL</b></td></tr>
<tr><td>A URL used by OITF to obtain rights silently for preview of this content item, e.g. a Marlin Action Token.</td></tr>
</table>
<table class="dae-property-table" id="drmcontrolinformation-drmprivatedata">
<tr><td class="api-signature">readonly String <b>drmPrivateData</b></td></tr>
<tr><td>Private data for the DRM scheme indicated in drmType to be applied for this content item. Private DRM Data is actually structured as an XML document whose schema is specific to the considered DRM system. One example is Marlin DRM private data schema defined in [[.OIPF_CSP2]].</td></tr>
</table>
<table class="dae-property-table" id="drmcontrolinformation-donotrecord">
<tr><td class="api-signature">readonly Boolean <b>doNotRecord</b></td></tr>
<tr><td>A flag indicating whether this content item is recordable or not.</td></tr>
</table>
<table class="dae-property-table" id="drmcontrolinformation-donottimeshift">
<tr><td class="api-signature">readonly Boolean <b>doNotTimeShift</b></td></tr>
<tr><td>A flag indicating if this content item is allowed for time shift play back.</td></tr>
</table>
</section>
</section>

<section id="drmcontrolinfocollection-class">
<h3>The DRMControlInfoCollection class</h3>
<pre>
typedef Collection&lt;<a href="#drmcontrolinformation-class" class="apiRef">DRMControlInformation</a>&gt; DRMControlInfoCollection
</pre>
The <code>DRMControlInfoCollection</code> class represents a collection of <a href="#drmcontrolinformation-class" class="apiRef">DRMControlInformation</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>
</section>  <!-- content-download-apis -->

<section id="content-on-demand-metadata-apis">
<h2>Content On Demand Metadata APIs</h2>
This section SHALL apply for OITFs that have indicated <code>&lt;clientMetadata&gt;</code> with value &ldquo;<code>true</code>&rdquo; and a &ldquo;<code>type</code>&rdquo; attribute with value &ldquo;<code>bcg</code>&rdquo; in the capability description and MAY apply for OITFs that have indicated <code>&lt;clientMetadata&gt;</code> with value &ldquo;<code>true</code>&rdquo; and a &ldquo;<code>type</code>&rdquo; attribute with value &ldquo;<code>dvb-si</code>&rdquo;
<section id="application-oipfcodmanager">
<h3>The application/oipfCodManager embedded object</h3>
<p>OITFs that have indicated <code>&lt;clientMetadata&gt;</code> with value &ldquo;<code>true</code>&rdquo; and a &ldquo;<code>type</code>&rdquo; attribute with value &ldquo;<code>bcg</code>&rdquo; SHALL implement an &ldquo;<code>application/oipfCodManager</code>&rdquo; embedded object with the following interface.</p>
<p>Content is organised into catalogues, where each catalogue contains a hierarchy of folders that are used to organise individual content items. The structure of the catalogue SHALL be determined by the server managing that catalogue and SHALL be reflected in the structure of the metadata passed to the OITF.</p>
<p>The three types of content in a CoD catalogue are:<ul>
<li>Assets, represented by the <a href="#codasset-class" class="apiRef">CODAsset</a> class. A <a href="#codasset-class" class="apiRef">CODAsset</a> is a user-level description of a piece of CoD content, and so it is more concerned with information such as the price, rental period, description and parental rating rather than detailed technical information about the asset such as encoding format. A CoD asset MAY represent a single movie, or a bundle of movies offered for a single price.
<li>Folders, represented by the <a href="#codfolder-class" class="apiRef">CODFolder</a> class.
<li>Services represented by the <a href="#codservice-class" class="apiRef">CODService</a> class. <a href="#codservice-class" class="apiRef">CODService</a> objects are a specific type of container representing subscription VoD (SVOD) services, where users purchase a group of assets which may change over time rather than a single movie or TV show.
</ul>
<p>The <a href="#codasset-class" class="apiRef">CODAsset</a>, <a href="#codfolder-class" class="apiRef">CODFolder</a> and <a href="#codservice-class" class="apiRef">CODService</a> classes define a type property that allows these classes to be distinguished by applications.  For each class, this property SHALL take the value defined below:</p>
<span style="font-family: sans-serif;font-size: 90%;">
<table class="dae-api-left-values-table">
<thead><tr><th>Class</th><th>Value</th></tr></thead>
<tr><td style="padding: 3px 10px;"><a href="#codfolder-class" class="apiRef">CODFolder</a></td><td style="padding: 3px 10px;">0</td></tr>
<tr><td style="padding: 3px 10px;"><a href="#codasset-class" class="apiRef">CODAsset</a></td><td style="padding: 3px 10px;">1</td></tr>
<tr><td style="padding: 3px 10px;"><a href="#codservice-class" class="apiRef">CODService</a></td><td style="padding: 3px 10px;">2</td></tr>
</table>
</span>
<p>This specification defines the mapping between the CoD API and BCG metadata.  Mappings between the CoD API and other CoD metadata sources are not specified in this document.</p>
<section id="content-on-demand-metadata-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#contentcataloguecollection-class" class="apiRef">ContentCatalogueCollection</a> <b>catalogues</b></td></tr>
<tr><td>A collection of all available CoD catalogues, as listed in an SD&amp;S BCG Discovery record. </td></tr>
</table>
<table class="dae-property-table" id="content-on-demand-metadata-oncontentcatalogueevent">
<tr><td class="api-signature">function <b>onContentCatalogueEvent</b>( Integer action )</td></tr>
<tr><td>This function is the DOM 0 event handler for events relating to changes in a content catalogue collection. The specified function is called with the argument <code>action</code>:<ul>
<li><code>Integer action</code> - The type of event. For current versions of the specification, this property SHALL always have the value 0 to indicate a change in the list of available catalogues.</ul></td></tr>
</table>
<table class="dae-property-table" id="content-on-demand-metadata-oncontentaction">
<tr><td class="api-signature">function <b>onContentAction</b>( Integer action, Integer result, Object item, <a href="#contentcatalogue-class" class="apiRef">ContentCatalogue</a> catalogue )</td></tr>
<tr><td>This function is the DOM 0 event handler for events relating to actions carried out on an item in a content catalogue. The specified function is called with the following arguments:<ul>
<li><code>Integer action</code> - The type of action that the event refers to.  Valid values are:
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>An operation to browse a content collection (e.g. getting a page from the collection).</td></tr>
<tr><td>1</td><td>Indicates that more information is available about this item (e.g. that more information has been retrieved from the server).</td></tr>
</table>
<li><code>Integer result</code> - TThe result of the action.  Valid values are:
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th></tr></thead>
<tr><td>0</td><td>The operation succeeded.</td></tr>
<tr><td>1</td><td>The item no longer exists in the catalogue.</td></tr>
<tr><td>2</td><td>The server has not responded in the timeout period.</td></tr>
<tr><td>3</td><td>Communication with the server has been interrupted.</td></tr>
</table>
<li><code>Object item</code> - The item in the catalogue that the event refers to.
<li><code><a href="#contentcatalogue-class" class="apiRef">ContentCatalogue</a> catalogue</code> - The parent catalogue of the affected object.
</ul></td></tr>
</table>

</section>
<section id="content-on-demand-metadata-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<thead><tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr></thead>
<tr><td><a href="#content-on-demand-metadata-oncontentcatalogueevent" class="apiRef">onContentCatalogueEvent</a></td><td>ContentCatalogueEvent</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>action</code></td></tr>
<tr><td><a href="#content-on-demand-metadata-oncontentaction" class="apiRef">onContentAction</a></td><td>ContentAction</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>action</code>, <code>result</code>, <code>item</code>, <code>catalogue</code></td></tr>
</table>
<p>NOTE: the above DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving the events listed above during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>LocalSystem</code> object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>
</section>

<section id="contentcataloguecollection-class">
<h3>The ContentCatalogueCollection class</h3>
<pre>
typedef Collection&lt;<a href="#contentcatalogue-class" class="apiRef">ContentCatalogue</a>&gt; ContentCatalogueCollection
</pre>
The <code>ContentCatalogueCollection</code> class represents a collection of <a href="#contentcatalogue-class" class="apiRef">ContentCatalogue</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>

<section id="contentcatalogue-class">
<h3>The ContentCatalogue class</h3>
<p>A <code>ContentCatalogue</code> represents a content catalogue for a content on demand service. </p>
<p>To receive events relating to operations on items in a catalogue, applications MAY add listeners for &ldquo;<code>ContentAction</code>&rdquo; events to the <a href="#application-oipfcodmanager" class="apiRef">application/oipfCodManager</a> object.</p>
<section id="contentcatalogue-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>name</b></td></tr>
<tr><td>The name of the content catalogue that should be displayed to the user. The value of this property is given by the Name element in the catalogue's BCG discovery record.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#codfolder-class" class="apiRef">CODFolder</a> <b>rootFolder</b></td></tr>
<tr><td>The root folder of the content catalogue.</td></tr>
</table>
</section>
<section id="contentcatalogue-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="2" class="api-signature"> <a href="#codfolder-class" class="apiRef">CODFolder</a> <b>getPurchaseHistory()</b></td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Get the list of items that have been purchased from the catalogue by the current user, including currently active rentals.</p>
<p>Items in this list will be derived from children of the BCG <code>UserActionList</code> element which have an <code>ActionType</code> of <code>buy</code>. If the <code>ActionList</code> element is not present, this method SHALL return <code>null</code>.</p></td></tr>
</table>
</section>
</section>

<section>
<h3>The ContentCatalogueEvent class</h3>
This section is intentionally left empty.
</section>
<section id="codfolder-class">
<h3>The CODFolder class</h3>
<p><code>CODFolder</code> represents a folder in a CoD catalogue.  Folders may contain other folders, and an asset may be present in more than one folder.</p>
<p>Because a content list may contain a large number of items, the contents of the list are made available on demand using a paging model.  Applications MAY request the contents of the list in 'pages' of an arbitrary size.  The data SHALL be fetched from the appropriate source, and application SHALL be notified when the data is available.</p>
<p>Each folder is described by a <code>GroupInformation</code> element in the BCG Group Information Table.</p>

<section id="codfolder-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="codfolder-type">
<tr><td class="api-signature">readonly Integer <b>type</b></td></tr>
<tr><td>The type of the item, used to distinguish between the types of objects that may be contained in a folder in a CoD catalogue.  This SHALL always have the value 0 for folders.</td></tr>
</table>
<table class="dae-property-table" id="codfolder-uri">
<tr><td class="api-signature">readonly String <b>uri</b></td></tr>
<tr><td>The <code>URI</code> used to refer to the folder. The value of this property is given by the <code>GroupId</code> attribute of the <code>GroupInformation</code> element representing this folder.</td></tr>
</table>
<table class="dae-property-table" id="codfolder-name">
<tr><td class="api-signature">readonly String <b>name</b></td></tr>
<tr><td>The name of the folder. The value of this property is given by the <code>Title</code> element that is a descendant of the <code>GroupInformation</code> element representing this folder.</td></tr>
</table>
<table class="dae-property-table" id="codfolder-description">
<tr><td class="api-signature">readonly String <b>description</b></td></tr>
<tr><td>A description of the folder, for display to an end user. The value of this property is given by the <code>Synopsis</code> element that is a descendant of the <code>GroupInformation</code> element representing this folder.</td></tr>
</table>
<table class="dae-property-table" id="codfolder-thumbnailuri">
<tr><td class="api-signature">readonly String <b>thumbnailUri</b></td></tr>
<tr><td><p>The URI of an image associated with this folder.<p>
<p>For assets whose BCG description contains a <code>RelatedMaterial</code> element indicating a relationship of <code>Promotional Still Image</code>, the value of this property is given by the <code>MediaURI</code> element that is a descendant of that element.
For assets without an appropriate <code>RelatedMaterial</code> element, the value of this property SHALL be <code>undefined</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="codfolder-length">
<tr><td class="api-signature">readonly Integer <b>length</b></td></tr>
<tr><td>The number of items in the current page. If <a href="#codfolder-getpage" class="apiRef">getPage()</a> has not yet been called, the value of this property SHALL be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="codfolder-"currentpage>
<tr><td class="api-signature">readonly Integer <b>currentPage</b></td></tr>
<tr><td>The page number of the currently-available results, as specified in the last call to <a href="#codfolder-getpage" class="apiRef">getPage()</a>.  If <a href="#codfolder-getpage" class="apiRef">getPage()</a> has not yet been called, the value of this property SHALL be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="codfolder-pagesize">
<tr><td class="api-signature">readonly Integer <b>pageSize</b></td></tr>
<tr><td><p>The number of items that were requested from the content catalogue in a call to <a href="#codfolder-getpage" class="apiRef">getPage()</a>.  This MAY be different form the number of items that are available (e.g. the last page in the collection).</p>
<p>If <a href="#codfolder-getpage" class="apiRef">getPage()</a> has not yet been called, the value of this property SHALL be <code>undefined</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="codfolder-totalsize">
<tr><td class="api-signature">readonly Integer <b>totalSize</b></td></tr>
<tr><td><p>The total number of items in the folder.  This MAY be <code>undefined</code> until <a href="#codfolder-getpage" class="apiRef">getPage()</a> has been called.</p>
<p>The value of this property may be given by the <code>numOfItems</code> attribute of the <code>GroupInformation</code> element representing this folder.</p></td></tr>
</table>
</section>
<section id="codfolder-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="codfolder-item">
<tr><td colspan="3" class="api-signature">Object <b>item</b>( Integer index )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Return the item at position index in the current page, or <code>undefined</code> if no item is present at that position.  This function SHALL only return objects that are instances of <a href="#codasset-class" class="apiRef">CODAsset</a>, <a href="#codfolder-class" class="apiRef">CODFolder</a>, or <a href="#codservice-class" class="apiRef">CODService</a>.</p>
<p>Applications SHALL be able to access items in the collection using array notation instead of calling this method directly.</p></td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">index</td><td>The index into the collection.</td></tr>
</table>

<table class="dae-method-table" id="codfolder-getpage">
<tr><td colspan="3" class="api-signature">void <b>getPage</b>( Integer page, Integer pageSize )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Retrieve one page of the folder's contents.  The application SHALL be notified by an event targeted at the folder's parent content catalogue when the data is available.</p>
<p>Calls to this method SHALL cancel any outstanding requests.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">page</td><td>The number of the page for which data should be retrieved, indexed from zero.</td></tr>
<tr><td class="dae-method-table-argument">pageSize</td><td>The size of the page.</td></tr>
</table>

<table class="dae-method-table" id="codfolder-abort">
<tr><td colspan="2" class="api-signature">void <b>abort</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Abort the current request for a new page of folder contents. Any results for this folder SHALL be removed (i.e. the value of the <a href="#codfolder-length" class="apiRef">length</a> property will be 0 and any calls to the <a href="#codfolder-item" class="apiRef">item()</a> method SHALL return <code>undefined</code>)</p></td></tr>
</table>
</section>
</section>

<section id="codasset-class">
<h3>The CODAsset class</h3>
<p>The <code>CODAsset</code> represents a piece of CoD content that can be purchased and played.  A <code>CODAsset</code> object MAY refer to a bundle of content items that are purchased together but which can only be played individually.</p>
<p>Some fields of a <code>CODAsset</code> object MAY not be populated until an application requests them; in this case the data MAY be fetched asynchronously from a server.  Fields where the data has not been fetched from the server SHALL have a value of <code>undefined</code>.  Fields for which data is not available on the server SHALL have a value of <code>null</code>.</p>
<p>Note: The <code>lookupMetadata()</code> method has been removed from this class.</p>

<section id="codasset-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="codasset-type">
<tr><td class="api-signature">readonly Integer <b>type</b></td></tr>
<tr><td>The type of the item, used to distinguish between the types of objects that may be contained in a folder in a CoD catalogue.  This property SHALL always have the value 1 for CoD assets.</td></tr>
</table>
<table class="dae-property-table" id="codasset-uid">
<tr><td class="api-signature">readonly String <b>uri</b></td></tr>
<tr><td>The CRID of the asset. The value of this property is given by the <code>programId</code> attribute of the BCG ProgramInformation element that describes the asset.</td></tr>
</table>
<table class="dae-property-table" id="codasset-name">
<tr><td class="api-signature">readonly String <b>name</b></td></tr>
<tr><td>The title of the asset that will be displayed to the user.  The value of this property is given by the BCG <code>Title</code> element that is a child of the asset's <code>BasicDescription</code> element.</td></tr>
</table>
<table class="dae-property-table" id="codasset-description">
<tr><td class="api-signature">readonly String <b>description</b></td></tr>
<tr><td>A description of the asset, for display to an end user. The value of this property is given by the BCG <code>Synopsis</code> element that is a child of the asset's <code>BasicDescription</code> element.</td></tr>
</table>
<table class="dae-property-table" id="codasset-genres">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>genres</b></td></tr>
<tr><td>A collection of genres that describe this asset.  Genres are represented by the values of any <code>Name</code> elements that are children of <code>Genre</code> elements in the asset's description.</td></tr>
</table>
<table class="dae-property-table" id="codasset-parentalratings">
<tr><td class="api-signature">readonly <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> <b>parentalratings</b></td></tr>
<tr><td>A collection of genres that describe this asset.  Genres are represented by the values of any <code>Name</code> elements that are children of <code>Genre</code> elements in the asset's description.</td></tr>
</table>
<table class="dae-property-table" id="codasset-blocked">
<tr><td class="api-signature">readonly Boolean <b>blocked</b></td></tr>
<tr><td>Flag indicating whether the asset is blocked due to parental control settings (i.e. whether its parental rating value exceeds the current system threshold).</td></tr>
</table>
<table class="dae-property-table" id="codasset-locked">
<tr><td class="api-signature">readonly Boolean <b>locked</b></td></tr>
<tr><td>Flag indicating whether the current state of the parental control system prevents the asset from being viewed (e.g. a correct parental control PIN has not been entered to allow the item to be viewed).</td></tr>
</table>
<table class="dae-property-table" id="codasset-thumbnailuri">
<tr><td class="api-signature">readonly String <b>thumbnailUri</b></td></tr>
<tr><td><p>The URI of an image associated with this asset.</p>
<p>For assets whose BCG description contains a <code>RelatedMaterial</code> element indicating a relationship of <code>Promotional Still Image</code>, the value of this property is given by the <code>MediaURI</code> element that is a descendant of that element.</p>
<p>For assets without an appropriate <code>RelatedMaterial</code> element, the value of this property SHALL be <code>undefined</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="codasset-price">
<tr><td class="api-signature">readonly String <b>price</b></td></tr>
<tr><td><p>The price of the asset, in a form that can be displayed to the user.  The value of this property is the concatenation of the value of the <code>Price</code> element that is a child of a <code>PurchaseItem</code> element in the asset's description and the value of the <code>Price</code> element's currency attribute.</p>
<p>For example, a Price element of </p><pre class="xml-document">
&lt;Price currency="JPY"&gt;500&lt;/Price&gt;
</pre>would give the value <code>500 JPY</code> for this field.  Implementations MAY replace the currency code with the appropriate currency symbol (e.g. &yen; ).</td></tr>
</table>
<table class="dae-property-table" id="codasset-rentalperiod">
<tr><td class="api-signature">readonly Integer <b>rentalPeriod</b></td></tr>
<tr><td><p>The period for which the asset can be rented, in hours.</p>
<p>For assets descriptions containing a <code>Purchase</code> element with a <code>PurchaseType</code> of <code>urn:tva:metadata:cs:PurchaseTypeCS:2004:playForPeriod</code>,  the value of this property is derived from the <code>QuantityUnit</code> and <code>QuantityRange</code> elements that are children of that <code>Purchase</code> element. If a <code>Purchase</code> element with the appropriate <code>PurchaseType</code> is not present, the value of this field SHALL be <code>undefined</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="codasset-playcount">
<tr><td class="api-signature">readonly Integer <b>playCount</b></td></tr>
<tr><td><p>The number of plays allowed for this asset when it is purchased.</p>
<p>For assets descriptions containing a <code>Purchase</code> element with a <code>PurchaseType</code> of <code>urn:tva:metadata:cs:PurchaseTypeCS:2004:playCounts</code>,  the value of this property is derived from the <code>QuantityUnit</code> and <code>QuantityRange</code> elements that are children of that <code>Purchase</code> element. If a <code>Purchase</code> element with the appropriate <code>PurchaseType</code> is not present, the value of this field SHALL be <code>undefined</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="codasset-duration">
<tr><td class="api-signature">readonly Integer <b>duration</b></td></tr>
<tr><td>The duration of the asset, in seconds.  The value of this property is given by the BCG <code>Duration</code> element that is a child of the asset's <code>BasicDescription</code> element.</td></tr>
</table>
<table class="dae-property-table" id="codasset-previewuri">
<tr><td class="api-signature">readonly String <b>previewUri</b></td></tr>
<tr><td><p>The URI used to refer to a preview of the asset. </p> 
<p>For assets whose BCG description contains a <code>RelatedMaterial</code> element indicating a relationship of <code>Trailer</code> or <code>Preview</code>, the value of this property is given by the <code>MediaURI</code> element of the <code>MediaLocator</code> contained in that element.</p>
<p>For assets without an appropriate <code>RelatedMaterial</code> element, the value of this property SHALL be <code>undefined</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="codasset-bookmarks">
<tr><td class="api-signature">readonly <a href="#bookmarkcollection-class" class="apiRef">BookmarkCollection</a> <b>bookmarks</b></td></tr>
<tr><td>A collection of the bookmarks set in a recording.  If no bookmarks are set, the collection SHALL be empty.</td></tr>
</table>
</section>
<section id="codasset-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="codasset-isready">
<tr><td colspan="2" class="api-signature">Boolean <b>isReady</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Check whether sufficient information is available to make a purchase or play the asset.  Due to the asynchronous nature of CoD catalogues, not all of the information required to play or purchase a CoD asset may have been received by the OITF at any given time.  If all of the required information is available, this method SHALL return <code>true</code>.  Otherwise, this method SHALL request the missing information and return <code>false</code>.  When the information is available, the application SHALL be notified via a <code>ContentAction</code> event with the reason code 1.</p></td></tr>
</table>
</section>
</section>

<section id="codservice-class">
<h3>The CODService class</h3>
<p>The CODService class is a subclass of <a href="#codfolder-class" class="apiRef">CODFolder</a> that represents a subscription CoD service.  A subscription CoD service is similar to a folder, except that:</p><ul>
<li>The service SHALL be purchased in its entirety, rather than purchasing individual items from the service.
<li>Business rules may prevent browsing of the content within a service unless the service has already been purchased.
</ul>
<p>A CODService MAY contain a number of assets, folders and services.</p>
<p>Note: The <code>lookupMetadata()</code> method and <code>uid</code> property has been removed from this class.</p>

<section id="codservice-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="codservice-length">
<tr><td class="api-signature">readonly Integer <b>length</b></td></tr>
<tr><td>The number of items in the current page of the service.</td></tr>
</table>
<table class="dae-property-table" id="codservice-currentpage">
<tr><td class="api-signature">readonly Integer <b>currentPage</b></td></tr>
<tr><td>The page number of the currently-available results, as specified in the last call to <a href="#codservice-getpage" class="apiRef">getPage()</a>.  If <a href="#codservice-getpage" class="apiRef">getPage()</a> has not yet been called, the value of this property SHALL be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="codservice-pagesize">
<tr><td class="api-signature">readonly Integer <b>pageSize</b></td></tr>
<tr><td><p>The number of items that were requested from the content catalogue in a call to <a href="#codservice-getpage" class="apiRef">getPage()</a>.  This MAY be different from the number of items that are available (e.g. the last page in the collection). </p>
<p>If <a href="#codservice-getpage" class="apiRef">getPage()</a> has not yet been called, the value of this property SHALL be <code>undefined</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="codservice-totalsize">
<tr><td class="api-signature">readonly Integer <b>totalSize</b></td></tr>
<tr><td><p>The total number of items in the service. This MAY be undefined until <a href="#codservice-getpage" class="apiRef">getPage()</a> has been called.</p>
<p>The value of this property may be given by the <code>numOfItems</code> attribute of the <code>GroupInformation</code> element representing this folder.</p></td></tr>
</table>
<table class="dae-property-table" id="codservice-type">
<tr><td class="api-signature">readonly Integer <b>type</b></td></tr>
<tr><td>The type of the item, used to distinguish between the types of objects that may be contained in a folder in a CoD catalogue.  This property SHALL always have the value 2 for a CoD service.</td></tr>
</table>
<table class="dae-property-table" id="codservice-uri">
<tr><td class="api-signature">readonly String <b>uri</b></td></tr>
<tr><td>The URI used to refer to the service.  The value of this property is given by the BCG <code>ServiceURL</code> element that is a child of the <code>ServiceInformation</code> element that describes the service.</td></tr>
</table>
<table class="dae-property-table" id="codservice-name">
<tr><td class="api-signature">readonly String <b>name</b></td></tr>
<tr><td>The name of the service that will be displayed to the user. The value of this property is given by the BCG <code>Name</code> element that is a child of the <code>ServiceInformation</code> element that describes the service.</td></tr>
</table>
<table class="dae-property-table" id="codservice-description">
<tr><td class="api-signature">readonly String <b>description</b></td></tr>
<tr><td>A description of the service, for display to an end user. The value of this property is given by the BCG <code>ServiceDescritpion</code> element that is a child of the <code>ServiceInformation</code> element that describes the service.</td></tr>
</table>
<table class="dae-property-table" id="codservice-thumbnailuri">
<tr><td class="api-signature">readonly String <b>thumbnailUri</b></td></tr>
<tr><td><p>The URI of an image associated with this service.  The value of this property is derived from the value of the first Logo element that is a child of the BCG <code>ServiceInformation</code> element describing the service.  If this element specifies anything other than the URL of an image, the value of this property SHALL be <code>undefined</code>.</p>
<p>Alternatively, for services whose BCG description contains a <code>RelatedMaterial</code> element indicating a relationship of <code>Promotional Still Image</code>, the value of this property is given by the <code>MediaURI</code> element of the <code>MediaLocator</code> contained in that element.</p>
<p>For assets without an appropriate <code>RelatedMaterial</code> or <code>Logo</code> element, the value of this property shall be <code>undefined</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="codservice-previewuri">
<tr><td class="api-signature">readonly String <b>previewUri</b></td></tr>
<tr><td><p>The URI used to refer to a preview of the content.</p>
<p>For services whose BCG description contains a <code>RelatedMaterial</code> element indicating a relationship of <code>Trailer</code> or <code>Preview</code>, the value of this property is given by the <code>MediaURI</code> element of the <code>MediaLocator</code> contained in that element.</p>
<p>For assets without an appropriate <code>RelatedMaterial</code> element, the value of this property shall be <code>undefined</code>.</p></td></tr>
</table>
</section>
<section id="codservice-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="codservice-isready">
<tr><td colspan="2" class="api-signature">Boolean <b>isReady</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Check whether sufficient information is available to make a purchase.  Due to the asynchronous nature of CoD catalogues, not all of the information required to play or purchase a CoD service may have been received by the OITF at any given time.  If all of the required information is available, this method SHALL return <code>true</code>.  Otherwise, this method SHALL request the missing information and return <code>false</code>.  When the information is available, the application SHALL be notified via a <code>ContentAction</code> event with the action code 1.</p></td></tr>
</table>
<table class="dae-method-table" id="codservice-item">
<tr><td colspan="3" class="api-signature">Object <b>item</b>( Integer index )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Return the item at position index in the current page, or <code>undefined</code> if no item is present at that position.  This function SHALL only return objects that are instances of <a href="#codasset-class" class="apiRef">CODAsset</a>, <a href="#codfolder-class" class="apiRef">CODFolder</a>, or <a href="#codservice-class" class="apiRef">CODService</a>.</p>
<p>Applications SHALL be able to access items in the collection using array notation instead of calling this method directly.</p></td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">index</td><td>The index into the collection.</td></tr>
</table>
<table class="dae-method-table" id="codservice-getpage">
<tr><td colspan="3" class="api-signature">void <b>getPage</b>( Integer page, Integer pageSize )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Retrieve one page of the services contents.  The application SHALL be notified by an event targeted at the services parent content catalogue when the data is available.</p>
<p>Calls to this method SHALL cancel any outstanding requests.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">page</td><td>The number of the page for which data should be retrieved, indexed from zero.</td></tr>
<tr><td class="dae-method-table-argument">pageSize</td><td>The size of the page.</td></tr>
</table>

<table class="dae-method-table" id="codservice-abort">
<tr><td colspan="2" class="api-signature">void <b>abort</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Abort the current request for a new page of folder contents. Any results for this folder SHALL be removed (i.e. the value of the <a href="#codservice-length" class="apiRef">length</a> property will be 0 and any calls to the <a href="#codservice-item" class="apiRef">item()</a> method SHALL return <code>undefined</code>)</p></td></tr>
</table>
</section>
</section>

</section>  <!-- content-on-demand-metadata-apis -->

<section id="content-service-protection-api">
<h2>Content Service Protection API</h2>
<p>The following requirements SHALL apply to OITF and/or server devices which have indicated support for DRM protection by providing one or more <code>&lt;drm&gt;</code> elements as specified in section <a href="#drm-capability-indication" class="sectionRef"></a>:</p>
<section id="application-oipfdrmagent">
<h3>The application/oipfDrmAgent embedded object</h3>
<p>An OITF SHALL support a non-visual embedded object of type &ldquo;<code>application/oipfDrmAgent</code>&rdquo;, with the following JavaScript API, to enable in-session message exchange from the web page with an underlying DRM agent.</p>
<p>Access to the functionality of the <code>application/oipfDrmAgent</code> embedded object SHALL adhere to the security requirements as defined in section <a href="#application-service-security" class="sectionRef"></a>.</p>
<p>Note: Annex <a href="#cod-clarification" class="sectionRef"></a> provides a clarification to the browser interaction model when dealing with protected content.</p>
<section id="application-oipfdrmagent-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="oipfdrmagent-ondrmmessageresult">
<tr><td class="api-signature">function <b>onDRMMessageResult</b>( String msgID, String resultMsg, Integer resultCode )
</td></tr>
<tr><td><p>The function that is called when the underlying DRM agent has a result message to report to the current HTML document as a consequence of a call to <a href="#oipfdrmagent-senddrmmessage" class="apiRef">sendDRMMessage</a>. The specified function is called with three arguments <code>msgID</code>, <code>resultMsg</code> and <code>resultCode</code> which are defined as follows: </p><ul>
<li><code>String msgID</code> &mdash; identifies the original message which has led to this resulting message.
<li><code>String resultMsg</code> &mdash; DRM system specific result message.
<li><code>Integer resultCode</code> &mdash; result code. Valid values include: 
<table class="dae-api-values-table">
<thead><tr><th>Result message</th><th>Description</th><th>Semantics</th></tr></thead>
<tr><td>0</td><td>Successful</td><td>The action(s) requested by <a href="#oipfdrmagent-senddrmmessage" class="apiRef">sendDRMMessage()</a> completed successfully.</td></tr>
<tr><td>1</td><td>Unknown error </td><td><a href="#oipfdrmagent-senddrmmessage" class="apiRef">sendDRMMessage()</a> failed because an unspecified error occurred.</td></tr>
<tr><td>2</td><td>Cannot process request</td><td><a href="#oipfdrmagent-senddrmmessage" class="apiRef">sendDRMMessage()</a> failed because the DRM agent was unable to complete the request.</td></tr>
<tr><td>3</td><td>Unknown MIME type</td><td><a href="#oipfdrmagent-senddrmmessage" class="apiRef">sendDRMMessage()</a> failed, because the specified Mime Type is unknown for the specified DRM system indicated in the DRMSystemId.</td></tr>
<tr><td>4</td><td>User consent needed</td><td><a href="#oipfdrmagent-senddrmmessage" class="apiRef">sendDRMMessage()</a> failed because user consent is needed for that action.</td></tr>
<tr><td>5</td><td>Unknown DRM system</td><td><a href="#oipfdrmagent-senddrmmessage" class="apiRef">sendDRMMessage()</a> failed, because the specified DRM System in DRMSystemId is unknown.</td></tr>
<tr><td>6</td><td>Wrong format</td><td><a href="#oipfdrmagent-senddrmmessage" class="apiRef">sendDRMMessage()</a> failed, because the message in msg has the wrong format.</td></tr>
</table>
</ul></td></tr>
</table>
<table class="dae-property-table" id="oipfdrmagent-ondrmsystemstatuschange">
<tr><td class="api-signature">function <b>onDRMSystemStatusChange</b>( String DRMSystemID )
</td></tr>
<tr><td><p>The function that is called when the status of a DRM system changes.</p>
<p>The specified function is called with one argument <code>DRMSystemID</code> which is defined as follows:</p><ul>
<li><code>String DRMSystemID</code> &mdash; argument that specifies the DRM System ID of the DRM system that generated the event as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drmcontrolinformationtype" class="extRef">Table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. 
</ul></td></tr>
</table>
<table class="dae-property-table" id="oipfdrmagent-ondrmsystemmessage">
<tr><td class="api-signature">function <b>onDRMSystemMessage</b>( String msg, String DRMSystemID )
</td></tr>
<tr><td><p>The function that is called when the underlying DRM system has a message to report to the current HTML document.</p>
<p>The specified function is called with two arguments, <code>msg</code> and <code>DRMSystemID</code>, which are defined as follows:</p><ul>
<li><code>String msg</code> &mdash; DRM system specific message. 
<li><code>String DRMSystemID</code> &mdash; argument that specifies the DRM System ID of the DRM system that generated the event as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. 
</ul></td></tr>
</table>
</section>
<section id="application-oipfdrmagent-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="oipfdrmagent-senddrmmessage">
<tr><td colspan="3" class="api-signature">String <b>sendDRMMessage</b>( String msgType, String msg, String DRMSystemID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Send message to the DRM agent, using a message type as defined by the DRM system. Returns a unique ID to identify the message, to be passed as the 'msgID' argument for the callback function registered through <a href="#oipfdrmagent-ondrmmessageresult" class="apiRef">onDRMMessageResult</a>. This is an asynchronous method. Applications will be notified of the results of the operation via events dispatched to <a href="#oipfdrmagent-ondrmmessageresult" class="apiRef">onDRMMessageResult</a> and corresponding DOM events.</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">msgType</td><td><p>A globally unique message type as defined by the DRM system, for example:</p><pre>
 application/vnd.marlin.drm.actiontoken+xml 
</pre><p>(i.e. MIME type of Marlin Action Token).</p>
<p>Valid values for the msgType parameter include  the MIME types described in <a href="volume7.html#drm-messages-used-in-dae" class="extRef">Annex C</a> of [[.OIPF_CSP2]].</p></td></tr>
<tr><td class="dae-method-table-argument">msg</td><td><p>The message to be provided to the underlying DRM agent formatted according to the message type as indicated by attribute <code>msgType</code>.</p><p>
Valid format for the <code>msg</code> parameter are message formats described in <a href="volume7.html#drm-messages-used-in-dae" class="extRef">Annex C</a> of [[.OIPF_CSP2]]. </p></td></tr>
<tr><td class="dae-method-table-argument">DRMSystemID</td><td><p>DRMSystemID as defined by element DRMSystemID in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For example, for Marlin, the DRMSystemID value is &ldquo;<code>urn:dvb:casystemid:19188</code>&rdquo;.</p>
<p>In the case that parameter <code>msgType</code> indicates a CSPG-CI+ message as described in <a href="volume7.html#mapping-messages-to-dae-api-or-events" class="extRef">section 4.2.3.4.1.1.2</a> of [[.OIPF_CSP2]] or an embedded CSPG message (see <a href="volume7.html#embedded-cspg" class="extRef">Annex F</a> of [[.OIPF_CSP2]]), the <code>DRMSystemID</code> parameter SHALL be specified. Otherwise, the value may be <code>null</code>.</p></td></tr>
</table>

<table class="dae-method-table" id="oipfdrmagent-drmsystemstatus">
<tr><td colspan="3" class="api-signature">Integer <b>DRMSystemStatus</b>( String DRMSystemID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Returns the status of the indicated DRM system, as defined below:
<table class="dae-api-values-table">
<thead><tr><th>Value</th><th>Description</th><th>Semantics</th></tr></thead>
<tr><td>0</td><td>READY</td><td>The DRM system is fully initialised and ready.</td></tr>
<tr><td>1</td><td>UNKNOWN</td><td>Unknown DRM system.</td></tr>
<tr><td>2</td><td>INITIALISING</td><td>The DRM system is initialising and not ready to start communicating with the application.</td></tr>
<tr><td>3</td><td>ERROR</td><td>There is a problem with the DRM system. It may be possible to communicate with it to obtain more information.</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">DRMSystemID</td><td>The DRM System ID of the DRM system that is being queried as defined by the element <code>DRMSystemID</code> in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For example, for Marlin, the DRMSystemID value is &ldquo;<code>urn:dvb:casystemid:19188</code>&rdquo;.</td></tr>
</table>

<table class="dae-method-table" id="oipfdrmagent-canplaycontent">
<tr><td colspan="3" class="api-signature">Boolean <b>canPlayContent</b>( String DRMPrivateData, String DRMSystemID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Checks the local availability of a valid license for playing a protected content item. </p>
<p>The function returns true if there is a valid license available locally that may allow playing the content. For example the actual playing may be blocked due to other constraints (e.g. video/audio output restrictions on selected output).</p>
<p>The DRMPrivateData may be retrieved by the application via a means out of scope of this specification (e.g. retrieved from Service Platform, or from a manifest file). For already downloaded content, the private data may be retrieved via the <a href="#getdrmprivatedata" class="apiRef">getDRMPrivateData()</a> method of the <a href="#download-class" class="apiRef">Download</a> class. In case the download is triggered through a Content Access Download Descriptor, the private data may be retrieved from the <a href="#download-drmcontrol" class="apiRef">drmControl</a> property.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">DRMPrivateData</td><td>DRM proprietary private data.</td></tr>
<tr><td class="dae-method-table-argument">DRMSystemID</td><td>DRMSystemID as defined by the element <code>DRMSystemID</code> in  <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For example, for Marlin, the DRMSystemID value is &ldquo;<code>urn:dvb:casystemid:19188</code>&rdquo;.</td></tr>
</table>

<table class="dae-method-table" id="oipfdrmagent-canrecordcontent">
<tr><td colspan="3" class="api-signature">Boolean <b>canRecordContent</b>( String DRMPrivateData, String DRMSystemID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Checks the local availability of a valid license for recording a protected content item.</p> 
<p>The function returns true if there is a valid license available locally that may allow recording the content. </p>
<p>The DRMPrivateData may be retrieved by the application via a means out of scope of this specification (e.g. retrieved from Service Platform, or from a manifest file).</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">DRMPrivateData</td><td>DRM proprietary private data.</td></tr>
<tr><td class="dae-method-table-argument">DRMSystemID</td><td>DRMSystemID as defined by the element <code>DRMSystemID</code> in  <a href="volume3.html#drmcontrolinformation-type" class="extRef">table9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For example, for Marlin, the DRMSystemID value is &ldquo;<code>urn:dvb:casystemid:19188</code>&rdquo;.</td></tr>
</table>
</section>
<section id="application-oipfdrmagent-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<thead><tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr></thead>
<tr><td><a href="#oipfdrmagent-ondrmmessageresult" class="apiRef">onDRMMessageResult</a></td><td>DRMMessageResult</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>msgID</code>, <code>resultMsg</code>, <code>resultCode</code>
</td></tr>
<tr><td><a href="#oipfdrmagent-ondrmsystemstatuschange" class="apiRef">onDRMSystemStatusChange</a></td><td>DRMSystemStatusChange</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>DRMSystemID</code>
</td></tr>
<tr><td><a href="#oipfdrmagent-ondrmsystemmessage" class="apiRef">onDRMSystemMessage</a></td><td>DRMSystemMessage</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>msg</code>, <code>DRMSystemID</code>
</td></tr>
</table>
NOTE: the above DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving  these events during the bubbling or the capturing phase. The <code>addEventListener()</code> method SHOULD be called on the <a href="#application-oipfdrmagent" class="apiRef">application/oipfDrmAgent</a> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>
</section> <!-- content-service-protection-api -->

<section id="gateway-discovery-and-control-apis">
<h2>Gateway Discovery and Control APIs</h2>
<p>The <code>application/oipfGatewayInfo</code> object SHALL provide the information of the gateway and subsequently interact with the gateway (e.g. IMS Gateway, Application Gateway, CSPG-CI+ Gateway and CSPG-DTCP Gateway) as defined in section <a href="#gateway-discovery-and-control" class="sectionRef"></a>. The OITF SHALL support the gateway discovery and control though the use of the following non-visual embedded object:</p><pre>
&lt;object id="gatewayinfo" type="application/oipfGatewayInfo"&gt;
</pre>
<p>Access to the functionality of the <code>application/oipfGatewayInfo</code> embedded object is privileged and SHALL adhere to the security requirements defined in section <a href="#application-service-security" class="sectionRef"></a>.</p>
<section id="application-oipfgatewayinfo">
<h3>The application/oipfGatewayInfo embedded object</h3>
<section id="oipfgatewayinfo-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>isIGDiscovered</b></td></tr>
<tr><td><p>Readonly property that indicates whether an IMS Gateway is discovered or not.</p>
<p>NOTE: This property was formerly referred to as <b><code>IGDiscovery</code></b>.</p></td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>isAGDiscovered</b></td></tr>
<tr><td><p>Readonly property that indicates whether an Application Gateway is discovered or not.</p>
<p>NOTE: This property was formerly referred to as <b><code>AGDiscovery</code></b>.</p></td></tr>
</table>
<table class="dae-property-table" id="iscspgciplusdiscovered">
<tr><td class="api-signature">readonly Boolean <b>isCSPGCIPlusDiscovered</b></td></tr>
<tr><td><p>Readonly property that indicates whether a CSPG-CI+ Gateway is discovered or not.</p>
<p>NOTE: This property was formerly referred to as <b><code>cspGatewayDiscovery</code></b>. The former <b><code>cspGatewayDiscovery</code></b> property is now replaced with <b><code>isCSPGCIPlusDiscovered</code></b> for CSPG-CI+ case and <b><a href="#iscspgdtcpdiscovered" class="apiRef">isCSPGDTCPDiscovered</a></b> for CSPG-DTCP case.</p></td></tr>
</table>
<table class="dae-property-table" id="iscspgdtcpdiscovered">
<tr><td class="api-signature">readonly Boolean <b>isCSPGDTCPDiscovered</b></td></tr>
<tr><td><p>Readonly property that indicates whether a CSPG-DRCP Gateway is discovered or not.</p>
<p>NOTE: This property was formerly referred to as <b><code>cspGatewayDiscovery</code></b>. The former <b><code>cspGatewayDiscovery</code></b> property is now replaced with <b><a href="#iscspgciplusdiscovered" class="apiRef">isCSPGCIPlusDiscovered</a></b> for CSPG-CI+ case and <b><code>isCSPGDTCPDiscovered</code></b> for CSPG-DTCP case.</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>igURL</b></td></tr>
<tr><td>Readonly property that indicates the base Gateway's URL for interacting between an OITF and an IMS Gateway.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>agURL</b></td></tr>
<tr><td>Readonly property that indicates the base Gateway's URL for interacting between an OITF and an Application Gateway.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>cspgDTCPURL</b></td></tr>
<tr><td><p>Readonly property that indicates the base Gateway's URL for interacting between an OITF and an CSPG-DTCP Gateway.</p>
<p>NOTE: This property was formerly referred to as <b><code>cspGatewayURL</code></b> which was relevant for CSPG-DTCP case only.</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">Integer <b>interval</b></td></tr>
<tr><td>Read-write property that specifies the periodic interval time(seconds) to discover the gateways. When the interval property is set, an UPnP Discovery mechanism is executed.</td></tr>
</table>

<table class="dae-property-table" id="ondiscoverig">
<tr><td class="api-signature">function <b>onDiscoverIG</b>( )</td></tr>
<tr><td><p>The function that SHALL be called when an IMS Gateway is discovered or lost by the OITF which uses a UPnP Discovery mechanism described in [[.OIPF_PROT2]] <a href="volume4.html#s10-1-1-1" class="extRef">section 10.1.1.1</a>. The actual status of the gateway (discovered or not) can be determined by reading the isIGDiscovered property.</p>
<p>The specified function is called with no arguments.</p></td></tr>
</table>
<table class="dae-property-table" id="ondiscoverag">
<tr><td class="api-signature">function <b>onDiscoverAG</b>( )</td></tr>
<tr><td><p>The function that SHALL be called when an Application Gateway is discovered or lost by the OITF which uses a UPnP Discovery mechanism described in [[.OIPF_PROT2]] <a href="volume4.html#s10-1-1-2" class="extRef">section 10.1.1.2</a>. The actual status of the gateway (discovered or not) can be determined by reading the isIGDiscovered property.</p>
<p>The specified function is called with no arguments.</p></td></tr>
</table>
<table class="dae-property-table" id="ondiscovercspgdtcp">
<tr><td class="api-signature">function <b>onDiscoverCSPGDTCP</b>( )</td></tr>
<tr><td><p>The function that SHALL be called when an CSPG-DTCP Gateway is discovered or lost by the OITF. The CSPG-DTCP gateway SHALL be discovered using a UPnP Discovery mechanism described in [[.OIPF_PROT2]] <a href="volume4.html#s10-1-1-3" class="extRef">section 10.1.1.3</a>. The actual status of the gateway (discovered or not) can be determined by reading the <a href="#iscspgdtcpdiscovered" class="apiRef">isCSPGDTCPDiscovered</a> property.</p>
<p>The specified function is called with no arguments.</p>
<p>NOTE: This property was formerly referred to as <b><code>onDiscoverCSPG</code></b>. The former <b><code>onDiscoverCSPG</code></b> property is now replaced with <b><a href="#ondiscovercspgciplus" class="apiRef">onDiscoverCSPGCIPlus</a></b> for CSPG-CI+ case and <b><code>onDiscoverCSPGDTCP</code></b> for CSPG-DTCP case.
</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>isIGSupported</b></td></tr>
<tr><td>Readonly property that indicates whether an IMS Gateway is supported or not.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>isAGSupported</b></td></tr>
<tr><td>Readonly property that indicates whether an Application Gateway is supported or not.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>isCSPGCIPlusSupported</b></td></tr>
<tr><td>Readonly property that indicates whether a CSPG-CI+ Gateway is supported or not.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>isCSPGDTCPSupported</b></td></tr>
<tr><td>Readonly property that indicates whether a CSPG-DTCP Gateway is supported or not.</td></tr>
</table>

<table class="dae-property-table" id="ondiscovercspgciplus">
<tr><td class="api-signature">function <b>onDiscoverCSPGCIPlus</b>( )</td></tr>
<tr><td><p>The function that SHALL be called when a CSPG-CI+ Gateway is discovered or lost by the OITF  (including any change to the DRM systems supported by that gateway). The CSPG-CI+ Gateway SHALL be discovered as defined in [[.OIPF_CSP2]]. The actual status of the gateway (discovered or not) can be determined by reading the <a href="#iscspgciplusdiscovered" class="apiRef">isCSPGCIPlusDiscovered</a> property.</p>
<p>The specified function is called with no arguments.</p>
<p>NOTE: This property was formerly referred to as <b><code>onDiscoverCSPG</code></b>. The former <b><code>onDiscoverCSPG</code></b> property is now replaced with <b><code>onDiscoverCSPGCIPlus</code></b> for CSPG-CI+ case and <b><a href="#ondiscovercspgdtcp" class="apiRef">onDiscoverCSPGDTCP</a></b> for CSPG-DTCP case.</p></td></tr>
</table>

<table class="dae-property-table">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>CSPGCIPlusDRMType</b></td></tr>
<tr><td>Readonly property that indicates the list of CA Systems supported by the CSPG-CI+ Gateway under the form of URN with the DVB CASystemID (16 bit number) in there. Each element of <code>CSPGCIPlusDRMType</code> shall be signalled by prefixing the decimal number format of CA_System_ID with "<code>urn:dvb:casystemid:</code>".</td></tr>
</table>
</section>
<section id="oipfgatewayinfo-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>isIGSupportedMethod</b>( String methodName )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Shall return <code>true</code> when the IG supports the method specified in the '<code>methodName</code>' argument. If the function returns <code>false</code>, it indicates that IG does not support the specified method.</p></td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">methodName</td><td>The name of the method to be checked for support.</td></tr>
</table>
</section>
<section id="oipfgatewayinfo-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated, in the following manner:
<table class="dae-event-table">
<thead><tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr></thead>
<tr><td><a href="#ondiscoverig" class="apiRef">onDiscoverIG</a></td><td>DiscoverIG</td><td>Bubbles: No<br />Cancellable: No </td></tr>
<tr><td><a href="#ondiscoverag" class="apiRef">onDiscoverAG</a></td><td>DiscoverAG</td><td>Bubbles: No<br />Cancellable: No </td></tr>
<tr><td><a href="#ondiscovercspgdtcp" class="apiRef">onDiscoverCSPGDTCP</a></td><td>DiscoverCSPGDTCP</td><td>Bubbles: No<br />Cancellable: No </td></tr>
<tr><td><a href="#ondiscovercspgciplus" class="apiRef">onDiscoverCSPGCIPlus</a></td><td>DiscoverCSPGCIPlus</td><td>Bubbles: No<br />Cancellable: No </td></tr>
</table>
NOTE: the above DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>application/oipfGatewayInfo</code> object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>
</section>

<section id="communication-services-apis">
<h2>Communication Services APIs</h2>
<p>If an OITF has indicated support for the control of its Communication Services functionality by a server by stating <code>&lt;communicationServices&gt;true&lt;/communicationServices&gt;</code> as defined in section <a href="#communication-services-api-support" class="sectionRef"></a> in its capability description, the OITF SHALL support communication services through the use of the following non-visual object:</p><pre>
&lt;object type="application/oipfCommunicationServices"/&gt;
</pre>
<p>The Communication Services API provides the necessary JavaScript methods to register new users. It also provides methods to register users (<a href="#registeruser" class="apiRef">registerUser</a>), along with the supported feature tags. A method <a href="#getregisteredusers" class="apiRef">getRegisteredUsers</a> is also defined to view all the registered users. A method <a href="#getallusers" class="apiRef">getAllUsers</a> retrieves all users provisioned in the IG. Once registered it is possible to switch users for using communication services by using method <a href="#setuser" class="apiRef">setUser</a>.</p>
<p>A property is defined to view the current user to be used for a service (<a href="#currentuser" class="apiRef">currentUser</a>). </p>
<p>In order to handle the out-of-session communication services notifications, namely, the new dialogues, there is a method for subscribing to these events (<a href="#subscribenotification" class="apiRef">subscribeNotification</a>). All new dialogues are communicated through a callback function (<a href="#onnotification" class="apiRef">onNotification</a>) to the application instance performing the subscription. </p>
<p>The Communication Services APIs apply only to privileged applications and SHALL adhere to the security model as defined in section <a href="#dae-security" class="sectionRef"></a>.</p>
<section id="application-oipfcommunicationservices">
<h3>The application/oipfCommunicationServices embedded object</h3>
<section id="oipfcommunicationservices-constants">
<h4>Constants</h4>
<table class="dae-constant-table">
<thead><tr><th>Name</th><th>Value</th><th>Use</th></tr></thead>
<tr><td>STATE_REGISTERED</td><td>0</td><td><p>Specifies that the user has been successfully registered (not subscribed to registration event).</p><p>This also represents the state when the registration event subscription has been terminated for some reason by network.</p></td></tr>
<tr><td>STATE_REGISTERED_SUBSCRIPTION_PENDING</td><td>1</td><td>Indicates that user is registered successfully but the subscription-state for the registration event indicates a status of "pending".</td></tr>
<tr><td>STATE_REGISTERED_SUBSCRIPTION_ACTIVE </td><td>2</td><td>Specifies that the user has been successfully registered and subscribed to registration event (i.e. subscription-state for registration event indicates a status of "active").</td></tr>
<tr><td>STATE_DEREGISTERED</td><td>3</td><td>Specifies that the user has been successfully deregistered. This can be result of network initiated/locally initiated deregistration request.</td></tr>
<tr><td>STATE_FAILURE</td><td>4</td><td>Represents a failure condition.</td></tr>
</table>
</section>
<section id="oipfcommunicationservices-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="onnotification">
<tr><td class="api-signature">function <b>onNotification</b>( String responseHeaders, String msgText, Document msgXML )</td></tr>
<tr><td><p>This function is called on the application which called <a href="#subscribenotification" class="apiRef">subscribeNotification</a> when an unsolicited notification arrives. The application will be notified of all notifications corresponding to any of the subscribed-to feature tags regardless of which application subscribed to it.</p>
<p>The specified function is called with 3 arguments.</p><ul>
<li><code>String responseHeaders</code> &mdash; The concatenated list of all HTTP headers, as a single string, with each header line separated by a U+000D (CR) U+000A (LF) pair excluding the status line. In absence of HNI-IGI interface, the responseHeaders will be a concatenated list all SIP headers, as a single string, with each header line separated by a U+000D (CR) U+000A (LF) pair excluding the status line.
<li><code>String msgText</code> - the response entity body as a string, as defined in the XMLHttpRequest specification as referenced in [[.OIPF_WSTVP2]].
<li><code>Document msgXML</code> &mdash; the response entity body as a Document, as defined in the XMLHttpRequest specification as referenced in [[.OIPF_WSTVP2]].
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="onnotificationresult">
<tr><td class="api-signature">function <b>onNotificationResult</b>( Integer resultMsg )</td></tr>
<tr><td><p>This function is called with return result from the <a href="#subscribenotification" class="apiRef">subscribeNotification</a> method.</p>
<p>This function is not invoked in the case when there is no re-registration as part of <a href="#subscribenotification" class="apiRef">subscribeNotification</a>.</p>
<p>The specified function is called with a single argument &mdash; <code>resultMsg</code>.</p><ul>
<li><code>Integer resultMsg</code> &mdash; result message from performing <a href="#subscribenotification" class="apiRef">subscribeNotification</a> method.
<table class="dae-api-values-table">
<tr><th>Result message</th><th>Description</th><th>Semantics</th></tr>
<tr><td>0</td><td>Successful</td><td>The action performed by the underlying functionality was successful.</td></tr>
<tr><td>1</td><td>Unknown error</td><td>The action performed by the underlying functionality failed because an unspecified error occurred.</td></tr>
<tr><td>2</td><td>Wrong user credentials</td><td>The user credentials was not accepted by the server.</td></tr>
<tr><td>3</td><td>The user doesn't exist</td><td>The user id doesn't exist in the local user table.</td></tr>
</table>
</ul></td></tr>
</table>

<table class="dae-property-table" id="onregistrationcontextupdate">
<tr><td class="api-signature">function <b>onRegistrationContextUpdate</b>( String user, Integer state, Integer errorCode )
</td></tr>
<tr><td><p>This function is called with return result from the methods <a href="#registeruser" class="apiRef">registerUser</a> and <a href="#deregisteruser" class="apiRef">deRegisterUser</a>. In addition, the function is also called whenever there is an update to the registration status of specified user.</p>
<p>The specified function is called with 3 arguments &mdash; <code>user</code>, <code>state</code> and <code>errorCode</code>.</p><ul>
<li><code>String user</code> &mdash; The IMPU of the user.
<li><code>Integer state</code> &mdash; The current state of the registration as indicated using the constant values defined in section <a href="#oipfcommunicationservices-constants" class="sectionRef"></a>.
<li><code>Integer errorCode</code> &mdash; In case of STATE_FAILED state, provides more information on reason for failure.
<table class="dae-api-values-table">
<tr><th>errorCode</th><th>Description</th><th>Semantics</th></tr>
<tr><td>1</td><td>Unknown error</td><td>The action performed by the underlying functionality failed because an unspecified error occurred.</td></tr>
<tr><td>2</td><td>Wrong user credentials</td><td>The user credentials were not accepted by the server. The DAE may request from the user a new PIN which can then be used to perform a new registerUser with the provided PIN.</td></tr>
<tr><td>3</td><td>The user doesn't exist</td><td>The user id doesn't exist in the local user table.</td></tr>
</table>
</ul></td></tr>
</table>

<table class="dae-property-table" id="currentuser">
<tr><td class="api-signature">readonly <a href="#userdata-class" class="apiRef">UserData</a> <b>currentUser</b></td></tr>
<tr><td>The current user property represents the public user identity  which is being used or shall be used for HNI-IGI communication. If not set then the default user shall be used or indicated. It shall be set to the default user if a user has not been explicitly set using the <a href="#setuser" class="apiRef">setUser()</a> method.</td></tr>
</table>
</section>
<section id="oipfcommunicationservices-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="getregisteredusers">
<tr><td colspan="2" class="api-signature"><a href="#userdatacollection-class" class="apiRef">UserDataCollection</a> <b>getRegisteredUsers</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Return all the users that are currently registered with the IG.</td></tr>
</table>

<table class="dae-method-table" id="registeruser">
<tr><td colspan="3" class="api-signature">void <b>registerUser</b>( String userId, String pin )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>This method performs user registration to the network.</p>
<p>Results from this method is sent to the callback method <a href="#onregistrationcontextupdate" class="apiRef">onRegistrationContextUpdate</a>.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">userId</td><td>The user identifier represents the public user identity or IMPU.</td></tr>
<tr><td class="dae-method-table-argument">pin</td><td><p>The pin is optional and carries the password to be used towards the IG in case of HTTP Digest over HNI-IGI interface or SIP Digest if there is no HNI-IGI. If pin is not specified then the default user password shall be used.</p>
<p>The pin used for digest authentication is limited to the HNI-IGI interface with the IG and SHALL NOT impact the HTTP Digest requests from within the DAE application. Support for this parameter is not applicable for non-native HNI-IGI.</p></td></tr>
</table>

<table class="dae-method-table" id="deregisteruser">
<tr><td colspan="3" class="api-signature">void <b>deRegisterUser</b>( String userId )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>The indicated user is de-registered. Any sessions that may be open are closed. De-registration of default user has no effect nor de-registration of any users registered from a native application in the OITF.</p>
<p>Results from this method is sent to the callback method <a href="#onregistrationcontextupdate" class="apiRef">onRegistrationContextUpdate</a>.</p>
</td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">userId</td><td>The user identifier represents the public user identity or IMPU.</td></tr>
</table>

<table class="dae-method-table" id="getallusers">
<tr><td colspan="2" class="api-signature"><a href="#userdatacollection-class" class="apiRef">UserDataCollection</a> <b>getAllUsers</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Return all the users that are currently provisioned in the IG. The first entry in the collection is the default user. The users are retrieved according to [[.OIPF_PROT2]] <a href="volume4.html#s5-4-6-4" class="extRef">section 5.4.6.4</a></td></tr>
</table>

<table class="dae-method-table" id="setuser">
<tr><td colspan="3" class="api-signature">void <b>setUser</b>( String userId )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>When invoked, any ongoing sessions for the current user shall be closed.</p>
<p>If setUser is unsuccessful due to user not being registered, it is necessary to first register the user and wait for a successful response to the <a href="#onregistrationcontextupdate" class="apiRef">onRegistrationContextUpdate</a> callback function.</p>
<p>If the user gets deregistered (either by the local application or by the network), any ongoing sessions for the user shall be closed. The default user shall be automatically assumed for all services until overridden again by the setUser method.</p>
</td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">userId</td><td>The user identifier represents the public user identity or IMPU.</td></tr>
</table>

<table class="dae-method-table" id="subscribenotification">
<tr><td colspan="3" class="api-signature">void <b>subscribeNotification</b>( <a href="#featuretagcollection-class" class="apiRef">FeatureTagCollection</a> featureTagCollection, Boolean performUserRegistration )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>This method subscribes for new IMS out-of-session dialogues for the indicated application for the currently active user. The notification shall be notified using <a href="#onnotification" class="apiRef">onNotification</a> callback method.</p>
<p>If the application that made the subscription closes then there is an automatic un-subscription to new notifications. Otherwise it is possible to perform <a href="#unsubscribenotification" class="apiRef">unsubscribeNotification</a>.
Any new dialogues shall be notified over the callback method <a href="#onnotification" class="apiRef">onNotification</a>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">featureTagCollection</td><td>The featureTagCollection object of the DAE application. If the value of this argument is NULL then all dialogs SHALL be reported.</td></tr>
<tr><td class="dae-method-table-argument">performUserRegistration</td><td><p>If this is <code>true</code> a new user registration is required. SHOULD be set to <code>false</code> if it is know that other applications will be registered shortly.</p>
<p>This parameter is ignored in the case when the filtering of notifications is done locally. In this case, the initial registration for active user will include all feature tags.</p></td></tr>
</table>

<table class="dae-method-table" id="unsubscribenotification">
<tr><td colspan="2" class="api-signature">void <b>unsubscribeNotification</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>The DAE application calling this method will be de-registered for notifications. Associated feature tag(s) for the DAE application are removed from the  featureTagCollection object for the user. A re-registration will be performed for the corresponding user if notifications are not locally filtered.</p>
<p>Results from this method is sent to the callback method <a href="#onnotificationresult" class="apiRef">onNotificationResult</a>.</p>
</td></tr>
</table>

</section>
<section id="oipfcommunicationservices-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated, in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#onnotificationresult" class="apiRef">onNotificationResult</a></td><td>NotificationResult</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>resultMsg</code></td></tr>
<tr><td><a href="#onnotification" class="apiRef">onNotification</a></td><td>Notification</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>callId</code>, <code>contact</code>, <code>from</code>, <code>to</code></td></tr>
<tr><td><a href="#onregistrationcontextupdate" class="apiRef">onRegistrationContextUpdate</a></td><td>RegistrationContextUpdate</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>user</code>, <code>state</code>, <code>errorCode</code> </td></tr>
</table>
Note: these DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <a href="#application-oipfcommunicationservices" class="apiRef">application/oipfCommunicationServices</a> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>

<section id="application-oipfcommunicationservices-presence">
<h3>Extensions to application/oipfCommunicationServices for presence and messaging services</h3>
<p>If a client has indicated support for the control of its presence and messaging functionality by a server by stating <code>&lt;presenceMessaging&gt;true&lt;/presenceMessaging&gt;</code> as defined in section <a href="#communication-services-api-support" class="sectionRef"></a> in its capability description, the client SHALL support Communication Services through the use of the following non-visual embedded object:</p><pre>
&lt;object type="application/oipfCommunicationServices"/&gt;
</pre>
<p>The presence and messaging API provides for instant messaging, presence and contact list services. The messages can either be in a chat session using MSRP (see [[.OIPF_PROT2]]) or page mode messages sent without a session. The support of presence and messaging SHALL follow the OMA specification [[!PRES]], [[!IM]].</p>
<p>The Communication Services API SHALL be supported in combined OITF and IG deployment cases. It MAY be supported in other deployment cases. The use of the HNI-IGI interface is OPTIONAL between the OITF and IG when these are co-deployed.</p>
<section id="oipfcommunicationservices-presence-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="onincomingmessage">
<tr><td class="api-signature">function <b>onIncomingMessage</b>( String fromURI, String msg, Integer cid )</td></tr>
<tr><td><p>The function that is called when an incoming chat message is received for the active user.</p>
<p>The specified function is called with 3 arguments:</p><ul>
<li><code>String fromURI</code> &mdash; The sender address of the message.
<li><code>String msg</code> &mdash; The text message sent by the remote peer.
<li><code>Integer cid</code> &mdash; Chat session identifier, either the same as one received from the <a href="#openchatsession" class="apiRef">openChatSession()</a> method or new if session is started by remote peer. Empty identifier if message is sent without a session.
</ul></td></tr>
</table>

<table class="dae-property-table" id="oncontactstatuschange">
<tr><td class="api-signature">function <b>onContactStatusChange</b>( String remoteURI, Integer state )</td></tr>
<tr><td><p>This function is called when status has changed for a contact in the contact list or a user used with the method <a href="#subscribetostatus" class="apiRef">subscribeToStatus()</a>.</p>
<p>The specified function is called with 2 arguments:</p><ul>
<li><code>String remoteURI</code> - The user address for which the status has changed.
<li><code>Integer state</code> &mdash; Set to 1 if the user is present, and 0 if not. Other values may be defined in the future.
</ul></td></tr>
</table>

<table class="dae-property-table" id="onnewwatcher">
<tr><td class="api-signature">function <b>onNewWatcher</b>( String remoteURI )</td></tr>
<tr><td><p>This function is called when a remote URI is requesting watcher authorization of the local user's presentity.</p>
<p>The specified function is called with one argument:</p><ul>
<li><code>String remoteURI</code> - The remote user address which requested watcher authorization.
</ul></td></tr>
</table>
</section>
<section id="oipfcommunicationservices-presence-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="openchatsession">
<tr><td colspan="3" class="api-signature">Integer <b>openChatSession</b>( String toURI )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Opens a chat session with a remote user.</p>
<p>Returns an integer identifier for the chat session to be used when a message is sent in the chat session or to match when incoming message is received.</p>
</td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">toURI</td><td>The address of the remote chat user.</td></tr>
</table>

<table class="dae-method-table" id="sendmessageinsession">
<tr><td colspan="3" class="api-signature">void <b>sendMessageInSession</b>( Integer cid, String msg )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Sends a new text message in a chat session. The chat can either be started by the user by calling the method <a href="#openchatsession" class="apiRef">openChatSession()</a> or can be a session received in the <a href="#onincomingmessage" class="apiRef">onIncomingMessage</a> callback function.</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>The chat session identifier.</td></tr>
<tr><td class="dae-method-table-argument">msg</td><td>Text message to send.</td></tr>
</table>

<table class="dae-method-table" id="closechatsession">
<tr><td colspan="3" class="api-signature">void <b>closeChatSession</b>( Integer cid )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Closes a chat session. </td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>The chat session identifier.</td></tr>
</table>

<table class="dae-method-table" id="sendmessage">
<tr><td colspan="3" class="api-signature">void <b>sendMessage</b>( String toURI, String msg )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Sends a new text message to a remote peer without starting a session.</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">toURI</td><td>The address of the remote chat user.</td></tr>
<tr><td class="dae-method-table-argument">msg</td><td>Text message to send.</td></tr>
</table>

<table class="dae-method-table" id="setstatus">
<tr><td colspan="3" class="api-signature">void <b>setStatus</b>( Integer state )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Sets the presence state of the local user.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">state</td><td>Set to 1 if the user is present, and 0 if not. Other values may be defined in the future.</td></tr>
</table>

<table class="dae-method-table" id="subscribetostatus">
<tr><td colspan="3" class="api-signature">void <b>subscribeToStatus</b>( String remoteURI )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Subscribe to status for a remote user.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">remoteURI</td><td>The address of the remote user.</td></tr>
</table>

<table class="dae-method-table" id="getcontacts-all">
<tr><td colspan="2" class="api-signature"><a href="#contactcollection-class" class="apiRef">ContactCollection</a> <b>getContacts</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Get the users contact list. </td></tr>
</table>

<table class="dae-method-table" id="allowcontact">
<tr><td colspan="3" class="api-signature">void <b>allowContact</b>( String remoteURI )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Allows the watcher authorization to subscribe to the local user's presentity. </td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">remoteURI</td><td>The address of the remote user.</td></tr>
</table>

<table class="dae-method-table" id="blockcontact">
<tr><td colspan="3" class="api-signature">void <b>blockContact</b>( String remoteURI )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Blocks the watcher authorization to subscribe to the local user's presentity. </td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">remoteURI</td><td>The address of the remote user.</td></tr>
</table>

<table class="dae-method-table" id="createcontactlist">
<tr><td colspan="3" class="api-signature">void <b>createContactList</b>( String contactListUri, <a href="#contactcollection-class" class="apiRef">ContactCollection</a> contacts )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Creates a contact list.</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">contactListUri</td><td>The public user identity or IMPU of the contact list.</td></tr>
<tr><td class="dae-method-table-argument">contacts</td><td>The collection of contact objects representing the members of the list.</td></tr>
</table>

<table class="dae-method-table" id="getcontacts">
<tr><td colspan="3" class="api-signature"><a href="#contactcollection-class" class="apiRef">ContactCollection</a> <b>getContacts</b>( String contactListUri )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Get the users in the specified contact list.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">contactListUri</td><td>The public user identity or IMPU of the contact list.</td></tr>
</table>

<table class="dae-method-table" id="addtocontactlist">
<tr><td colspan="3" class="api-signature">Boolean <b>addToContactList</b>( String contactListUri, <a href="#contact-class" class="apiRef">Contact</a> member )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Updates the specified contact list by adding a new member to that list.</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">contactListUri</td><td>The public user identity or IMPU of the contact list to be updated.</td></tr>
<tr><td class="dae-method-table-argument">member</td><td>The new contact to be added to the list.</td></tr>
</table>

<table class="dae-method-table" id="removefromcontactlist">
<tr><td colspan="3" class="api-signature">Boolean <b>removeFromoContactList</b>( String contactListUri, <a href="#contact-class" class="apiRef">Contact</a> member )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Updates the specified contact list by removing specified member from that list.</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">contactListUri</td><td>The public user identity or IMPU of the contact list to be updated.</td></tr>
<tr><td class="dae-method-table-argument">member</td><td>The new contact to be removed from the list.</td></tr>
</table>

<table class="dae-method-table" id="deletecontactlist">
<tr><td colspan="3" class="api-signature">Boolean <b>deleteContactList</b>( String contactListUri )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Deletes the specified contact list.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">contactListUri</td><td>The public user identity or IMPU of the contact list to be deleted.</td></tr>
</table>

<table class="dae-method-table" id="allowallcontacts">
<tr><td colspan="3" class="api-signature">void <b>allowAllContacts</b>( String domain )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Allows all watchers belonging to specified domain authorization to subscribe to local user's presentity. If <code>null</code>, then all contacts will be allowed.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">domain</td><td>Watchers belonging to this domain are authorized to subscribe. If <code>null</code>, then all watchers are authorized to subscribe irrespective of domain.</td></tr>
</table>

<table class="dae-method-table" id="blockallcontacts">
<tr><td colspan="3" class="api-signature">void <b>blockAllContacts</b>( String domain )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Blocks all watchers belonging to specified domain authorization to subscribe to local user's presentity. If <code>null</code>, then all contacts will be blocked.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">domain</td><td>Watchers belonging to this domain are denied authorization to subscribe. If <code>null</code>, then all watchers are blocked from subscribing irrespective of domain.</td></tr>
</table>
</section>

<section id="oipfcommunicationservices-presence-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#onincomingmessage" class="apiRef">onIncomingMessage</a></td><td>IncomingMessage</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>fromURI</code>, <code>msg</code>, <code>cid</code></td></tr>
<tr><td><a href="#oncontactstatuschange" class="apiRef">onContactStatusChange</a></td><td>ContactStatusChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>remoteURI</code>, <code>present</code></td></tr>
<tr><td><a href="#onnewwatcher" class="apiRef">onNewWatcher</a></td><td>NewWatcher</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>remoteURI</code></td></tr>
</table>
<p>Note: these DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <a href="#application-oipfcommunicationservices" class="apiRef">application/oipfCommunicationServices</a> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>
</section>

<section id="userdata-class">
<h3>The UserData class</h3>
<section id="userdata-properties">
<h4>Properties</h4>
<table class="dae-property-table" >
<tr><td class="api-signature">readonly String <b>userId</b></td></tr>
<tr><td>The user identifier represents the public user identity or IMPU.</td></tr>
</table>
<table class="dae-property-table" >
<tr><td class="api-signature">readonly <a href="#featuretagcollection-class" class="apiRef">FeatureTagCollection</a> <b>featureTags</b></td></tr>
<tr><td>The feature tag data is optional. It carries a collection of feature tag objects associated with an application. For example the feature tag may be an ICSI or IARI or a feature tag identifying the service for. an incoming instant messages. The object includes feature tags related to both DAE and native applications in OITF.</td></tr>
</table>
<table class="dae-property-table" >
<tr><td class="api-signature">readonly String <b>friendlyName</b></td></tr>
<tr><td>The friendly name for the user. Used as display name in outgoing messages.</td></tr>
</table>
</section>
</section>
<section id="userdatacollection-class">
<h3>The UserDataCollection class</h3>
<pre>
typedef Collection&lt;<a href="#userdata-class" class="apiRef">UserData</a>&gt; UserDataCollection
</pre>
The <code>UserDataCollection</code> class represents a collection of <a href="#userdata-class" class="apiRef">UserData</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>
<section id="featuretag-class">
<h3>The FeatureTag class</h3>
<section id="featuretag-properties">
<h4>Properties</h4>
<table class="dae-property-table" >
<tr><td class="api-signature">readonly String <b>featureTag</b></td></tr>
<tr><td><p>A string containing a featureTag value associated to an application. The featureTag value may have a value of null when used with the <a href="#subscribenotification" class="apiRef">subscribeNotification()</a> method on the <a href="#application-oipfcommunicationservices" class="apiRef">application/oipfCommunicationServices</a> object. This indicates that all dialogues are reported.</p>
<p>The feature tag SHALL populate the X-OITF- headers as specified in [[!TISPAN]] section 5.6.2, [[!IM]], [[!3GPPTS24.229]], [[!RFC3840]] and [[!RFC3841]].</p></td></tr>
</table>
</section>
</section>
<section id="featuretagcollection-class">
<h3>The FeatureTagCollection class</h3>
<pre>
typedef Collection&lt;<a href="#featuretag-class" class="apiRef">FeatureTag</a>&gt; FeatureTagCollection
</pre>
The <code>FeatureTagCollection</code> class represents a collection of <a href="#featuretag-class" class="apiRef">FeatureTag</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>

<section id="contact-class">
<h3>The Contact class</h3>
<section id="contact-properties">
<h4>Properties</h4>
<table class="dae-property-table" >
<tr><td class="api-signature">String <b>contactId</b></td></tr>
<tr><td>The contact identifier represents the public user identity or IMPU used in communication with the contact.</td></tr>
</table>
<table class="dae-property-table" >
<tr><td class="api-signature">String <b>friendlyName</b></td></tr>
<tr><td>The friendly name for the user. Used as display name in outgoing messages.</td></tr>
</table>
</section>
</section>
<section id="contactcollection-class">
<h3>The ContactCollection class</h3>
<pre>
typedef Collection&lt;<a href="#contact-class" class="apiRef">Contact</a>&gt; ContactCollection
</pre>
<p>The ContactCollection class represents a collection of Contact objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.</p>
<p>In addition to the methods and properties defined for generic collections, the ContactCollection class supports the additional methods defined below.</p>
<section id="contactcollection-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>remove</b>( String contactId )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Removes the contact represented by <code>contactId</code> from the users contact list.</p><p>Returns <code>true</code> on success.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">contactId</td><td>Contact identifier of the user in the contact list.</td></tr>
</table>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>add</b>( <a href="#contact-class" class="apiRef">Contact</a> contact )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Adds the contact represented by the <a href="#contact-class" class="apiRef">Contact</a> object to the users contact list.</p><p>Returns <code>true</code> on success.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">contact</td><td>Contact object to be added from users contact list.</td></tr>
</table>
</section>
</section>

<section id="application-oipfcommunicationservices-voicetel">
<h3>Extensions to application/oipfCommunicationServices for voice telephony services</h3>
<p>If an  OITF has indicated support for full-duplex Voice Telephony Services functionality by a server by stating <code>&lt;telephony_services&gt;true&lt;/telephony_services&gt;</code>, or 
<code>&lt;telephony_services video=&ldquo;false&rdquo;&gt;true&lt;/telephony_services&gt;</code>, or 
<code>&lt;telephony_services video=&ldquo;true&rdquo;&gt;true&lt;/telephony_services&gt;</code> 
as defined in section <a href="#communication-services-api-support" class="sectionRef"></a> in its capability description, the OITF SHALL support IMS through the use of the following non-visual embedded object: </p><pre>
&lt;object type="application/oipfCommunicationServices"/&gt;
</pre>
<p>The full-duplex Voice Telephony Services API provides support for managing the setup and life-cycle of a telephony call session. It also provides the methods to manage the capture devices and the list of preferred codecs to be used.</p>
<p>The full-duplex Voice Telephony Services API MAY be supported in the combined OITF and IG deployment cases as well as the separated OITF and IG case. It MAY be supported in other deployment cases. The use of the HNI-IGI interface is OPTIONAL between the OITF and IG when these are co-deployed.</p>
<section id="oipfcommunicationservices-voicetel-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="oipfcommunicationservices-oncallevent">
<tr><td class="api-signature">function <b>onCallEvent</b>( Integer eventType, Integer cid, Integer status, String info )</td></tr>
<tr><td>The function that is called when an event related to the identified call is notified.
The specified function is called with four arguments:<ul>
<li><code>Integer eventType</code> &mdash; the type of event. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>EVENT_INCOMING_CALL: an incoming call is received for the active user</td></tr>
<tr><td>1</td><td>EVENT_CALL_PROGRESS: called when the outgoing call is in progress (the request has been received by the remote peer and the local signalling engine is waiting for an answer).</td></tr>
<tr><td>2</td><td>EVENT_CALL_RESULT: notifies the result of an outgoing call.</td></tr>
<tr><td>3</td><td>EVENT_HANGUP: called when the remote peer hang-up the call.</td></tr>
<tr><td>4</td><td>EVENT_SESSION_START: the call session is established and running (media streams can be transmitted and rendered).</td></tr>
<tr><td>5</td><td>EVENT_SESSION_END: the call session ended and the related resources are released.</td></tr>
<tr><td>6</td><td>EVENT_INCOMING_UPDATE: an incoming update request is received for the active user. (*)</td></tr>
<tr><td>7</td><td>EVENT_UPDATE_RESULT: notifies the result of an outgoing update request. (*)</td></tr>
<tr><td>8</td><td>EVENT_SESSION_UPDATE: the update of the identified call session is active (e.g.: additional media streams can be transmitted and rendered). (*)</td></tr>
<tr><td>9</td><td>EVENT_ERROR: notifies an error event raised during the identified call session.</td></tr>
</table>
(*) Values not supported for voice only telephony services
<li><code>Integer cid</code> &mdash; call session identifier for the application (Call ID). Call IDs are unique, locally generated positive integer values used to identify a call session.
<li><code>Integer status</code> &mdash; status information on the event. The content depends on the event
<li><code>String info</code> &mdash; text field with additional information. The content depends on the event.
</ul>
<p>The values of the cid, status and info parameters are defined according to the type of event. Any parameters which are unused for an event SHALL have the value undefined.</p>
<p>EVENT_INCOMING_CALL</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
<li><code>status</code>: call type Identifier. Valid Call Type values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>AUDIO_ONLY: full-duplex voice only call</td></tr>
<tr><td>1</td><td>VIDEO_ONLY: full-duplex video only call (*)</td></tr>
<tr><td>2</td><td>AUDIO_VIDEO: full-duplex video call (voice + video) (*)</td></tr>
</table>
(*) Values not supported for voice only telephony services
<li><code>info</code>: originating URI. The sender address of the call.
</ul>
<p>EVENT_CALL_PROGRESS</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
<li><code>status</code>: The type of notification coming from the call in progress. This release provides support for a single value; extensions may be defined in future versions.
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>RINGING</td></tr>
</table>
</ul>
<p>EVENT_CALL_RESULT</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
<li><code>status</code>: the result of an outgoing call. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>ACCEPT: the call request has been accepted by the remote peer</td></tr>
<tr><td>1</td><td>REFUSE: the call request has been refused by the remote peer</td></tr>
<tr><td>2</td><td>TIMEOUT: the call request has been refused due to no response by the remote peer</td></tr>
<tr><td>3</td><td>BUSY: the remote peer is currently busy</td></tr>
<tr><td>4</td><td>ABORT: a general error occurred</td></tr>
</table>
<li><code>info</code>: if status is equal to 0 (ACCEPT), then the info parameter contains the string representing the value of call type Identifier resulting from the negotiation between the peers. Valid Call Type values are shown in the table below:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>AUDIO_ONLY: full-duplex voice only call</td></tr>
<tr><td>1</td><td>VIDEO_ONLY: full-duplex video only call (*)</td></tr>
<tr><td>2</td><td>AUDIO_VIDEO: full-duplex video call (voice + video) (*)</td></tr>
</table>
(*) Values not supported for voice only telephony services
</ul>
<p>EVENT_HANGUP</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
</ul>
<p>EVENT_SESSION_START</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
</ul>
<p>EVENT_SESSION_END</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
</ul>
<p>EVENT_SESSION_INCOMING</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
<li><code>status</code>: call type Identifier. Valid Call Type values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>AUDIO_ONLY: full-duplex voice only call</td></tr>
<tr><td>1</td><td>VIDEO_ONLY: full-duplex video only call</td></tr>
<tr><td>2</td><td>AUDIO_VIDEO: full-duplex video call (voice + video)</td></tr>
</table>
</ul>
<p>EVENT_UPDATE_RESULT</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
<li><code>status</code>: the result of an outgoing call. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>ACCEPT: the call request has been accepted by the remote peer</td></tr>
<tr><td>1</td><td>REFUSE: the call request has been refused by the remote peer</td></tr>
<tr><td>2</td><td>TIMEOUT: the call request has been refused due to no response by the remote peer</td></tr>
<tr><td>3</td><td>ABORT: a general error occurred</td></tr>
</table>
</ul>
<p>EVENT_SESSION_UPDATE</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
</ul>
<p>EVENT_ERROR</p><ul>
<li><code>cid</code>: call session identifier for the application (Call ID).
<li><code>status</code>: the error code of the referenced call. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>ERROR_MEDIA: A media subsystem error</td></tr>
<tr><td>1</td><td>ERROR_SIGNALING: A signaling subsystem error</td></tr>
</table>
<li><code>info</code>: supplementary textual information for the error identified by the status parameter.
</ul>
</td></tr>
</table>
<table class="dae-property-table" id="oipfcommunicationservices-callparameters">
<tr><td class="api-signature">readonly StringCollection <b>callParameters</b></td></tr>
<tr><td>The list of call parameters supported.</td></tr>
</table>
</section>
<section id="oipfcommunicationservices-voicetel-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="oipfcommunicationservices-call">
<tr><td colspan="3" class="api-signature">Integer <b>call</b>( String toURI, Integer callType )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Opens a telephony session with a remote user. Returns a unique, locally generated, positive integer identifier for the call session (call session ID). Returns <code>null</code> if an error occurred. The current specification provides support for a single active call session only.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">toURI</td><td>The address of the remote user.</td></tr>
<tr><td class="dae-method-table-argument">callType</td><td>Valid Call Type values are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>AUDIO_ONLY: activate a full-duplex voice only call</td></tr>
<tr><td>1</td><td>VIDEO_ONLY: activate a video only call (*)</td></tr>
<tr><td>2</td><td>AUDIO_VIDEO: activate a full-duplex video call (*)</td></tr>
</table>
(*) Parameters and values not supported for voice only telephony services
</td></tr>
</table>
<table class="dae-method-table" id="oipfcommunicationservices-answer">
<tr><td colspan="3" class="api-signature">Integer <b>answer</b>( Integer cid, Integer response )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Answers an incoming call. Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>Call session identifier for the application (Call ID).</td></tr>
<tr><td class="dae-method-table-argument">response</td><td>Valid response values are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>ANSWER_ACCEPT: Accepts the incoming call</td></tr>
<tr><td>1</td><td>ANSWER_REFUSE: Refuses the incoming call</td></tr>
<tr><td>2</td><td>ANSWER_TIMEOUT: Refuses the incoming call due to no answer from user</td></tr>
<tr><td>3</td><td>ANSWER_BUSY: Refuses the incoming call sending a busy</td></tr>
</table>
</td></tr>
</table>
<table class="dae-method-table" id="oipfcommunicationservices-hangup">
<tr><td colspan="3" class="api-signature">Integer <b>hangup</b>( Integer cid )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Closes a telephony session. Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>Call session identifier for the application (Call ID).</td></tr>
</table>
<table class="dae-method-table" id="oipfcommunicationservices-getdevicelist">
<tr><td colspan="3" class="api-signature"><a href="#deviceinfocollection-class" class="apiRef">DeviceInfoCollection</a> <b>getDeviceList</b>( Integer deviceType )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Returns the list of devices installed on the terminal (or connected) for a specific device type. The device in the first position of the returned list is the default device to be used by the terminal. The position of each device is consistent between method invocations as long as no new devices are connected to the OITF or removed. If an error occurs, the method returns <code>null</code>.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">deviceType</td><td>Valid types of device are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Audio Capture devices</td></tr>
<tr><td>1</td><td>Video Capture devices (*)</td></tr>
</table>
(*) Parameters and values not supported for voice only telephony services
</td></tr>
</table>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>setCaptureDevice</b>( Integer deviceType, Integer deviceID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Sets the capture device (for a specific device type) that will be used during the call. This method does not affect currently ongoing call sessions. Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred.</p>
<p>If the application does not set capture devices (i.e. it does not invoke <code>setCaptureDevice()</code> ) then the devices that will be used for the next call session will be the ones in the first position in the <a href="#deviceinfocollection-class" class="apiRef">DeviceInfoCollection</a> objects returned by the <a href="#oipfcommunicationservices-getdevicelist" class="apiRef">getDeviceList()</a> method for each device type.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">deviceType</td><td>Valid types of device are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Audio Capture devices</td></tr>
<tr><td>1</td><td>Video Capture devices (*)</td></tr>
</table>
(*) Parameters and values not supported for voice only telephony services
</td></tr>
<tr><td class="dae-method-table-argument">deviceID</td><td>The specific <a href="#deviceinfo-class" class="apiRef">DeviceInfo</a> object <a href="#deviceinfo-id" class="apiRef">id</a> property (in a <a href="#deviceinfocollection-class" class="apiRef">DeviceInfoCollection</a>) identifying the capture device that will be used for the call</td></tr>
</table>
<table class="dae-method-table" id="getcodeclist">
<tr><td colspan="3" class="api-signature"><a href="#codecinfocollection-class" class="apiRef">CodecInfoCollection</a> <b>getCodecList</b>( Integer streamType )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Returns the list of codec available on the terminal for a specific stream type. If an error occurs or no codecs are available for the specified stream type, the method returns <code>null</code>.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">streamType</td><td>Valid stream type values are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Audio</td></tr>
<tr><td>1</td><td>Video(*)</td></tr>
</table>
(*) Parameters and values not supported for voice only telephony services
</td></tr>
</table>
<table class="dae-method-table" id="setpreferredcodeclist">
<tr><td colspan="3" class="api-signature">Boolean <b>setPreferredCodecList</b>( Integer streamType, <a href="#codecinfocollection-class" class="apiRef">CodecInfoCollection</a> preferredCodecList )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Sets a list of preferred codec to be used in the call setup for a specific stream type. Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred. Invocation of this method does not affect currently ongoing call sessions.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">streamType</td><td>Valid stream type values are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Audio</td></tr>
<tr><td>1</td><td>Video(*)</td></tr>
</table>
(*) Parameters and values not supported for voice only telephony services
</td></tr>
<tr>
<td class="dae-method-table-argument">preferredCodecList</td><td>List of codecs to be used during the call setup negotiation (ordered by preference)</td></tr>
</table>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">String <b>getCallParameter</b>( Integer cid, String parameter )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Returns a parameter value for the call session identified by the <code>cid</code> parameter. This method can be invoked before a call session creation or during an ongoing call session. If the <code>cid</code> parameter is <code>null</code> then the retrieved settings will be those that will be applied to the next call sessions that will be created (default for outgoing or incoming call). Returns the value of the parameter or <code>null</code> if an error occurred or the parameter is not supported.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>Call session identifier for the application (Call ID).</td></tr>
<tr><td class="dae-method-table-argument">parameter</td><td>Mandatory values are shown in the table below. Parameter names are not case sensitive.
<table class="dae-api-values-table">
<tr><th>Parameter name</th><th>Description</th></tr>
<tr><td>AUDIO_PAUSE</td><td>Audio transmission pause. The parameter can be <code>TRUE</code> or <code>FALSE</code>.</td></tr>
<tr><td>VIDEO_PAUSE</td><td>Video transmission pause. The parameter can be <code>TRUE</code> or <code>FALSE</code>. (*)</td></tr>
<tr><td>VIDEO_FPS</td><td>Captured video frame per second (*)</td></tr>
<tr><td>VIDEO_SIZE</td><td>Captured video frame per second (*)<ul><li>176x144<li>352x288<li>640x480</ul></td></tr>
<tr><td>MEDIA_BW</td><td>Audio and video (if available) transmission gross bandwidth (Kbps)</td></tr>
</table>
(*) Parameters and values not supported for voice only telephony services
</td></tr>
</table>
<table class="dae-method-table" id="oipfcommunicationservices-setcallparameter">
<tr><td colspan="3" class="api-signature">Boolean <b>setCallParameter</b>( Integer cid, String parameter, String value )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Sets parameter value for the call session identified by the <code>cid</code> parameter. This method can be invoked before a call session creation or during an ongoing call session. If <code>cid</code> parameter is defined, then the settings will be applied to the call session identified by this Call ID. If <code>cid</code> parameter is <code>null</code> then the settings will be applied at the next call sessions that will be created (default for outgoing or incoming call). Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred.
</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>Call session identifier for the application (Call ID).</td></tr>
<tr><td class="dae-method-table-argument">parameter</td><td>Mandatory values are shown in the table below. Parameter names are not case sensitive.
<table class="dae-api-values-table">
<tr><th>Parameter name</th><th>Description</th></tr>
<tr><td>AUDIO_PAUSE</td><td>Audio transmission pause. The parameter can be <code>TRUE</code> or <code>FALSE</code>.</td></tr>
<tr><td>VIDEO_PAUSE</td><td>Video transmission pause. The parameter can be <code>TRUE</code> or <code>FALSE</code>. (*)</td></tr>
<tr><td>VIDEO_FPS</td><td>Captured video frame per second (*)</td></tr>
<tr><td>VIDEO_SIZE</td><td>Captured video frame per second (*)<ul><li>176x144<li>352x288<li>640x480</ul></td></tr>
<tr><td>MEDIA_BW</td><td>Audio and video (if available) transmission gross bandwidth (Kbps)</td></tr>
</table>
(*) Parameters and values not supported for voice only telephony services
</td></tr>
<tr>
<td class="dae-method-table-argument">value</td><td>The value for the parameter</td></tr>
</table>
</section>
<section id="oipfcommunicationservices-voicetel-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a></td><td>CallEvent</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>eventType</code>, <code>cid</code>, <code>status</code>, <code>info</code></td></tr>
</table>
<p>Note: these DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <a href="#application-oipfcommunicationservices" class="apiRef">application/oipfCommunicationServices</a> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>
</section>

<section id="application-oipfcommunicationservices-videotel">
<h3>Extensions to application/oipfCommunicationServices for video telephony services</h3>
<p>If an OITF has indicated support for full-duplex Video Telephony Services functionality by a server by stating <code>&lt;telephony_services video="true"&gt;true&lt;/telephony_services&gt;</code> as defined in section <a href="#communication-services-api-support" class="sectionRef">9.3.9</a> in its capability description, the OITF SHALL support communication services through the use of the following non-visual embedded object:</p><pre>
&lt;object type="application/oipfCommunicationServices"/&gt;
</pre>
<p>The extensions for telephony services provide support for:</p><ul>
<li>Parameters and values related to video (identified by (*) in previous sections).
<li>Methods to manage the rendering of local and remote video streams through CEA-2014 A/V Control or HTML5 video element.
<li>Methods to send a session update request and to accept or refuse it. A session update is typically invoked when users want to add video to their currently ongoing voice-only call session.</ul>
<p>When a remote or local video is activated on a <i>target</i> CEA-2014 A/V Control or HTML5 video element, any currently displayed video content on that object is stopped and released. The activated stream is automatically played.</p>
<p>The full-duplex Video Telephony Services API MAY be supported in the combined OITF and IG deployment cases as well as the separated OITF and IG case. It MAY be supported in other deployment cases. The use of the HNI-IGI interface is OPTIONAL between the OITF and IG when these are co-deployed.</p>
<section id="oipfcommunicationservices-videotel-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="oipfcommunicationservices-showremotevideo">
<tr><td colspan="3" class="api-signature">Boolean <b>showRemoteVideo</b>( Integer cid, Integer mode, String idVideoCallObject )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Activates or deactivates remote peer video rendering. Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred. This method can be invoked as soon as a valid call id is available: after a call method invocation or when an incoming call is notified.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>Call session identifier for the application (Call ID).</td></tr>
<tr><td class="dae-method-table-argument">mode</td><td>Valid values are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Parameter name</th><th>Description</th></tr>
<tr><td>0</td><td>Deactivates remote video</td></tr>
<tr><td>1</td><td>Activates remote video</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-argument">idVideoCallObject</td><td>ID attribute associated with the HTML tag of the A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef">7.14</a> or HTML5 video element in which the video frames will be rendered</td></tr>
</table>
<table class="dae-method-table" id="oipfcommunicationservices-showlocalvideopreview">
<tr><td colspan="3" class="api-signature">Boolean <b>showLocalVideoPreview</b>( Integer cid, Integer mode, String idVideoCallObject )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Activates or deactivates local video preview. This method can be invoked before a call session creation or during an ongoing call session. If <code>cid</code> parameter is defined, then the local video stream will be one currently used in the call session identified by this Call ID. If <code>cid</code> parameter is <code>null</code> then the local video stream will be the one that will be used in the next call session that will be created (outgoing or incoming call). Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred. This method can be invoked before or after the call session setup</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>Call session identifier for the application (Call ID).</td></tr>
<tr><td class="dae-method-table-argument">mode</td><td>Valid values are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Parameter name</th><th>Description</th></tr>
<tr><td>0</td><td>Deactivates local video preview</td></tr>
<tr><td>1</td><td>Activates local video preview</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-argument">idVideoCallObject</td><td>ID attribute associated with the HTML tag of the A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef">7.14</a> or HTML5 video element in which the video frames will be rendered</td></tr>
</table>
<table class="dae-method-table" id="oipfcommunicationservices-callupdate">
<tr><td colspan="3" class="api-signature">Boolean <b>callUpdate</b>( Integer cid, Integer callType )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Requests an update for the call session identified by the cid parameter. Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>Call session identifier for the application (Call ID).</td></tr>
<tr><td class="dae-method-table-argument">callType</td><td>Valid values are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Parameter name</th><th>Description</th></tr>
<tr><td>0</td><td>AUDIO_ONLY: activate a full-duplex voice only call</td></tr>
<tr><td>1</td><td>VIDEO_ONLY: activate a video only call</td></tr>
<tr><td>2</td><td>AUDIO_VIDEO: activate a full-duplex video call (voice + video)</td></tr>
</table>
</td></tr>
</table>
<table class="dae-method-table" id="oipfcommunicationservices-callanswerupdate">
<tr><td colspan="3" class="api-signature">Boolean <b>callAnswerUpdate</b>( Integer cid, Integer responseUpdate )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Answers an incoming call. Returns <code>true</code> if the method is successfully executed; <code>false</code> if an error occurred. Note that if an OITF supports full-duplex voice only calls, then the underlying signalling layer SHALL automatically refuse any update request to video. Requests an update for the call session identified by the <code>cid</code> parameter.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">cid</td><td>Call session identifier for the application (Call ID).</td></tr>
<tr><td class="dae-method-table-argument">responseUpdate</td><td>Valid values are shown in the table below.
<table class="dae-api-values-table">
<tr><th>Parameter name</th><th>Description</th></tr>
<tr><td>0</td><td>UPDATE_ACCEPT: Accepts the update request</td></tr>
<tr><td>1</td><td>UPDATE_REFUSE: Refuses the update request</td></tr>
<tr><td>2</td><td>UPDATE_TIMEOUT: Refuses the update request due to no answer from user</td></tr>
</table>
</td></tr>
</table>
</section>
</section>

<section id="deviceinfo-class">
<h3>The DeviceInfo class</h3>
Represents a device installed on or connected to the OITF. A device can be for example a capture device, a rendering device etc.
<section id="deviceinfo-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="deviceinfo-id">
<tr><td class="api-signature">readonly Integer <b>id</b></td></tr>
<tr><td>A unique, implementation dependent identifier for the capture device defined by the local system. The system SHALL guarantee that the id assigned to a device will not change during the life of the application</td></tr>
</table>
<table class="dae-property-table" id="deviceinfo-devicetype">
<tr><td class="api-signature">readonly Integer <b>deviceType</b></td></tr>
<tr><td>The type of device, valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Audio Capture devices</td></tr>
<tr><td>1</td><td>Video Capture devices (*)</td></tr>
</table>
(*) Parameters and values not supported for voice only telephony services
</td></tr>
</table>
<table class="dae-property-table" id="deviceinfo-devicename">
<tr><td class="api-signature">readonly String <b>deviceName</b></td></tr>
<tr><td>The friendly name for the capture device. May be used in user messages.</td></tr>
</table>
<table class="dae-property-table" id="deviceinfo-deviceproductname">
<tr><td class="api-signature">readonly String <b>deviceProductName</b></td></tr>
<tr><td>The complete name, model number etc. for the capture device.</td></tr>
</table>
</section>
</section>
<section id="deviceinfocollection-class">
<h3>The DeviceInfoCollection class</h3>
<pre>
typedef Collection&lt;<a href="#deviceinfo-class" class="apiRef">DeviceInfo</a>&gt; DeviceInfoCollection
</pre>
<p>The <code>DeviceInfoCollection</code> class represents a collection of <a href="#deviceinfo-class" class="apiRef">DeviceInfo</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.</p>
</section>

<section id="codecinfo-class">
<h3>The CodecInfo class</h3>
<section id="codecinfo-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>codecName</b></td></tr>
<tr><td>The codec name.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>mimeType</b></td></tr>
<tr><td>The codec mime-type. A list of possible codec mime-types for multimedia telephony supported by the OIPF Solution are listed in <a href="volume2.html#av-for-video-telephony" class="extRef">Table 6</a> of [[.OIPF_MEDIA2]].</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>profile</b></td></tr>
<tr><td>The codec profile. Normative definition of a subset of standard codec functionalities. The codec profiles for multimedia telephony supported by the OIPF Solution are listed in <a href="volume2.html#video-telephony" class="extRef">section 5.1.3</a> of [[.OIPF_MEDIA2]].</td></tr>
</table>

</section>
</section>
<section id="codecinfocollection-class">
<h3>The CodecInfoCollection class</h3>
<pre>
typedef Collection&lt;<a href="#codecinfo-class" class="apiRef">CodecInfo</a>&gt; CodecInfoCollection
</pre>
<p>The <code>CodecInfoCollection</code> class represents a collection of <a href="#codecinfo-class" class="apiRef">CodecInfo</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.</p>
<p>In addition to the methods and properties defined for generic collections, the <code>CodecInfoCollection</code> class supports the additional properties and methods defined below.</p>

<section id="codecinfocollection-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>moveAt</b>( Integer targetIndex, Integer index )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Moves a <a href="#codecinfo-class" class="apiRef">CodecInfo</a> item from the specified <code>index</code> to the specified <code>targetIndex</code>. The operation is performed through an item removal and an insertion of the same item in a new position. The <code>targetIndex</code> is the position in which the element SHALL be inserted considering position indexes before item removal. During removal and insertion, the other items will shift accordingly. This method SHALL return <code>true</code> if the operation succeeded, or <code>false</code> if an invalid index was specified (e.g. index > length).</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">targetIndex</td><td>The index in the list to which the item should be moved.</td></tr>
<tr><td class="dae-method-table-argument">index</td><td>The index in the list of the item that will be moved.</td></tr>
</table>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">Boolean <b>remove</b>( Integer index )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Removes the item at the specified index from the <code>CodecInfoCollection</code>. The other items SHALL shift accordingly. Returns <code>true</code> if the operation succeeded, or <code>false</code> if an invalid index was specified.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">index</td><td>The index of the item to be removed.</td></tr>
</table>
</section>
</section>
</section>   <!-- communication-services-apis -->

<section id="parental-rating-and-parental-control-apis">
<h2>Parental rating and parental control APIs</h2>
<p>This section defines APIs related to parental ratings and parental control.</p>
<p>Sections <a href="#application-oipfparentalcontrolmanager" class="sectionRef"></a> through <a href="#parentalratingschemecollection-class" class="sectionRef"></a> define a new JavaScript embedded object &ldquo;<code>application/oipfParentalControlManager</code>&rdquo; and the related <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> and <a href="#parentalratingschemecollection-class" class="apiRef">ParentalRatingSchemeCollection</a> objects, which allows applications to construct a new parental rating scheme (and a parental rating value using that scheme), and to temporarily enable or disable viewing of a content item. These APIs SHALL be supported if an OITF supports parental controls as indicated by value &ldquo;<code>true</code>&rdquo; for element <code>&lt;parentalcontrol&gt;</code> (as defined by section <a href="#parental-ratings-capabilty" class="sectionRef"></a>) in its capability profile.</p>
<p>Sections <a href="#parentalrating-class" class="sectionRef"></a> and <a href="#parentalratingcollection-class" class="sectionRef"></a> define the <a href="#parentalrating-class" class="apiRef">ParentalRating</a> and <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> objects. These objects are used/referenced by various other objects, such as the <a href="#programme-class" class="apiRef">Programme</a> object as defined in section <a href="#programme-class" class="sectionRef"></a> to indicate a particular parental rating. The support for these objects depends on the support for the sections in which these are used.</p>

<section id="application-oipfparentalcontrolmanager">
<h3>The application/oipfParentalControlManager embedded object</h3>
<p>If an OITF supports parental controls as indicated by value &ldquo;<code>true</code>&rdquo; for element <code>&lt;parentalcontrol&gt;</code> (as defined by section <a href="#parental-ratings-capabilty" class="sectionRef"></a>) in its capability profile, the OITF SHALL support the <code>application/oipfParentalControlManager</code> object with the following interface.</p>
<p>The following example shows a possible usage scenario for the <code>application/oipfParentalControlManager</code>, i.e. to add a new parental rating scheme to the parentalRatingSchemes collection:</p><pre class="javascript">
//get a reference to the parental control manager object
var pcManager = document.getElementById("pcmanager");

// add a new rating scheme &mdash; in this case, the MPAA rating scheme
pcManager.parentalRatingSchemes.addParentalRatingScheme(
    "urn:mpeg:mpeg7:cs:MPAAParentalRatingCS:2001", "G,PG,PG-13,R,NC-17,NR" );
</pre>
<p>The following example shows a possible usage scenario for the <code>application/oipfParentalControlManager</code>, i.e. to temporarily unblock a blocked content item (e.g. after asking the user to enter the parental control pin):</p><pre class="javascript">
// If a content item is blocked, the event &ldquo;onParentalRatingChange&rdquo; can be captured, and 
// the setParentalControlStatus() method can be used to temporarily unblock the content 
// (e.g. after asking the user to enter the parental control pin)

function askForPin() { ... }

...

//get a reference to the A/V player object 
var avPlayer = document.getElementById("avPlayer");

avPlayer.onParentalRatingChange = function() {
  var pin=askForPin();pcManager.setParentalControlStatus(pin, false)};
</pre>
<section id="application-oipfparentalcontrolmanager-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="oipfparentalcontrolmanager-parentalratingschemes">
<tr><td class="api-signature">readonly <a href="#parentalratingschemecollection-class" class="apiRef">ParentalRatingSchemeCollection</a> <b>parentalRatingSchemes</b></td></tr>
<tr><td>A reference to the collection of rating schemes known by the OITF.</td></tr>
</table>
<table class="dae-property-table" >
<tr><td class="api-signature">readonly Boolean <b>isPINEntryLocked</b></td></tr>
<tr><td>The lockout status of the parental control PIN.  If the incorrect PIN has been entered too many times in the configured timeout period, parental control PIN entry SHALL be locked out for a period of time determined by the OITF.</td></tr>
</table>
</section>
<section id="application-oipfparentalcontrolmanager-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="setparentalcontrolstatus">
<tr><td colspan="3" class="api-signature">Integer <b>setParentalControlStatus</b>( String pcPIN, Boolean enable )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>As defined in [[.OIPF_CSP2]], the OITF shall prevent the consumption of a programme when its parental rating doesn't meet the parental rating criterion currently defined in the OITF. Calling this method with <code>enable</code> set to <code>false</code> will temporarily allow the consumption of any blocked programme.</p>  
<p>Setting the parental control status using this method SHALL set the status until the consumption of any of all the blocked programmes terminates (e.g. until the content item being played is changed), or another call to the <code>setParentalControlStatus()</code> method is made.</p>
<p>Setting the parental control status using this method has the following effect; for the <a href="#programme-class" class="apiRef">Programme</a> and <a href="#channel-class" class="apiRef">Channel</a> objects as defined in sections <a href="#programme-class" class="sectionRef"></a> and <a href="#channel-class" class="sectionRef"></a>, the <code>blocked</code> property of a programme or channel SHALL be set to <code>true</code> for programmes whose parental rating does not meet the applicable parental rating criterion, but the <code>locked</code> property SHALL be set to <code>false</code>.</p>
<p>This operation to temporarily disable parental rating control SHALL be protected by the parental control PIN (i.e. through the pcPIN argument). The return value indicates the success of the operation, and SHALL take one of the following values:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>The PIN is correct.</td></tr>
<tr><td>1</td><td>The PIN is incorrect.</td></tr>
<tr><td>2</td><td>PIN entry is locked because an invalid PIN has been entered too many times. The number of invalid PIN attempts before PIN entry is locked is outside the scope of this specification.</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">pcPIN</td><td>The parental control PIN.</td></tr>
<tr><td class="dae-method-table-argument">enable</td><td>Flag indicating whether parental control should be enabled.</td></tr>
</table>

<table class="dae-method-table" id="getparentalcontrolstatus">
<tr><td colspan="2" class="api-signature">Boolean <b>getParentalControlStatus</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Returns a flag indicating the temporary parental control status set by <a href="#setparentalcontrolstatus" class="apiRef">setParentalControlStatus()</a>. Note that the returned status covers parental control functionality related to all rating schemes, not only the rating scheme upon which the method is called.</td></tr>
</table>

<table class="dae-method-table" id="getblockunrated">
<tr><td colspan="2" class="api-signature">Boolean <b>getBlockUnrated</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Returns a flag indicating whether or not the OITF has been configured by the user to block content for which a parental rating is absent.</td></tr>
</table>

<table class="dae-method-table" id="setparentalcontrolpin">
<tr><td colspan="3" class="api-signature">Integer <b>setParentalControlPIN</b>( String oldPcPIN, String newPcPIN )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Set the parental control PIN.</p>  
<p>This operation SHALL be protected by the parental control PIN (if PIN entry is enabled).  The return value indicates the success of the operation, and SHALL take one of the following values: </p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>The PIN is correct.</td></tr>
<tr><td>1</td><td>The PIN is incorrect.</td></tr>
<tr><td>2</td><td>PIN entry is locked because an invalid PIN has been entered too many times. The number of invalid PIN attempts before PIN entry is locked is outside the scope of this specification.</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">oldPcPIN</td><td>The current parental control PIN.</td></tr>
<tr><td class="dae-method-table-argument">newPcPIN</td><td>The new value for the parental control PIN.</td></tr>
</table>

<table class="dae-method-table" id="unlockwithparentalcontrolpin">
<tr><td colspan="3" class="api-signature">Integer <b>unlockWithParentalControlPIN</b>( String pcPIN, Object target )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Unlock the object specified by target for viewing if <code>pcPIN</code> contains the correct parental control PIN.</p>  
<p>The object type of target can be one of the following:</p><ul>
<li><code>video/broadcast</code> object, in which case the content being presented through this object SHALL be unlocked until a new channel is selected.
<li>A/V Control object, in which case the content being presented through this object SHALL be unlocked until a new item of content is played using this object 
</ul><p>Otherwise an Invalid object error code SHALL be returned.</p>
<p>The return value indicates the success of the operation, and SHALL take the following values: </p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>The PIN is correct.</td></tr>
<tr><td>1</td><td>The PIN is incorrect.</td></tr>
<tr><td>2</td><td>PIN entry is locked because an invalid PIN has been entered too many times. The number of invalid PIN attempts before PIN entry is locked is outside the scope of this specification.</td></tr>
<tr><td>3</td><td>Invalid object.</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">pcPIN</td><td>The parental control PIN.</td></tr>
<tr><td class="dae-method-table-argument">target</td><td>The object to be unlocked.</td></tr>
</table>

<table class="dae-method-table" id="verifyparentalcontrolpin">
<tr><td colspan="3" class="api-signature">Integer <b>verifyParentalControlPIN</b>( String pcPIN )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Verify that the PIN specified by <code>pcPIN</code> is the correct parental control PIN.</p>  
<p>This method will return one of the following values: </p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>The PIN is correct.</td></tr>
<tr><td>1</td><td>The PIN is incorrect.</td></tr>
<tr><td>2</td><td>PIN entry is locked because an invalid PIN has been entered too many times. The number of invalid PIN attempts before PIN entry is locked is outside the scope of this specification.</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">pcPIN</td><td>The parental control PIN to be verified.</td></tr>
</table>

<table class="dae-method-table" id="setblockunrated">
<tr><td colspan="3" class="api-signature">Integer <b>setBlockUnrated</b>( String pcPIN, Boolean block )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Set whether programmes for which no parental rating has been retrieved from the metadata client nor defined by the service provider should be blocked automatically by the terminal.</p>  
<p>This operation SHALL be protected by the parental control PIN (if PIN entry is enabled).  The return value indicates the success of the operation, and SHALL take one of the following values: </p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>The PIN is correct.</td></tr>
<tr><td>1</td><td>The PIN is incorrect.</td></tr>
<tr><td>2</td><td>PIN entry is locked because an invalid PIN has been entered too many times. The number of invalid PIN attempts before PIN entry is locked is outside the scope of this specification.</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">pcPIN</td><td>The parental control PIN.</td></tr>
<tr><td class="dae-method-table-argument">block</td><td>Flag indicating whether programmes SHALL be blocked.</td></tr>
</table>
</section>
</section>

<section id="parentalratingscheme-class">
<h3>The ParentalRatingScheme class</h3>
<pre>
typedef Collection&lt;String&gt; ParentalRatingScheme
</pre>
<p>A <code>ParentalRatingScheme</code> describes a single parental rating scheme that may be in use for rating content, e.g. the MPAA or BBFC rating schemes. It is a collection of strings representing rating values, which next to the properties and methods defined below SHALL support the array notation to access the rating values in this collection. For the natively OITF supported parental rating systems the values SHALL be ordered by the OITF to allow the rating values to be compared in the manner as defined for property <a href="#parentalratingscheme-threshold" class="apiRef">threshold</a> for the respective parental rating system. Using a threshold as defined in this API may not necessarily be the proper way in which parental rating filtering is applied on the OITF, e.g. the US FCC requirements take precedence for device to be imported to the US.</p>
<p>The parental rating schemes supported by a receiver MAY vary between deployments.</p>
<p>See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.  In addition to the methods and properties defined for generic collections, the <code>ParentalRatingScheme</code> class supports the additional properties and methods defined below.
<section id="parentalratingscheme-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="parentalratingscheme-name">
<tr><td class="api-signature">readonly String <b>name</b></td></tr>
<tr><td><p>The unique name that identifies the parental rating scheme. Valid strings include:</p><ul>
<li>the URI of one of the MPEG-7 classification schemes representing a parental rating scheme as defined by the &ldquo;<code>uri</code>&rdquo; attribute of one of the parental rating <code>&lt;ClassificationScheme&gt;</code> elements in [[!MPEG-7]].
<li>the string value <mark class="error">&ldquo;<code>urn:oipf:GermanyFSKCS</code>&rdquo; to represent the GermanyFSK rating scheme as defined in [[.OIPF_META2]]</mark>.<div class="editor-note">This classification scheme is in all versions of the OIPF specification, but has been versioned. In R2v2.3 it is <a href="volume3.html#germanyfskCS" class="extRef">urn:oipf:cs:GermanyFSKCS:2008</a></div>
<li>the string value &ldquo;<code>dvb-si</code>&rdquo;: this means that the scheme of a minimum recommended age encoded as per ratings 0x01 to 0x0f in the parental rating descriptor from [[!EN300468]], is used to represent the parental rating values.
<p>NOTE: If the broadcaster defined range from 0x10 to 0xff is used then that would be a different parental rating scheme and not "<code>dvb-si</code>".</p></ul>
<p>If the value of &ldquo;<code>name</code>&rdquo; is &ldquo;<code>dvb-si</code>&rdquo;, the <code>ParentalRatingScheme</code> remains empty (i.e. <code>ParentalRatingScheme.length == 0</code>).</p>
</td></tr>
</table>
<table class="dae-property-table" id="parentalratingscheme-threshold" >
<tr><td class="api-signature">readonly String <b>threshold</b></td></tr>
<tr><td><p>The parental rating threshold that is currently in use by the OITF's parental control system for this rating scheme, which is encoded as a <a href="#parentalrating-class" class="apiRef">ParentalRating</a> object in the following manner:</p>
<p>If the value of the &ldquo;<code>name</code>&rdquo; property of the <code>ParentalRatingScheme</code> object is unequal to &ldquo;<code>dvb-si</code>&rdquo;, then:</p><ul>
<li>the &ldquo;<code>value</code>&rdquo; property of the threshold object represents the value for which items with a <a href="#parentalrating-value" class="apiRef">ParentalRating.value</a> greater or equal to the &ldquo;<code>value</code>&rdquo; property of the threshold object have been configured by the OITF's parental control subsystem to be blocked. 
<li>the &ldquo;<code>labels</code>&rdquo; property of the threshold object represents the bit map of zero or more flags for which items with a <a href="#parentalrating-labels" class="apiRef">ParentalRating.labels</a> property with any of the same flags set have been configured by the OITF's parental control subsystem to be blocked.
</ul>
<p>If the value of the &ldquo;<code>name</code>&rdquo; property of the <code>ParentalRatingScheme</code> object is &ldquo;<code>dvb-si</code>&rdquo;, the threshold indicates a minimum recommended age encoded as per [[!EN300468]] at which or above which the content is being blocked by the OITF's parental control subsystem</p>
<p>Note that the <code>value</code> property as an index into the <a href="#parentalrating-class" class="apiRef">ParentalRating</a> object that defines the threshold can be 1 larger than the value of <code>ParentalRatingScheme.length</code> to convey that no content is being blocked by the parental control subsystem.</p>
</td></tr>
</table>
</section>
<section id="parentalratingscheme-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="parentalratingscheme-indexof">
<tr><td colspan="3" class="api-signature">Integer <b>indexOf</b>( String ratingValue )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Return the index of the rating represented by attribute <code>ratingValue</code> inside the parental rating scheme string collection, or <code>-1</code> if the rating value cannot be found in the collection.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">ratingValue</td><td>The string representation of a parental rating value. See property <a href="#parentalrating-name" class="apiRef">name</a> in section <a href="#parentalrating-properties" class="sectionRef"></a> for more information about possible values. Values are not case sensitive.</td></tr>
</table>
<table class="dae-method-table" id="parentalratingscheme-iconuri">
<tr><td colspan="3" class="api-signature">String <b>iconUri</b>( Integer index  )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Return the URI of the icon representing the rating at <code>index</code> in the rating scheme, or undefined if no item is present at that position.  If no icon is available, this method SHALL return <code>null</code>.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">index</td><td>The index of the parental rating scheme.</td></tr>
</table>
</section>
</section>

<section id="parentalratingschemecollection-class">
<h3>The ParentalRatingSchemeCollection class</h3>
<pre>
typedef Collection&lt;<a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a>&gt; ParentalRatingSchemeCollection
</pre>
<p>A <code>ParentalRatingSchemeCollection</code> represents a collection of parental rating schemes, e.g. as returned by property <a href="#oipfparentalcontrolmanager-parentalratingschemes" class="apiRef">parentalRatingSchemes</a> of the &ldquo;<a href="#application-oipfparentalcontrolmanager" class="apiRef">application/oipfParentalControlManager</a>&rdquo; object as defined in section <a href="#application-oipfparentalcontrolmanager" class="sectionRef"></a>. Next to the properties and methods defined below a <code>ParentalRatingSchemeCollection</code> object SHALL support the array notation to access the parental rating scheme objects in this collection. </p>
<p>See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template. In addition to the methods and properties defined for generic collections, the <code>ParentalRatingSchemeCollection</code> class supports the additional properties and methods defined below.</p>
<section id="parentalratingschemecollection-methods">
<h4>Methods</h4>
<table class="dae-method-table"  id="parentalratingschemecollection-addparentalratingscheme">
<tr><td colspan="3" class="api-signature"><a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> <b>addParentalRatingScheme</b>( String name, String values )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">
<p>Create a new <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> object and adds it to the <code>ParentalRatingSchemeCollection</code>. Applications MAY use this method to register additional parental rating schemes with the platform. When registered, the new parental rating scheme SHALL (temporarily) be accessible through the <a href="#oipfparentalcontrolmanager-parentalratingschemes" class="apiRef">parentalRatingSchemes</a> property of the &ldquo;<a href="#application-oipfparentalcontrolmanager" class="apiRef">application/oipfParentalControlmanager</a>&rdquo; object as defined in section <a href="#application-oipfparentalcontrolmanager" class="sectionRef"></a>.</p>
<p>The application SHALL make sure that the values are ordered in such a way to allow the rating values to be compared in the manner as defined for the <code>threshold</code> property for the respective parental rating system.</p>
<p>This method returns a reference to the <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> object representing the added scheme. If the value of the <code>name</code> parameter corresponds to an already-registered rating scheme, this method returns a reference to the existing <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> object. If the newly defined rating scheme was not known to the OITF, the scheme MAY be stored persistently, and the OITF may offer a UI to set the parental rating blocking criteria for the newly added parental rating scheme. </p>
<p>If the OITF has successfully stored (persistently or not persistently) the additional parental rating scheme, the method SHALL return a non-<code>null</code> <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> object.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">name</td><td>A unique string identifying the parental rating scheme to which this value refers. See property <a href="parentalratingscheme-name" class="apiRef">name</a> in section <a href="#parentalratingscheme-properties" class="sectionRef"></a> for more information about possible values.</td></tr>
<tr><td class="dae-method-table-argument">values</td><td>A comma-separated list of the possible values in the rating scheme, in ascending order of severity. In case the rating scheme is one of the [[!MPEG-7]] rating classification schemes, this means that the list of parental rating values contains the values as specified by the <code>&lt;Name&gt;</code> elements of the <code>&lt;Term&gt;</code> elements in the order of appearance as they are defined for the classification scheme, with the exception of the Internet Content Rating Association (ICRA) based ratings, for which the reverse order has to be applied. The values must be ordered in such a way to allow the rating values to be compared in the manner as defined for property <code>threshold</code> for the respective parental rating system.</td></tr>
</table>

<table class="dae-method-table" id="getparentalratingscheme">
<tr><td colspan="3" class="api-signature"><a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> <b>getParentalRatingScheme</b>( String name )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">This method returns a reference to the <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> object that is associated with the given scheme as specified through parameter &ldquo;<code>name</code>&rdquo;. If the value of <code>name</code> does not correspond to the <code>name</code> property of any of the <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> objects in the <a href="#parentalratingschemecollection-class" class="apiRef">ParentalRatingSchemeCollection</a>, the method SHALL return <code>undefined</code>.</td></tr>
<tr><td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">name</td><td>The unique name identifying a parental rating scheme.</td></tr>
</table>
</section>
</section>

<section id="parentalrating-class">
<h3>The ParentalRating class</h3>
<p>A <code>ParentalRating</code> object describes a parental rating value for a programme or channel. The <code>ParentalRating</code> object identifies both the rating scheme in use, and the parental rating value within that scheme.</p>
<p>In case of a BCG the values of the properties in this object will be read from the <code>ParentalGuidance</code> element that is the child of a programme's BCG description.</p>
<p>Example usage:<pre  class="javascript">
&lt;!-- This example shows a possible usage scenario for the ParentalRating 
     data structure, i.e. to create a new programme to record and set 
     parental rating to MPAA parental rating to PG-13.    
--&gt;
...
&lt;script type="text/javascript" language="Javascript1.5"&gt;

// get a reference to the recorder object
var recorder = document.getElementById("recorder");

// create new programme to record 
var myProgramme = recorder.createProgrammeObject();

// add a new parental rating value to myProgramme, in this case the 
// programme is rated PG-13 for the US using the MPAA Parental rating scheme.
myProgramme.parentalRatings.addParentalRating(
    "urn:mpeg:mpeg7:cs:MPAAParentalRatingCS:2001", "PG-13", 2, 0, "US"
    );

&lt;/script&gt;
...
&lt;object id="recorder" type="application/oipfRecordingScheduler"/&gt;
</pre>
<section id="parentalrating-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="parentalrating-name">
<tr><td class="api-signature">readonly String <b>name</b></td></tr>
<tr><td><p>The string representation of the parental rating value for the respective rating scheme denoted by property <code>scheme</code>. </p>
<p>Valid strings include:</p> <ul>
<li>if the value of property <a href="#parentalrating-scheme" class="apiRef">scheme</a> represents one of the parental rating classification scheme names identified by [[!MPEG-7]]: the string representation of one of the parental rating values as defined by one of the <code>&lt;Name&gt;</code> elements.
<li>if the value of property <a href="#parentalrating-scheme" class="apiRef">scheme</a> is <mark class="error">&ldquo;<code>urn:oipf:GermanyFSKCS</code>&rdquo;, the string representation of one the values for the GermanyFSK rating scheme as defined in [[.OIPF_META2]].</mark><div class="editor-note">This classification scheme is in all versions of the OIPF specification, but has been versioned. In R2v2.3 it is <a href="volume3.html#germanyfskCS" class="extRef">urn:oipf:cs:GermanyFSKCS:2008</a></div>
<li>if the value of property <a href="#parentalrating-scheme" class="apiRef">scheme</a> is equal to &ldquo;<code>dvb-si</code>&rdquo;, this means that the scheme of a minimum recommended age encoded as per ratings 0x01 to 0x0f in the parental rating descriptor from [[!EN300468]], which corresponds to rating_type 0 in [[!IEC62455]].
<p>NOTE: If the broadcaster defined range from 0x10 to 0xff is used then that would be a different parental rating scheme and not "<code>dvb-si</code>".</p>
</ul>
<p>An example of a valid parental rating value is &ldquo;PG-13&rdquo;.</p>
</td></tr>
</table>

<table class="dae-property-table" id="parentalrating-scheme">
<tr><td class="api-signature">readonly String <b>scheme</b></td></tr>
<tr><td><p>Unique name identifying the parental rating guidance scheme to which this parental rating value refers. Valid strings include:</p><ul>
<li>the URI of one of the MPEG-7 classification schemes representing a parental rating scheme as defined by the &ldquo;<code>uri</code>&rdquo; attribute of one of the parental rating <code>&lt;ClassificationScheme&gt;</code> elements in [[!MPEG-7]].
<li>the string value <mark class="error">&ldquo;<code>urn:oipf:GermanyFSKCS</code>&rdquo; to represent the GermanyFSK rating scheme as defined in [[.OIPF_META2]]</mark><div class="editor-note">This classification scheme is in all versions of the OIPF specification, but has been versioned. In R2v2.3 it is <a href="volume3.html#germanyfskCS" class="extRef">urn:oipf:cs:GermanyFSKCS:2008</a></div>.
<li>the string value &ldquo;<code>dvb-si</code>&rdquo;: this means that the scheme of a minimum recommended age encoded as per [[!EN300468]], is used to represent the parental rating values.
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="parentalrating-value">
<tr><td class="api-signature">readonly String <b>value</b></td></tr>
<tr><td><p>The parental rating value represented as an index into the set of values defined as part of the <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> identified through property &ldquo;<a href="#parentalrating-scheme" class="apiRef">scheme</a>&rdquo;.</p>
<p>If an associated <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> object can be found by calling method <a href="#getparentalratingscheme" class="apiRef">getParentalRatingScheme()</a> on property <a href="#oipfparentalcontrolmanager-parentalratingschemes" class="apiRef">parentalRatingSchemes</a> of the <a href="#application-oipfparentalcontrolmanager" class="apiRef">application/oipfParentalControlManager</a> object and the value of property <a href="#parentalrating-scheme" class="apiRef">scheme</a> is not equal to &ldquo;<code>dvb-si</code>&rdquo;, then the <code>value</code> property SHALL represent the index of the parental rating value inside the <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> object, or <code>-1</code> if the value cannot be found. If the value of property <a href="#parentalrating-scheme" class="apiRef">scheme</a> is equal to &ldquo;<code>dvb-si</code>&rdquo;, then this property SHALL be the integer representation of the string value of <a href="#parentalrating-class" class="apiRef">ParentalRating</a> property <a href="#parentalrating-name" class="apiRef">name</a>.</p>
<p>If no associated <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> object can be found by calling method <a href="#getparentalratingscheme" class="apiRef">getParentalRatingScheme</a> on property <a href="#oipfparentalcontrolmanager-parentalratingschemes" class="apiRef">parentalRatingSchemes</a> of the <a href="#application-oipfparentalcontrolmanager" class="apiRef">application/oipfParentalControlManager</a> object, then the <code>value</code> property SHALL have value <code>undefined</code>. </p>
</td></tr>
</table>

<table class="dae-property-table" id="parentalrating-labels">
<tr><td class="api-signature">readonly Integer <b>labels</b></td></tr>
<tr><td><p>The labels property represents a set of parental advisory flags that may provide additional information about the rating.</p>
<p>The value of this field is a 32 bit integer value that represents a binary mask corresponding to the sum of zero or more label values defined in the table below. If no labels have been explicitly set, the value for the &ldquo;<code>labels</code>&rdquo; property SHALL be 0.</p>
<p>Valid labels include:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>Indicates that a content item features sexual suggestive dialog.</td></tr>
<tr><td>2</td><td>Indicates that a content item features strong language.</td></tr>
<tr><td>4</td><td>Indicates that a content item features sexual situations.</td></tr>
<tr><td>8</td><td>Indicates that a content item features violence.</td></tr>
<tr><td>16</td><td>Indicates that a content item features fantasy violence.</td></tr>
<tr><td>32</td><td>Indicates that a content item features disturbing scenes.</td></tr>
<tr><td>64</td><td>Indicates that a content item features portrayals of discrimination.</td></tr>
<tr><td>128</td><td>Indicates that a content item features scenes of illegal drug use.</td></tr>
<tr><td>256</td><td>Indicates that a content item features strobing that could impact viewers suffering from Photosensitive epilepsy.</td></tr>
</table>

</td></tr>
</table>

<table class="dae-property-table" id="parentalrating-region">
<tr><td class="api-signature">readonly String <b>region</b></td></tr>
<tr><td>The region to which the parental rating value applies as an alpha-2 region code as defined in ISO 3166-1. Returns <code>undefined</code> if no specific region has been defined.</td></tr>
</table>
</section>
</section>

<section id="parentalratingcollection-class">
<h3>The ParentalRatingCollection class</h3>
<pre>
typedef Collection&lt;<a href="#parentalrating-class" class="apiRef">ParentalRating</a>&gt; ParentalRatingCollection
</pre>
<p>A <code>ParentalRatingCollection</code> represents a collection of parental rating values. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.</p>
<p>In addition to the methods and properties defined for generic collections, the <code>ParentalRatingCollection</code> class supports the additional properties and methods defined below.</p>

<section id="parentalratingcollection-methods">
<h4>Methods</h4>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">void <b>addParentalRating</b>( String scheme, String name, Integer value, Integer labels, String region )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Creates a <a href="#parentalrating-class" class="apiRef">ParentalRating</a> object instance for a given parental rating scheme and parental rating value, and adds it to the <code>ParentalRatingCollection</code> for a programme or channel. </td></tr>
<tr><td class="dae-method-table-label" rowspan="5">Arguments</td>
<td class="dae-method-table-argument">scheme</td><td>A unique string identifying the parental rating scheme to which this value refers. See property <a href="#parentalrating-scheme" class="apiRef">scheme</a> in section <a href="#parentalrating-properties" class="sectionRef"></a> for more information about possible values.</td></tr>
<tr><td class="dae-method-table-argument">name</td><td>A string representation of the parental rating value. See property <a href="#parentalrating-name" class="apiRef">name</a> in section <a href="#parentalrating-properties" class="sectionRef"></a> for more information about possible values. Values are not case sensitive.</td></tr>
<tr><td class="dae-method-table-argument">value</td><td>The parental rating value represented as an Integer. See property <a href="#parentalrating-value" class="apiRef">value</a> in section <a href="#parentalrating-properties" class="sectionRef"></a> for more information about possible values.</td></tr>
<tr><td class="dae-method-table-argument">labels</td><td>A set of content rating labels that may provide additional information about the rating. See property <a href="#parentalrating-labels" class="apiRef">labels</a> in section <a href="#parentalrating-properties" class="sectionRef"></a> for more information about possible values.</td></tr>
<tr><td class="dae-method-table-argument">region</td><td>The region to which the parental rating value applies as an alpha-2 region code as defined in ISO 3166-1. The value of this argument must be <code>null</code> or <code>undefined</code> if no specific region has been identified.  Values are not case sensitive.</td></tr>
</table>
</section>
</section>
</section>

<section id="scheduled-recording-apis">
<h2>Scheduled Recording APIs</h2>
<p>This section describes the APIs needed to support control by a DAE application of the recording (PVR) functionality available to an OITF, including time-shift support, scheduled recording and storage of basic metadata about recorded items. Changes made by a DAE application to properties that can also be set by the OITF may be overwritten by the OITF from metadata without warning.</p>
<p>This section SHALL apply for OITFs that  have indicated <code>&lt;recording&gt;</code> with value &ldquo;<code>true</code>&rdquo;  as defined in section <a href="#pvr-capability" class="sectionRef"></a> in its capability description.
<section id="application-oipfrecordingscheduler">
<h3>The application/oipfRecordingScheduler embedded object</h3>
<p>The OITF SHALL support the scheduling of recordings of broadcasts through the use of the following non-visual embedded object:</p><pre>
&lt;object type="application/oipfRecordingScheduler"/&gt;
</pre>
<p>Note that the functionality in this section SHALL adhere to the security model as specified in section <a href="#application-service-security" class="sectionRef"></a>.</p>
<p>Which channels can be recorded SHALL be indicated by the <code>ipBroadcast</code>, <code>DASH</code> and <code>HAS</code> attributes in the PVR capability indication (see section <a href="#pvr-capability" class="sectionRef"></a>). Within the channels indicated by these attributes, recording of both channels stored in the channel list and locally defined channels SHALL be supported.</p>
<section id="application-oipfrecordingscheduler-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="oipfrecordingscheduler-record">
<tr><td colspan="3" class="api-signature"><a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> <b>record</b>( <a href="#programme-class" class="apiRef">Programme</a> programme )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">
<p>Requests the scheduler to schedule the recording of the programme identified by the <a href="#programme-programmeid" class="apiRef">programmeID</a> property of the programme.</p>
<p>If the <a href="#programme-programmeidtype" class="apiRef">programmeIDType</a> of the programme has the value ID_TVA_GROUP_CRID then the <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> object returned by this method SHALL be a &ldquo;parent&rdquo; scheduled recording object that conceptually represents the  recording.  Each individual programme in the  SHALL be represented by a separate <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> object.  Note that <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> objects for individual programmes may not be created until the CRID has been partially or completely resolved. The start time, duration and other properties of the programme SHALL NOT be used for scheduling any recording. </p>
<p>Individual programmes SHALL be recorded if any entries in a programme's  associated groupCRIDs collection matches the group CRID specified in the programmeID property of any &ldquo;parent&rdquo; recording.</p>
<p>The other data contained in the programme object is used solely for annotation of the (scheduled) recording. If such programme metadata is provided, it SHALL be retained in the <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> object that is returned if the recording of the programme was scheduled successfully, reflecting the possibility that not all relevant metadata might be available to the scheduler. When the programme is recorded, the metadata in the associated Recording object SHALL be updated with the metadata from the broadcast stream if such metadata is available. If the recording could not be scheduled due to a scheduling conflict or lack of resources the value <code>null</code> is returned.</p>
<p>Note that the actual implementation of this method should enable the scheduler to identify the domain of the service that issues the scheduling request in order to support future retrieval of the scheduled recording through the <a href="#oipfrecordingscheduler-getscheduledrecordings" class="apiRef">getScheduledRecordings</a> method.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">programme</td><td>The programme to be recorded, as defined in section <a href="#programme-class" class="sectionRef"></a>.</td></tr>
</table>

<table class="dae-method-table" id="oipfrecordingscheduler-recordat">
<tr><td colspan="3" class="api-signature"><a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> <b>recordAt</b>( Integer startTime, Integer duration, Integer repeatDays, String channelID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">
<p>Requests the scheduler to schedule the recording of the broadcast to be received over the channel identified by <code>channelID</code>, starting at <code>startTime</code> and stopping at <code>startTime + duration</code>. If the recording was scheduled successfully, the resulting <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> object is returned. If the recording could not be scheduled due to a scheduling conflict or lack of resources the value <code>null</code> is returned.</p>
<p>The OITF SHOULD associate metadata with recordings scheduled using this method. This metadata MAY be obtained from the broadcast being recorded (for example DVB-SI in an MPEG-2 transport stream) or from other sources of metadata. If an application anticipates that the OITF may not be able to obtain any metadata, it SHOULD instead of using this method;</p><ul>
<li>create a <a href="#programme-class" class="apiRef">Programme</a> object (using the <a href="#oipfrecordingscheduler-createprogrammeobject" class="apiRef">createProgrammeObject()</a> method) containing the <code>channelID</code>, <code>startTime</code> and <code>duration</code>
<li>populate that <a href="#programme-class" class="apiRef">Programme</a> object with metadata
<li>pass that <a href="#programme-class" class="apiRef">Programme</a> object to the <a href="#oipfrecordingscheduler-record" class="apiRef">record(Programme)</a> method.
</ul>
<p>Note that the actual implementation of this method should enable the scheduler to identify the domain of the service that issues the scheduling request in order to support future retrieval of the scheduled recording through the <a href="#oipfrecordingscheduler-getscheduledrecordings" class="apiRef">getScheduledRecordings()</a> method.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="4">Arguments</td>
<td class="dae-method-table-argument">startTime</td><td>The start of the time period of the recording measured in seconds since midnight (GMT) on 1/1/1970. If the start time occurs in the past and the current time is within the specified duration of the recording, the OITF SHALL start recording immediately and MAY record any earlier content from the current programme that is available (e.g. stored in a time-shift buffer).</td></tr>
<tr><td class="dae-method-table-argument">duration</td><td>The duration of the recording in seconds. </td></tr>
<tr><td class="dae-method-table-argument">repeatDays</td><td><p>Bitfield indicating which days of the week the recording SHOULD be repeated. Values are as follows:</p>
<table class="dae-api-left-values-table">
<tr><th>Day</th><th>Bitfield Value</th></tr>
<tr><td>Sunday</td><td>0x01 (i.e. 00000001)</td></tr>
<tr><td>Monday</td><td>0x02 (i.e. 00000010)</td></tr>
<tr><td>Tuesday</td><td>0x04 (i.e. 00000100)</td></tr>
<tr><td>Wednesday</td><td>0x08 (i.e. 00001000)</td></tr>
<tr><td>Thursday</td><td>0x10 (i.e. 00010000)</td></tr>
<tr><td>Friday</td><td>0x20 (i.e. 00100000)</td></tr>
<tr><td>Saturday</td><td>0x40 (i.e. 01000000)</td></tr>
</table>
<p>These bitfield values can be 'OR'-ed together to repeat a recording on more than one day of a week (e.g. weekdays) </p>
<p>A value of 0x00 indicates that the recording will not be repeated.</p>
</td></tr>
<tr><td class="dae-method-table-argument">channelID</td><td>The identifier of the channel from which the broadcasted content is to be recorded. Specifies either a ccid or ipBroadcastID (as defined by the <a href="#channel-class" class="apiRef">Channel</a> object in section <a href="#channel-class" class="sectionRef"></a>) </td></tr>
</table>

<table class="dae-method-table" id="oipfrecordingscheduler-getscheduledrecordings">
<tr><td colspan="2" class="api-signature"><a href="#scheduledrecordingcollection-class" class="apiRef">ScheduledRecordingCollection</a> <b>getScheduledRecordings</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">
<p>Returns a subset of all the recordings that are scheduled but which have not yet started. The subset SHALL include only scheduled recordings that were scheduled using a service from the same FQDN as the domain of the service that calls the method.</p></td></tr>
</table>

<table class="dae-method-table" id="oipfrecordingscheduler-getchannelconfig">
<tr><td colspan="2" class="api-signature"><a href="#channelconfig-class" class="apiRef">ChannelConfig</a> <b>getChannelConfig</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">
<p>Returns the channel line-up of the OITF in the form of a <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> object as defined in section <a href="#channelconfig-class" class="sectionRef"></a>. The <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> object returned from this function SHALL be identical to the <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> object returned from the <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a> method on the <a href="#video-broadcast" class="apiRef">video/broadcast</a> object as defined in section <a href="#video-broadcast-methods" class="sectionRef"></a></p></td></tr>
</table>

<table class="dae-method-table" id="oipfrecordingscheduler-remove">
<tr><td colspan="3" class="api-signature">void <b>remove</b>( <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> recording )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">
<p>Remove a recording (either scheduled, in-progress or completed).</p>
<p>For non-privileged applications, recordings SHALL only be removed when they are scheduled but not yet started and the recording was scheduled by the current service.</p>
<p>As with the <a href="#oipfrecordingscheduler-record" class="apiRef">record()</a> method, only the <a href="#programme-programmeid" class="apiRef">programmeID</a> property of the scheduled recording SHALL be used to identify the scheduled recording to remove where this property is available. The other data contained in the scheduled recording SHALL NOT be used when removing a recording scheduled using methods other than <a href="#oipfrecordingscheduler-recordat" class="apiRef">recordAt()</a>. For recordings scheduled using <a href="#oipfrecordingscheduler-recordat" class="apiRef">recordAt()</a>, the data used to identify the recording to remove is implementation dependent.</p>
<p>If the <a href="#programme-programmeidtype" class="apiRef">programmeIDType</a> property has the value <a href="#programme-constants" class="apiRef">ID_TVA_GROUP_CRID</a> then the OITF SHALL cancel the recording of the specified group.</p>
<p>If an A/V Control object is presenting the indicated recording then the state of the A/V Control object SHALL be automatically changed to 6 (the error state).</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">recording</td><td>The scheduled recording to be removed.</td></tr>
</table>


<table class="dae-method-table" id="oipfrecordingscheduler-createprogrammeobject">
<tr><td colspan="2" class="api-signature"><a href="#programme-class" class="apiRef">Programme</a> <b>createProgrammeObject</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">
<p>Factory method to create an instance of <a href="#programme-class" class="apiRef">Programme</a>.</p></td></tr>
</table>
</section>
</section>

<section id="scheduledrecording-class">
<h3>The ScheduledRecording class</h3>
<p>The <code>ScheduledRecording</code> object represents a scheduled programme in the system, i.e. a recording that is scheduled but which has not yet started. For group recordings (e.g. recording an entire series), a <code>ScheduledRecording</code> object is also used to represent a &ldquo;parent&rdquo; recording that enables management of the group recording without representing any of the actual recordings in the group. The values of the properties of a <code>ScheduledRecording</code> (except for <a href="#scheduledrecording-startpadding" class="apiRef">startPadding</a> and <a href="#scheduledrecording-endpadding" class="apiRef">endPadding</a>) are provided when the object is created using one of the <a href="#oipfrecordingscheduler-record" class="apiRef">record()</a> methods in section <a href="#application-oipfrecordingscheduler" class="sectionRef"></a>, for example by using a corresponding <a href="#programme-class" class="apiRef">Programme</a> object as argument for the <a href="#oipfrecordingscheduler-record" class="apiRef">record()</a> method, and can not be changed for this scheduled recording object (except for <a href="#scheduledrecording-startpadding" class="apiRef">startPadding</a> and <a href="#scheduledrecording-endpadding" class="apiRef">endPadding</a>).</p>
<section id="scheduledrecording-constants">
<h4>Constants</h4>
<p>The following table lists the constants for recording states.</p>
<table class="dae-constant-table-novalue">
<tr><th>Name</th><th>Use</th></tr>
<tr><td id="RECORDING_SCHEDULED">RECORDING_SCHEDULED</td><td>Recording has been newly scheduled.</td></tr>
<tr><td id="RECORDING_REC_STARTED">RECORDING_REC_STARTED</td><td>Recording has started.</td></tr>
<tr><td id="RECORDING_REC_COMPLETED">RECORDING_REC_COMPLETED</td><td>Recording has successfully completed.</td></tr>
<tr><td id="RECORDING_REC_PARTIALLY_COMPLETED">RECORDING_REC_PARTIALLY_COMPLETED</td><td><p>The recording has only partially completed due to insufficient storage space, a clash or hardware failure.</p><p>There are three possible conditions for this:</p><ol>
<li>The end of the recording is missed.
<li>The start of the recording is missed.
<li>A piece from the centre of the recording is missed (e.g. due to the receiver rebooting or a transient failure of the network connection).</ol>
</td></tr>
<tr><td id="RECORDING_ERROR">RECORDING_ERROR</td><td>An error has been encountered. Refer to detailed error codes for details on the error.</td></tr>
</table>

<p>This specification does not define values for these constants. Implementations may use any values as long as the value of each constant is unique. </p>
<p>The following table lists the constants for detailed error codes when a recording failed to complete.</p>
<table class="dae-constant-table-novalue">
<tr><th>Name</th><th>Use</th></tr>
<tr><td id="ERROR_REC_RESOURCE_LIMITATION">ERROR_REC_RESOURCE_LIMITATION</td><td>The recording sub-system is unable to record due to resource limitations.</td></tr>
<tr><td id="ERROR_INSUFFICIENT_STORAGE">ERROR_INSUFFICIENT_STORAGE</td><td>There is insufficient storage space available. (Some of the recording may be available).</td></tr>
<tr><td id="ERROR_REC_UNKNOWN">ERROR_REC_UNKNOWN</td><td>Recording has stopped before completion due to unknown (probably hardware) failure.</td></tr>
</table>

<p>This specification does not define values for these constants. Implementations may use any values as long as the value of each constant is unique. </p>
<p>The following table lists the constants for programme ID types.</p>
<table class="dae-constant-table">
<tr><th>Name</th><th>Value</th><th>Use</th></tr>
<tr><td>ID_TVA_CRID</td><td>0</td><td>Used in the <a href="#programme-programmeidtype" class="apiRef">programmeIDType</a> property to indicate that the programme is identified by its TV-Anytime CRID (Content Reference Identifier).</td></tr>
<tr><td>ID_DVB_EVENT</td><td>1</td><td>Used in the <a href="#programme-programmeidtype" class="apiRef">programmeIDType</a> property to indicate that the programme is identified by a DVB URL referencing a DVB-SI event as enabled by <a href="volume3.html#event-information-tables" class="extRef">section 4.1.3</a> of [[.OIPF_META2]]. Support for this constant is OPTIONAL.</td></tr>
<tr><td>ID_TVA_GROUP_CRID</td><td>2</td><td>Used in the <a href="#programme-programmeidtype" class="apiRef">programmeIDType</a> property to indicate that the Programme object represents a group of programmes identified by a TV-Anytime group CRID.</td></tr>
</table>

</section>
<section id="scheduledrecording-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="scheduledrecording-state">
<tr><td class="api-signature">readonly Integer <b>state</b></td></tr>
<tr><td>The state of the recording. Valid values are:<ul class="allowed-values-list">
<li><a href="#RECORDING_REC_STARTED" class="apiRef">RECORDING_REC_STARTED</a>
<li><a href="#RECORDING_REC_COMPLETED" class="apiRef">RECORDING_REC_COMPLETED</a>
<li><a href="#RECORDING_REC_PARTIALLY_COMPLETED" class="apiRef">RECORDING_REC_PARTIALLY_COMPLETED</a>
<li><a href="#RECORDING_SCHEDULED" class="apiRef">RECORDING_SCHEDULED</a>
<li><a href="#RECORDING_ERROR" class="apiRef">RECORDING_ERROR</a>
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="scheduledrecording-error">
<tr><td class="api-signature">readonly Integer <b>error</b></td></tr>
<tr><td>If the state of the recording has changed due to an error, this field contains an error code detailing the type of error.  This is only valid if the value of the <a href="#scheduledrecording-state" class="apiRef">state</a> argument is <a href="#RECORDING_ERROR" class="apiRef">RECORDING_ERROR</a> or <a href="#RECORDING_REC_PARTIALLY_COMPLETED" class="apiRef">RECORDING_REC_PARTIALLY_COMPLETED</a> otherwise this property SHALL be <code>null</code>. Valid values are:<ul class="allowed-values-list">
<li><a href="#ERROR_REC_RESOURCE_LIMITATION" class="apiRef">ERROR_REC_RESOURCE_LIMITATION</a>
<li><a href="#ERROR_INSUFFICIENT_STORAGE" class="apiRef">ERROR_INSUFFICIENT_STORAGE</a>
<li><a href="#ERROR_REC_UNKNOWN" class="apiRef">ERROR_REC_UNKNOWN</a>
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="scheduledrecording-scheduleid">
<tr><td class="api-signature">readonly String <b>scheduleID</b></td></tr>
<tr><td>An identifier for this scheduled recording. This value SHALL be unique to this scheduled recording. For a recording object this identifier can be used to associate which scheduled recording object this recording was created from.</td></tr>
</table>

<table class="dae-property-table" id="scheduledrecording-customid">
<tr><td class="api-signature">readonly String <b>customID</b></td></tr>
<tr><td>An identifier for this scheduled recording. This value is an identifier that the DAE application can set in order to keep track of scheduled recordings. It is not changed by the OITF.</td></tr>
</table>

<table class="dae-property-table" id="scheduledrecording-startpadding">
<tr><td class="api-signature">Integer <b>startPadding</b></td></tr>
<tr><td><p>The amount of padding to add at the start of a scheduled recording, in seconds. If the value of this property is <code>undefined</code>, an OITF defined start padding will be used. The default OITF defined start padding MAY be changed through property <a href="#pvrstartpadding" class="apiRef">pvrStartPadding</a> of the <a href="#configuration-class" class="apiRef">Configuration</a> class as defined in section <a href="#configuration-class" class="sectionRef"></a>. When a recording is due to start, the OITF MAY use a smaller amount of padding in order to avoid conflicts with other recordings.</p>
<p>Positive values of this property SHALL cause the recording to start earlier than the specified start time (i.e. the actual duration of the recording shall be increased); negative values SHALL cause the recording to start later than the specified start time (i.e. the actual duration of the recording shall be decreased).</p>
</td></tr>
</table>

<table class="dae-property-table" id="scheduledrecording-endpadding">
<tr><td class="api-signature">Integer <b>endPadding</b></td></tr>
<tr><td><p>The amount of padding to add at the end of a scheduled recording, in seconds. If the value of this property is <code>undefined</code>, an OITF defined end padding will be used. The default OITF defined end padding MAY be changed through property <a href="#pvrendpadding" class="apiRef">pvrEndPadding</a> of the <a href="#configuration-class" class="apiRef">Configuration</a> class as defined in section <a href="#configuration-class" class="sectionRef"></a>. When a recording is in progress, the OITF MAY use a smaller amount of padding in order to avoid conflicts with other recordings.</p>
<p>Positive values of this property SHALL cause the recording to end later than the specified end time (i.e. the actual duration of the recording shall be increased); negative values SHALL cause the recording to end earlier than the specified end time (i.e. the actual duration of the recording shall be decreased).</p>
</td></tr>
</table>

<table class="dae-property-table" id="scheduledrecording-repeatdays">
<tr><td class="api-signature">readonly Integer <b>repeatDays</b></td></tr>
<tr><td><p>Bitfield indicating which days of the week the recording SHOULD be repeated. Values are as follows:</p>
<table class="dae-api-left-values-table">
<tr><th>Day</th><th>Bitfield Value</th></tr>
<tr><td>Sunday</td><td>0x01 (i.e. 00000001)</td></tr>
<tr><td>Monday</td><td>0x02 (i.e. 00000010)</td></tr>
<tr><td>Tuesday</td><td>0x04 (i.e. 00000100)</td></tr>
<tr><td>Wednesday</td><td>0x08 (i.e. 00001000)</td></tr>
<tr><td>Thursday</td><td>0x10 (i.e. 00010000)</td></tr>
<tr><td>Friday</td><td>0x20 (i.e. 00100000)</td></tr>
<tr><td>Saturday</td><td>0x40 (i.e. 01000000)</td></tr>
</table>
<p>These bitfield values can be arithmetically summed to repeat a recording on more than one day of a week (e.g. weekdays)</p><p>A value of 0x00 indicates that the recording will not be repeated.</p>
</td></tr>
</table>

<table class="dae-property-table" id="scheduledrecording-name">
<tr><td class="api-signature">String <b>name</b></td></tr>
<tr><td>The short name of the scheduled recording, e.g. 'Star Trek: DS9'.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-longname">
<tr><td class="api-signature">String <b>longName</b></td></tr>
<tr><td>The long name of the scheduled recording, e.g. 'Star Trek: Deep Space Nine'. If the long name is not available, this property will be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-description">
<tr><td class="api-signature">String <b>description</b></td></tr>
<tr><td>The description of the scheduled recording, e.g. an episode synopsis. If no description is available, this property will be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-longdescription">
<tr><td class="api-signature">String <b>longDescription</b></td></tr>
<tr><td>The long description of the programme. If no description is available, this property will be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-starttime">
<tr><td class="api-signature">readonly Integer <b>startTime</b></td></tr>
<tr><td>The start time of the scheduled recording, measured in seconds since midnight (GMT) on 1/1/1970. The value for the <a href="#scheduledrecording-startpadding" class="apiRef">startPadding</a> property can be used to indicate if the recording has to be started before the <a href="#programme-starttime" class="apiRef">startTime</a> (as defined by the <a href="#programme-class" class="apiRef">Programme</a> class).</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-duration">
<tr><td class="api-signature">readonly Integer <b>duration</b></td></tr>
<tr><td>The duration of the scheduled recording (in seconds). The value for the <a href="#scheduledrecording-endpadding" class="apiRef">endPadding</a> property can be used to indicate how long the recording has to be continued after the specified duration of the recording.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-channel">
<tr><td class="api-signature">readonly <a href="#channel-class" class="apiRef">Channel</a> <b>channel</b></td></tr>
<tr><td>Reference to the broadcast channel where the scheduled programme is available.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-ismanual">
<tr><td class="api-signature">readonly Boolean <b>isManual</b></td></tr>
<tr><td><p><code>true</code> if the recording was scheduled using <a href="#oipfrecordingscheduler-recordat" class="apiRef">oipfRecordingScheduler.recordAt()</a> or using a terminal-specific approach that does not use guide data to determine what to record, <code>false</code> otherwise.</p>
<p>If <code>false</code>, then any fields whose name matches a field in the <a href="#programme-class" class="apiRef">Programme</a> object contains details from the programme guide on the programme that has been recorded. If <code>true</code>, only the <a href="#scheduledrecording-channel" class="apiRef">channel</a>, <a href="#scheduledrecording-starttime" class="apiRef">startTime</a> and <a href="#scheduledrecording-duration" class="apiRef">duration</a> properties are required to be valid.</p>
</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-programmeid">
<tr><td class="api-signature">readonly String <b>programmeID</b></td></tr>
<tr><td>The unique identifier of the scheduled programme or series, e.g. a TV-Anytime CRID (Content Reference Identifier). For recordings scheduled using the <a href="#oipfrecordingscheduler-recordat" class="apiRef">oipfRecordingScheduler.recordAt()</a> method, the value of this property MAY be <code>undefined</code>.
</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-programmeidtype">
<tr><td class="api-signature">readonly Integer <b>programmeIDType</b></td></tr>
<tr><td>The type of identification used to reference the programme, as indicated by one of the ID_* constants defined  in section <a href="#scheduledrecording-constants" class="sectionRef"></a>. For recordings scheduled using the <a href="#oipfrecordingscheduler-recordat" class="apiRef">oipfRecordingScheduler.recordAt()</a> method, the value of this property MAY be <code>undefined</code>.
</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-episode">
<tr><td class="api-signature">readonly Integer <b>episode</b></td></tr>
<tr><td>The episode number for the programme if it is part of a series. This property is <code>undefined</code> when the programme is not part of a series or the information is not available.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-totalepisodes">
<tr><td class="api-signature">readonly Integer <b>totalEpisodes</b></td></tr>
<tr><td>If the programme is part of a series, the total number of episodes in the series. This property is <code>undefined</code> when the programme is not part of a series or the information is not available.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-parentalratings">
<tr><td class="api-signature">readonly <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> <b>parentalRatings</b></td></tr>
<tr><td><p>A collection of parental rating values for the programme for zero or more parental rating schemes supported by the OITF. The value of this property is typically provided by a corresponding &ldquo;<a href="#programme-class" class="apiRef">Programme</a>&rdquo; object that is used to schedule the recording and can not be changed for this scheduled recording object. If no parental rating information is available for this scheduled recording, this property is a <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> object (as defined in section <a href="#parentalratingcollection-class" class="sectionRef"></a>) with length 0.</p>
<p>Note that if the <code>parentalRatings</code> property contains a certain parental rating (e.g.  PG-13) and the broadcast channel associated with this scheduled recording has metadata that says that the content is rated PG-16, then the conflict resolution is implementation dependent.</p>
<p>Note that this property was formerly called &ldquo;parentalRating&rdquo; (singular not plural).</p></td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-custommetadata">
<tr><td class="api-signature">String <b>customMetadata</b></td></tr>
<tr><td><p>Application-specific information for this recording. This value is information that the DAE application can set in order to retain additional information on this scheduled recording. It is not changed by the OITF. </p>
<p>The OITF SHALL support values up to and including 16 K Bytes in size. Strings longer than this MAY get truncated.</p></td></tr>
</table>
</section>
</section>

<section id="scheduledrecordingcollection-class">
<h3>The ScheduledRecordingCollection class</h3>
<pre>
typedef Collection&lt;<a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a>&gt; ScheduledRecordingCollection
</pre>
<p>The <code>ScheduledRecordingCollection</code> class represents a collection of <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a>&gt; objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.</p>
</section>

<section id="application-oipfrecordingscheduler-control-extension">
<h3>Extension to application/oipfRecordingScheduler for control of recordings</h3>
<p>The OITF SHALL support the following extensions to the <a href="#application-oipfrecordingscheduler" class="apiRef">application/oipfRecordingScheduler</a> object defined in section <a href="#application-oipfrecordingscheduler" class="sectionRef"></a>.<p>
<p>This subsection SHALL apply for OITFs that have indicated support for the extended PVR management functionality by adding the attribute '<code>manageRecordings = true</code>' to the <code>&lt;recording&gt;</code> element in the client capability description as defined in section <a href="#pvr-capability" class="sectionRef"></a>.</p>
<p>The functionality as described in this section is subject to the security model of section <a href="#dae-security" class="sectionRef"></a>.
<section id="scheduledrecording-control-extension-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="scheduledrecording-control-extension-recordings">
<tr><td class="api-signature">readonly <a href="#scheduledrecordingcollection-class" class="apiRef">ScheduledRecordingCollection</a> <b>recordings</b></td></tr>
<tr><td>Provides a list of scheduled and recorded programmes in the system. This property may only provide access to a subset of the full list of recordings, as determined by the value of the <code>manageRecordings</code> attribute of the <code>&lt;recording&gt;</code> element in the client capability description (see section <a href="#pvr-capability" class="sectionRef"></a>).</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-control-extension-discinfo">
<tr><td class="api-signature">readonly <a href="#discinfo-class" class="apiRef">DiscInfo</a> <b>discInfo</b></td></tr>
<tr><td>Get information about the status of the local storage device. The <a href="#discinfo-class" class="apiRef">DiscInfo</a> class is defined in section <a href="#discinfo-class" class="sectionRef"></a>.</td></tr>
</table>
<table class="dae-property-table" id="scheduledrecording-control-extension-onpvrevent">
<tr><td class="api-signature">function <b>onPVREvent</b>( Integer state, <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> recording )</td></tr>
<tr><td>This function is the DOM 0 event handler for notification of changes in the state of recordings. The specified function is called with the following arguments:<ul>
<li><code>Integer state</code> &mdash; The current state of the recording. One of:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>The recording has started.</td></tr>
<tr><td>2</td><td>The recording has stopped, having completed.</td></tr>
<tr><td>3</td><td>The recording sub-system is unable to record due to resource limitations.</td></tr>
<tr><td>4</td><td>There is insufficient storage space available. (Some of the recording may be available).</td></tr>
<tr><td>6</td><td>The recording has stopped before completion due to unknown (probably hardware) failure.</td></tr>
<tr><td>7</td><td>The recording has been newly scheduled.</td></tr>
<tr><td>8</td><td>The recording has been deleted (for complete or in-progress recordings) or removed from the schedule (for scheduled recordings).</td></tr>
<tr><td>9</td><td>The recording is due to start in a short time.</td></tr>
<tr><td>10</td><td>The recording has been updated. For performance reasons, OITFs SHOULD NOT dispatch events with the state when only the duration of an in-progress recording has changed.</td></tr>
</table>
<li><code><a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> recording</code> &mdash; The recording to which this event refers.
</ul>
</td></tr>
</table>
</section>
<section id="scheduledrecording-control-extension-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="scheduledrecording-control-extension-getrecording">
<tr><td colspan="3" class="api-signature"><a href="#recording-class" class="apiRef">Recording</a> <b>getRecording</b>( String id )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Returns the <a href="#recording-class" class="apiRef">Recording</a> object for which the value of the <a href="#recording-id" class="apiRef">Recording.id</a> property corresponds to the given <code>id</code> parameter. If such a <a href="#recording-class" class="apiRef">Recording</a> does not exist, the method returns <code>null</code>.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">id</td><td>Identifier corresponding to the <a href="#recording-id" class="apiRef">id</a> property of a <a href="#recording-class" class="apiRef">Recording</a> object.</td></tr>
</table>

<table class="dae-method-table" id="scheduledrecording-control-extension-stop">
<tr><td colspan="3" class="api-signature">void <b>stop</b>( <a href="#recording-class" class="apiRef">Recording</a> )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Stop an in-progress recording. The recording SHALL NOT be deleted.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">recording</td><td>The recording to be stopped.</td></tr>
</table>

<table class="dae-method-table" id="scheduledrecording-control-extensiont-refresh">
<tr><td colspan="2" class="api-signature">void <b>refresh</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Update the <a href="#scheduledrecording-control-extension-recordings" class="apiRef">recordings</a> property to show the current status of all recordings.</td></tr>
</table>

<table class="dae-method-table" id="scheduledrecording-control-extension-update">
<tr><td colspan="3" class="api-signature">Boolean <b>update</b>( String id, Integer startTime, Integer duration, Integer repeatDays )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Requests the scheduler to update a scheduled or ongoing recording. </p>
<p>For scheduled recordings the properties <a href="#scheduledrecording-starttime" class="apiRef">startTime</a>, <a href="#scheduledrecording-duration" class="apiRef">duration</a> and <a href="#scheduledrecording-repeatdays" class="apiRef">repeatDays</a> can be modified. </p>
<p>For ongoing recordings only the <a href="#scheduledrecording-duration" class="apiRef">duration</a> property may be modified. </p>
<p>This method SHALL return true if the operation succeeded, or false if for any reason it rescheduling is not possible (e.g. the updated recording overlaps with another scheduled recording and there are insufficient system resources to do both).</p>
<p>If the method returns false then no changes SHALL be made to the recording.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="4">Arguments</td>
<td class="dae-method-table-argument">id</td><td>The id of the recording to update.</td></tr>
<tr><td class="dae-method-table-argument">startTime</td><td>The new start time of the recording, or <code>undefined</code> if the start time is not to be updated.</td></tr>
<tr><td class="dae-method-table-argument">duration</td><td>The new duration of the recording, or <code>undefined</code> if the duration is not to be updated.</td></tr>
<tr><td class="dae-method-table-argument">repeatDays</td><td>The new set of days on which the recording is to be repeated, or <code>undefined</code> if this is not to be updated.</td></tr>
</table>
</section>
<section id="scheduledrecording-control-extension-events">
<h4>Events</h4>
<p>For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:</p>
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#scheduledrecording-control-extension-onpvrevent" class="apiRef">onPVREvent</a></td><td>PVREvent</td><td>Bubbles: No<br />Cancellable: No <br />Context Info: <code>state</code>, <code>recording</code></td></tr>
</table>
<p>Note: the DOM events are directly dispatched to the event target, and will not bubble nor capture. Remote UIs SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Remote UIs that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <a href="#application-oipfrecordingscheduler" class="apiRef">application/oipfRecordingScheduler</a> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>
</section>

<section id="recording-class">
<h3>The Recording class</h3>
<p>The <code>Recording</code> class represents an in-progress or completed recording being made available through the extended PVR management functionality as defined in section <a href="#application-oipfrecordingscheduler-control-extension" class="sectionRef"></a>. Recordings for which no data has yet been recorded are represented by the <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> class. </p>
<p>This class implements the <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> interface (see section <a href="#scheduledrecording-class" class="sectionRef"></a>) to provide access to the information  relating to the scheduling of the recording. The difference between scheduled recordings, in-progress recordings and completed recordings is primarily what properties are populated with values. In addition, for recorded and in-progress recordings the following is true:</p><ul>
<li>The <a href="#scheduledrecording-startpadding" class="apiRef">startPadding</a> property is read only.
<li>For in-progress recordings, changes to the value of the <a href="#scheduledrecording-endpadding" class="apiRef">endPadding</a> property SHALL modify the actual duration of the recording.  If the value of the <a href="#scheduledrecording-endpadding" class="apiRef">endPadding</a> property is changed so that the current actual duration of the recording exceeds the new actual duration specified by the sum of the <a href="#scheduledrecording-startpadding" class="apiRef">startPadding</a>, <a href="#scheduledrecording-duration" class="apiRef">duration</a> and <a href="#scheduledrecording-endpadding" class="apiRef">endPadding</a> properties, the recording SHALL be stopped immediately.  Changing the value of this property for a completed recording SHALL have no effect.
</ul>
<p>Recordings MAY be &ldquo;manual&rdquo; in that they simply record a channel at a certain time, for a period - analogous to a traditional VCR - or alternatively recordings can be programme based.</p>
<p>If an in-progress recording is interrupted and automatically resumed, e.g. due to a temporary power failure, all sections of the recording SHALL be represented by a single <code>Recording</code> object.</p>
<p>Values of properties in the <code>Recording</code> object SHALL be obtained from metadata about the recorded programme and are typically copied from the <a href="#programme-class" class="apiRef">Programme</a> used for scheduling a recording by the <a href="#oipfrecordingscheduler-record" class="apiRef">record(Programme programme)</a> method of the <a href="#application-oipfrecordingscheduler" class="apiRef">application/oipfRecordingScheduler object</a>. See section <a href="#application-oipfrecordingscheduler-control-extension" class="sectionRef"></a> for more information about the mapping between the properties of a <a href="#programme-class" class="apiRef">Programme</a> and the BCG metadata. In the event of a conflict between the metadata in the Programme and that in the broadcast channel, the conflict resolution is implementation dependent.</p>
<p>NOTE: The property <code>parentalRatings</code> formerly defined as part of this class is now redundant following the renaming of the <code>parentalRating</code> property in the <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> class to <a href="#scheduledrecording-parentalratings" class="apiRef">parentalRatings</a>.
<section id="recording-properties">
<h4>Properties</h4>
<p>NOTE: The properties <code>state</code> and <code>isManual</code> formerly defined in this class are now defined in the <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> class, and since the <code>Recording</code> class inherits from the <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> class they are still part of the <code>Recording</code> class.</p>
<table class="dae-property-table" id="recording-uri">
<tr><td class="api-signature">readonly String <b>uri</b></td></tr>
<tr><td>A uri identifying the content item in local storage according to [[!RFC3986]]. The format of the URI is outside the scope of this specification except that;<ul>
<li>the scheme SHALL NOT be one that is included in this specification
<li>the URI SHALL NOT include a fragment
</ul></td></tr>
</table>
<table class="dae-property-table" id="recording-id">
<tr><td class="api-signature">readonly String <b>id</b></td></tr>
<tr><td>An identifier for this recording. This value SHALL be unique to this recording and so can be used to compare two recording objects to see if they refer to the same recording. The OITF SHALL guarantee that recording identifiers are unique in relation to download identifiers and <a href="#codasset-class" class="apiRef">CODAsset</a> identifiers.</td></tr>
</table>
<table class="dae-property-table" id="recording-donotdelete">
<tr><td class="api-signature">Boolean <b>doNotDelete</b></td></tr>
<tr><td>If <code>true</code>, then this recording should not be automatically deleted by the system.</td></tr>
</table>
<table class="dae-property-table" id="recording-savedays">
<tr><td class="api-signature">Integer <b>saveDays</b></td></tr>
<tr><td>The number of days for which an individual or manual recording SHOULD be saved.  Recordings older than this value MAY be deleted. If the value of this property is <code>undefined</code>, the default save duration SHALL be used.</td></tr>
</table>
<table class="dae-property-table" id="recording-saveepisodes">
<tr><td class="api-signature">Integer <b>saveEpisodes</b></td></tr>
<tr><td>TThe number of episodes of a series-link that SHOULD be saved.  Older episodes MAY be deleted.  This is only valid when set on the latest scheduled recording in the series. If the value of this property is <code>undefined</code>, the default value SHALL be used.</td></tr>
</table>
<table class="dae-property-table" id="recording-blocked">
<tr><td class="api-signature">readonly Boolean <b>blocked</b></td></tr>
<tr><td><p>Flag indicating whether the programme is blocked due to parental control settings or conditional access restrictions.</p>
<p>The <code>blocked</code> and <a href="#recording-locked" class="apiRef">locked</a> properties work together to provide a tri-state flag describing the status of a programme.  This can best be described  by the following table:</p>
<table class="dae-api-left-values-table">
<tr><th>Description</th><th>blocked</th><th>locked</th></tr>
<tr><td>No parental control applies.</td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td>Item is above the parental rating threshold (or manually blocked); no PIN has been entered to view it and so the item cannot currently be viewed.</td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td>Item is above the parental rating threshold (or manually blocked); the PIN has been entered and so the item can be viewed.</td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td>Invalid combination &mdash; OITFs SHALL NOT support this combination</td><td><code>false</code></td><td><code>true</code></td></tr>
</table>
</td></tr>
</table>
<table class="dae-property-table" id="recording-showtype">
<tr><td class="api-signature">readonly Integer <b>showType</b></td></tr>
<tr><td><p>Flag indicating the type of show. This field SHALL take one of the following values: </p>
<table class="dae-api-left-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>The show is live.</td></tr>
<tr><td>1</td><td>The show is a first-run show.</td></tr>
<tr><td>2</td><td>The show is a rerun.</td></tr>
</table>
</td></tr>
</table>
<table class="dae-property-table" id="recording-subtitles">
<tr><td class="api-signature">readonly Boolean <b>subtitles</b></td></tr>
<tr><td>Flag indicating whether subtitles or closed-caption information is available.</td></tr>
</table>
<table class="dae-property-table" id="recording-subtitlelanguages">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>subtitleLanguages</b></td></tr>
<tr><td>Supported subtitle languages, indicated by their  ISO 639-2 language codes as defined in [[!ISO639-2]].</td></tr>
</table>
<table class="dae-property-table" id="recording-ishd">
<tr><td class="api-signature">readonly Boolean <b>isHD</b></td></tr>
<tr><td>Flag indicating whether the programme has high-definition video.</td></tr>
</table>
<table class="dae-property-table" id="recording-is3d">
<tr><td class="api-signature">readonly Boolean <b>is3D</b></td></tr>
<tr><td>Flag indicating whether the programme has 3D video.</td></tr>
</table>
<table class="dae-property-table" id="recording-audioType">
<tr><td class="api-signature">readonly Integer <b>audioType</b></td></tr>
<tr><td>Bitfield indicating the type of audio that is available for the programme. Since more than one type of audio may be available for a given programme, the value of this field SHALL consist of one or more of the following values ORed together:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Desccription</th></tr>
<tr><td>1</td><td>Mono audio</td></tr>
<tr><td>2</td><td>Stereo audio</td></tr>
<tr><td>4</td><td>Multi-channel audio</td></tr>
</table>
</td></tr>
</table>
<table class="dae-property-table" id="recording-ismultilingual">
<tr><td class="api-signature">readonly Boolean <b>isMultilingual</b></td></tr>
<tr><td>Flag indicating whether more than one audio language is available for this recording.</td></tr>
</table>
<table class="dae-property-table" id="recording-audiolanguages">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>audioLanguages</b></td></tr>
<tr><td>Supported audio languages, indicated by their ISO 639-2 language codes as defined in [[!ISO639-2]].</td></tr>
</table>
<table class="dae-property-table" id="recording-genres">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>genres</b></td></tr>
<tr><td>A collection of genres that describe this programme.</td></tr>
</table>
<table class="dae-property-table" id="recording-recordingstarttime">
<tr><td class="api-signature">readonly Integer <b>recordingStartTime</b></td></tr>
<tr><td>The actual start time of the recording, including any padding, measured in seconds since midnight (GMT) on 1/1/1970. This MAY not be the same as the scheduled start time of the recorded programme (e.g. due to a recording starting late, or due to start/end padding).  For recordings that have not yet started, the value of this field SHALL be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="recording-recordingduration">
<tr><td class="api-signature">readonly Integer <b>recordingDuration</b></td></tr>
<tr><td>The actual duration of the recording, including any padding, measured in seconds. This MAY not be the same as the scheduled duration of the recording (e.g. due to a recording finishing early, or due to start/end padding). For recordings that have not yet started, the value of this field SHALL be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="recording-bookmarks">
<tr><td class="api-signature">readonly <a href="#bookmarkcollection-class" class="apiRef">Bookmarks</a> <b>bookmarks</b></td></tr>
<tr><td>A collection of the bookmarks set in a recording. If no bookmarks are set, the collection SHALL be empty.</td></tr>
</table>
<table class="dae-property-table" id="recording-locked">
<tr><td class="api-signature">readonly Boolean <b>locked</b></td></tr>
<tr><td>Flag indicating whether the current state of the parental control system prevents the recording from being viewed (e.g. a correct parental control PIN has not been entered to allow the recording to be viewed).</td></tr>
</table>
</section>
</section>

<section id="recordingcollection-class">
<h3>The RecordingCollection class</h3>
<p>This section is intentionally left empty.</p>
</section>

<section id="pvrevent-class">
<h3>The PVREvent class</h3>
<p>This section is intentionally left empty.</p>
</section>

<section id="bookmark-class">
<h3>The Bookmark class</h3>
<p>The <code>Bookmark</code> class represents a bookmark or chapter mark in a recording or CoD asset. This is not a web bookmark &mdash; instead, it is a point from which the viewer may want to resume playback of a piece of content. These MAY be set implicitly without user intervention (e.g. at the point where a user stops watching a recording, in order to allow them to resume from that point later) or explicitly by the user (e.g. at the start of a favourite scene).  </p>
<section id="bookmark-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="bookmark-time">
<tr><td class="api-signature">readonly Integer <b>time</b></td></tr>
<tr><td>The time at which the bookmark is set, in seconds from the start of the content item.</td></tr>
</table>
<table class="dae-property-table" id="bookmark-name">
<tr><td class="api-signature">readonly Name <b>name</b></td></tr>
<tr><td>The name of the bookmark.</td></tr>
</table>
</section>
</section>
<section id="bookmarkcollection-class">
<h3>The BookmarkCollection class</h3>
<pre>
typedef Collection&lt;<a href="#bookmark-class" class="apiRef">Bookmark</a>&gt; BookmarkCollection
</pre>
<p>A <code>BookmarkCollection</code> is a collection of bookmarks, ordered by time. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template. In addition to the methods and properties defined for generic collections, the <code>BookmarkCollection</code> class supports the additional properties and methods defined below.</p>
<p>NOTE: In principle bookmarks MAY be stored on in the network however the protocol for communicating bookmarks between the OITF and the network is not defined in the present document.</p>
<section id="bookmarkcollection-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="bookmarkcollection-addbookmark">
<tr><td colspan="3" class="api-signature"><a href="#bookmark-class" class="apiRef">Bookmark</a> <b>addBookmark</b>( Integer time, String name )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Add a new bookmark to the collection. If the bookmark cannot be added (e.g. because the value given for time lies outside the length of the recording), this method SHALL return <code>null</code>.</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">time</td><td>The time at which the bookmark is set, in seconds since the start of the recording.</td></tr>
<tr><td class="dae-method-table-argument">name</td><td>The name of the bookmark.</td></tr>
</table>
<table class="dae-method-table" id="bookmarkcollection-removebookmark">
<tr><td colspan="3" class="api-signature">void <b>removeBookmark</b>( <a href="#bookmark-class" class="apiRef">Bookmark</a> bookmark )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Remove a bookmark from the collection.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">bookmark</td><td>The bookmark to be removed.</td></tr>
</table>
</section>
</section>
</section>  <!-- scheduled-recording-apis -->

<section id="remote-management-apis">
<h2>Remote Management APIs</h2>
<p>This section defines interfaces to perform remote diagnostics and management of the device. </p>
<p>Browser based remote management SHALL be supported by OITFs that have indicated <code>&lt;remote_diagnostics&gt;true&lt;/remote_diagnostics&gt;</code> in their capability profile (as defined in section <a href="#remote-diagnostics-support" class="sectionRef"></a>).</p>
<section id="application-oipfremotemanagement">
<h3>The application/oipfRemoteManagement embedded object</h3>
<p>The application/oipfRemoteManagement embedded object has the following properties and methods. </p>
<p>Access to the functionality of the application/oipfRemoteManagement embedded object SHALL adhere to the security requirements as defined in section <a href="#dae-security" class="sectionRef"></a>.</p>
<section id="application-oipfremotemanagement-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>vendorName</b></td></tr>
<tr><td>The value of this property SHALL be the same as the value of the <a href="#localsystem-vendorname" class="apiRef">LocalSystem.vendorName</a> property (see section <a href="#localsystem-properties" class="sectionRef"></a>)</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>modelName</b></td></tr>
<tr><td>The value of this property SHALL be the same as the value of the <a href="#localsystem-modelname" class="apiRef">LocalSystem.modelName</a> property (see section <a href="#localsystem-properties" class="sectionRef"></a>)</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>softwareVersion</b></td></tr>
<tr><td>The value of this property SHALL be the same as the value of the <a href="#localsystem-softwareversion" class="apiRef">LocalSystem.softwareVersion</a> property (see section <a href="#localsystem-properties" class="sectionRef"></a>)</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>hardwareVersion</b></td></tr>
<tr><td>The value of this property SHALL be the same as the value of the <a href="#localsystem-hardwareversion" class="apiRef">LocalSystem.hardwareVersion</a> property (see section <a href="#localsystem-properties" class="sectionRef"></a>)</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>familyName</b></td></tr>
<tr><td>The value of this property SHALL be the same as the value of the <a href="#localsystem-familyname" class="apiRef">LocalSystem.familyName</a> property (see section <a href="#localsystem-properties" class="sectionRef"></a>)</td></tr>
</table>
<table class="dae-property-table" id="application-oipfremotemanagement-onsoftwareupdate">
<tr><td class="api-signature">function <b>onSoftwareUpdate</b>( String updateEvent, Integer seconds, String message, String version )</td></tr>
<tr><td>The function that is called when the OITF's software update state is changed. The specified function is called with the following arguments:<ul>
<li><code>String updateEvent</code> &mdash; The event type that caused the invocation of this function. One of:
<table class="dae-api-left-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td><code>SOFTWARE_AVAILABLE</code></td><td>New software for the OITF has been found on a remote management server. The <code>message</code> argument may contain a user-centric message regarding this new software version and the <code>version</code> argument may contain the version number of the software update.</td></tr>
<tr><td><code>SOFTWARE_DOWNLOADING</code></td><td>New software for the OITF is in the process of being downloaded. The <code>version</code> argument may contain the version number of the software being downloaded. This event type may be signalled at multiple times during the download of the new software, indicating positive progress; in this case the <code>message</code> argument should contain an indication of the download progress.</td></tr>
<tr><td><code>SOFTWARE_DOWNLOAD_FAILED</code></td><td>The download of new software has failed. A descriptive reason for the failure may be found in the <code>message</code> argument and the <code>version</code> argument may contain the version number of the software that failed to be downloaded.</td></tr>
<tr><td><code>SOFTWARE_DOWNLOADED</code></td><td>A new software version of the OITF has been downloaded but has not yet been installed. Applications can now save relevant data that should survive a firmware upgrade. The actual mechanism of the download is out of scope of this specification. The <code>message</code> argument may contain a user-centric message regarding this new software version. The <code>seconds</code> argument has no significance.</td></tr>
<tr><td><code>FORCED_UPDATE</code></td><td>A new software version will shortly be installed. This event may occur if the users has not agreed to install the software but the system must have a new software version. The <code>seconds</code> argument gives the time until the OITF will install the new software.</td></tr>
</table>
<li><code>Integer seconds</code> &mdash; The time before action takes place. The meaning depends on the event type as described above.
<li><code>String message</code> &mdash; A message that may be used to inform the user about the purpose of this update to the software in order to receive the users consent to perform the actual update. <code>undefined</code> if not used.
<li><code>String version</code> &mdash; The new version number of the software identified for the update, or <code>undefined</code> if not available.
</ul></td></tr>
</table>
</section>
<section id="application-oipfremotemanagement-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="application-oipfremotemanagement-getparameter">
<tr><td colspan="3" class="api-signature">String <b>getParameter</b>( String parameterName )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Returns the requested parameter.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">parameterName</td><td>
<p>&ldquo;<code>SAMPLE_PACKET_LOSS</code>&rdquo;: This queries the RTP packet loss since the last call to this function, or the start of the current RTP content item, whichever is more recent. The returned string is of the format &ldquo;&lt;time in milliseconds since the last sample&gt; &lt;fraction lost&gt; &lt;number of packets lost&gt;&rdquo;. These fields (i.e. &lt;xxx&gt;) are defined as described in [[!RFC3550]] <a href="http://tools.ietf.org/html/rfc3550#section-6.4.2" class="extRef">section 6.4.2</a> and are decimal numbers (encoded as strings). If no content item is playing an empty string is returned.</p>
<p>&ldquo;<code>SAMPLE_DECODER_ERRORS</code>&rdquo;: This queries the decoder errors since the last call to this function, or the start of the current RTP content item, whichever is more recent. The returned string is of the format &ldquo;&lt;time in milliseconds since the sample&gt; &lt;total number of frames decoded&gt; &lt;total number of errors&gt;&rdquo;. These fields are decimal numbers (encoded as strings). If no content item is playing an empty string is returned.</p>
<p>&ldquo;<code>CUMULATIVE_PACKET_LOSS</code>&rdquo;: This queries the RTP packet loss since the start of the current RTP content item. The returned string is of the format &ldquo;&lt;time in milliseconds of this sample within the content&gt; &lt;fraction lost&gt; &lt;number of packets lost&gt;&rdquo;. These fields (i.e. &lt;xxx&gt;) are defined as described in [[!RFC3550]] <a href="http://tools.ietf.org/html/rfc3550#section-6.4.2" class="extRef">section 6.4.2</a> and are decimal numbers (encoded as strings). If no content item is playing an empty string is returned.</p>
<p>&ldquo;<code>CUMULATIVE_DECODER_ERRORS</code>&rdquo;: This queries the decoder errors since the start of the current RTP content item, whichever is more recent. The returned string is of the format &ldquo;&lt;time in milliseconds of this sample within the content&gt; &lt;total number of frames decoded&gt; &lt;total number of errors&gt;&rdquo;. These fields are decimal numbers (encoded as strings). If no content item is playing an empty string is returned.</p>
<p>Values are not case sensitive. Optionally, further vendor specific parameters may be supported.</p>
<p>In the case that a parameter is requested that a device does not support, it SHALL return an empty string.</p>
</td></tr>
</table>

<table class="dae-method-table" id="application-oipfremotemanagement-triggersoftwareupdate">
<tr><td colspan="3" class="api-signature">Integer <b>triggerSoftwareUpdate</b>( String token )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Triggers an OITF to start its software update process. The process itself and any user involvement (e.g. to confirm agreement for a software update) is not defined. The method is blocking. The process of updating the software MAY generate SoftwareUpdate events to indicate progress.</p>
<p>The returned integer is a result code that can take the following values:</p>
<table class="dae-api-values-table">
<tr><th>Result message</th><th>Description</th><th>Semantics</th></tr>
<tr><td>0</td><td>Successful</td><td>The request is successful and the device software will be updated.</td></tr>
<tr><td>1</td><td>Unknown error </td><td><code>triggerSoftwareUpdate()</code> failed because an unspecified error occurred.</td></tr>
<tr><td>2</td><td>Invalid token</td><td><code>triggerSoftwareUpdate()</code> failed because the token is not valid.</td></tr>
<tr><td>3</td><td>No update available</td><td><code>triggerSoftwareUpdate()</code> failed, because no update exists.</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">token</td><td>
An optional token string used to assist in the software update process. The token may be used to transfer credentials information to control the software update.</td></tr>
</table>
<table class="dae-method-table" id="application-oipfremotemanagement-softwareupdatestatus">
<tr><td colspan="2" class="api-signature">Integer <b>softwareUpdateStatus</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Returns the current status of any ongoing software update activity. The value returned by this function shall be:
<table class="dae-api-values-table">
<tr><th>Result message</th><th>Description</th></tr>
<tr><td>-2</td><td>No software update is in progress.</td></tr>
<tr><td>-1</td><td>New software is available to download for the OITF.</td></tr>
<tr><td>0 .. 99</td><td>New software is being downloaded to the OITF and the value gives an approximation of the amount already downloaded.</td></tr>
<tr><td>100</td><td>Indicates that new software has been successfully downloaded to the OITF and is available for installation.</td></tr>
<tr><td>1001 .. 1999</td><td>Indicates that an error occurred during the download of new software to the OITF. This range of values can be used to provide an implementation specific error code.</td></tr>
</table>
</td></tr>
</table>
</section>
<section id="application-oipfremotemanagement-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#application-oipfremotemanagement-onsoftwareupdate" class="apiRef">onSoftwareUpdate</a></td><td>SoftwareUpdate</td><td>Bubbles: No<br />Cancellable: No <br />Context Info: <code>updateEvent</code>, <code>seconds</code></td></tr>
</table>
Note: the DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Remote UIs that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <a href="#application-oipfremotemanagement" class="apiRef">application/oipfRemoteManagement</a> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>
</section>

<section id="metadata-apis">
<h2>Metadata APIs</h2>
<p>This section defines the JavaScript APIs used by DAE applications for reading and searching metadata about programmes. This API does not specify whether these query operations are carried out on the OITF or whether they require communication with a server.</p>
<p>The metadata API provides DAE applications with high-level access to metadata about programmes and channels. This document describes the mapping between this API and CoD and programme guide metadata. Mappings between this API and other metadata sources are not specified in this document.</p>
<p>This section SHALL apply for OITFs that have indicated <code>&lt;clientMetadata&gt;</code> with value &ldquo;<code>true</code>&rdquo; and a &ldquo;<code>type</code>&rdquo; attribute with value &ldquo;<code>bcg</code>&rdquo; or &ldquo;<code>dvb-si</code>&rdquo; as defined in section <a href="#OITF-metadata-api-support" class="sectionRef"></a> in their capability.</p>
<p>Note that in order to access the metadata of programmes and channels several extensions to the Programme and Channel classes have been defined when the OITF has indicated support for <code>&lt;clientMetadata&gt;</code>. See sections <a href="#programme-metadata-extensions" class="sectionRef"></a> &ldquo;<a href="#programme-metadata-extensions" class="sectionTitleRef"></a>&rdquo; and <a href="#metadata-extensions-to-channel" class="sectionRef"></a> &ldquo;<a href="#metadata-extensions-to-channel" class="sectionTitleRef"></a>&rdquo; for more information).</p>
<p>The functionality as described in this section is subject to the security model of section <a href="#dae-security" class="sectionRef"></a> (in particular section <a href="#security-requirements-for-metadata-processing" class="sectionRef"></a>).</p>

<section id="application-oipfsearchmanager">
<h3>The application/oipfSearchManager embedded object</h3>
<p>OITFs SHALL implement the &ldquo;<code>application/oipfSearchManager</code>&rdquo; embedded object. This object provides a mechanism for applications to create and manage metadata searches.</p>
<section id="application-oipfsearchmanager-properties">
<h4>Properties</h4>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>guideDaysAvailable</b></td></tr>
<tr><td>The number of days for which guide data is available.  A value of -1 means that the amount of guide data available is unknown.</td></tr>
</table>
<table class="dae-property-table" id="onmetadataupdate">
<tr><td class="api-signature">function <b>onMetadataUpdate</b>( Integer action, Integer info, Object object )</td></tr>
<tr><td><p>This function is the DOM 0 event handler for events indicating changes in metadata. This SHALL be raised under the following circumstances:</p><ol>
<li>When a new version of the metadata is discovered. Note that new versions of metadata can be made available without any of the individual items of metadata changing. It is an application's responsibility to determine what, if anything, has changed.
<li>When the values of the blocked or locked properties on a content item change due to changes in the parental control subsystem (e.g. parental control being enabled or disabled, or a content item being unlocked with a PIN).
</ol>
<p>The specified function is called with the arguments <code>action</code>, <code>info</code> and <code>object</code>. These arguments are defined as follows:</p><ul>
<li><code>Integer action</code> &mdash; the type of update that has taken place. This field will take one of the following values:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>A new version of metadata is available (see <a href="volume3.html#update-mechanism-for-bcg" class="extRef">section 4.1.2.1.2</a> of [[.OIPF_META2]]) and applications SHOULD discard all references to <a href="#programme-class" class="apiRef">Programme</a> objects immediately and re-acquire them.</td></tr>
<tr><td>2</td><td>A change to the parental control flags for a content item has occurred (e.g. the user has unlocked the parental control features of the receiver, allowing a blocked item to be played).</td></tr>
<tr><td>3</td><td>A flag affecting the filtering criteria of a channel has changed.  Applications MAY listen for events with this action code to update lists of favourite channels, for instance.</td></tr>
</table>
<li><code>Integer info</code> &mdash; extended information about the type of update that has taken place. If the <code>action</code> argument is set to the value 3, the value of this field SHALL be one or more of the following:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>The list of blocked channels has changed.</td></tr>
<tr><td>2</td><td>A list of favourite channels has changed.</td></tr>
<tr><td>4</td><td>The list of hidden channels has changed.</td></tr>
</table>
<p>If the <code>action</code> argument is set to the value 2, the value of this field SHALL be one or more of:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>The block status of a content item has changed.</td></tr>
<tr><td>2</td><td>The lock status of a content item has changed.</td></tr>
</table>
<p>This field is treated as a bitfield, so values MAY be combined to allow multiple reasons to be passed.</p>
<li><code>Object object</code> &mdash; the affected channel, programme, or CoD asset prior to the change. If more than one is affected, then this argument SHALL take the value <code>null</code>.
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="onmetadatasearch">
<tr><td class="api-signature">function <b>onMetadataSearch</b>( <a href="#metadatasearch-class" class="apiRef">MetadataSearch</a> search, Integer state )</td></tr>
<tr><td><p>This function is the DOM 0 event handler for events relating to metadata searches. The specified function is called with the arguments <code>search</code> and <code>state</code>. These arguments are defined as follows:</p><ul>
<li><code><a href="#metadatasearch-class" class="apiRef">MetadataSearch</a> search</code> &mdash; the affected search
<li><code>Integer state</code> &mdash; the new state of the search
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Search has finished. This event SHALL be generated when a search has completed.</td></tr>
<tr><td>1</td><td>This value is not used.</td></tr>
<tr><td>2</td><td>This value is not used.</td></tr>
<tr><td>3</td><td>The <a href="#metadatasearch-class" class="apiRef">MetadataSearch</a> object has returned to the idle state, either because of a call to <a href="#searchresults-abort" class="apiRef">SearchResults.abort()</a> or because the parameters for the search have been modified (e.g. the query, constraints or search target).</td></tr>
<tr><td>4</td><td>The search cannot be completed due to a lack of resources or any other reason (e.g. insufficient memory is available to cache all of the requested results).</td></tr>
</table>
</ul></td></tr>
</table>
</section>
<section id="application-oipfsearchmanager-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#onmetadatasearch" class="apiRef">onMetadataSearch</a></td><td>MetadataSearch</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>search</code>, <code>state</code></td></tr>
<tr><td><a href="#onmetadataupdate" class="apiRef">onMetadataUpdate</a></td><td>MetadataUpdate</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>action</code>, <code>info</code>, <code>object</code></td></tr>
</table>
Note: these DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>application/oipfSearchManager</code> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
<section id="application-oipfsearchmanager-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="application-oipfsearchmanager-createsearch">
<tr><td colspan="3" class="api-signature"><a href="#metadatasearch-class" class="apiRef">MetadataSearch</a> <b>createSearch</b>( Integer searchTarget )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Create a <a href="#metadatasearch-class" class="apiRef">MetadataSearch</a> object that can be used to search the metadata.
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">searchTarget</td><td>
<p>The metadata that should be searched. </p>
<p>Valid values of the <code>searchTarget</code> parameter are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>Metadata relating to scheduled content shall be searched.</td></tr>
<tr><td>2</td><td>Metadata relating to content on demand shall be searched.</td></tr>
</table>
<p>These values are treated as a bitfield, allowing searches to be carried out across multiple search targets.</p>
</td></tr>
</table>
<table class="dae-method-table" id="application-oipfsearchmanager-getchannelconfig">
<tr><td colspan="2" class="api-signature"><a href="#channelconfig-class" class="apiRef">ChannelConfig</a> <b>getChannelConfig</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Returns the channel line-up of the tuner in the form of a <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> object as defined in section <a href="#channelconfig-class" class="sectionRef"></a>. This includes the favourite lists.</p>
<p>The <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> object returned from this function SHALL be identical to the <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> object returned from the <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a> method on the <a href="#video-broadcast" class="apiRef">video/broadcast</a> object as defined in section <a href="#video-broadcast-methods" class="sectionRef"></a>.</p>
</td></tr>
</table>
</section>
<section id="metadatasearch-class">
<h3>The MetadataSearch class</h3>
<p>A <code>MetadataSearch</code> object represents a query of the metadata about available programmes. Applications can create <code>MetadataSearch</code> objects using the <a href="#application-oipfsearchmanager-createsearch" class="apiRef">createSearch()</a> method on the <a href="#application-oipfsearchmanager" class="apiRef">application/oipfSearchManager</a> object. When metadata queries are performed on a remote server, the protocol used is defined in <a href="volume3.html#SOAP-query-mechanism" class="extRef">section 4.1.2.2</a> of [[.OIPF_META2]].</p>
<p>Each search consists of three steps:</p><ol>
<li>Definition of the query.  The application creates a <code>MetadataSearch</code> object, and either creates its associated <a href="#query-class" class="apiRef">Query</a> object, or sets a query using the <a href="#findprogrammesfromstream" class="apiRef">findProgrammesFromStream()</a> method, and sets any applicable constraints and result ordering.
<li>Acquisition of results. The OITF acquires some or all of the items that match the specified query and constraints, and caches the requested subset of the results. This is typically triggered by a call to <a href="#searchresults-getresults" class="apiRef">getResults()</a>.
<li>Retrieval.  The application accesses the results via the <a href="#searchresults-class" class="apiRef">SearchResults</a> class.
</ol>
<p>The <code>MetadataSearch</code> and <a href="#searchresults-class" class="apiRef">SearchResults</a> classes work together to manage an individual search.  For every search, the <code>MetadataSearch</code> object and its corresponding <a href="#searchresults-class" class="apiRef">SearchResults</a> object SHALL be in one of three states as described in Table <a href="#metadata-search-states" class="tableRef"></a>.  Figure <a href="#metadata-search-state-machine" class="figureRef"></a> below shows the transitions between these states:</p>
<figure id="metadata-search-state-machine">
<img alt="FIGURE 13" src="images/MetadataSearchStateMachine.png" />
<figcaption>Figure ####: State machine for a metadata search (informative)</figcaption>
</figure>
<table id="metadata-search-states" class="simple">
<caption>Table ####: Metadata search states (normative)</caption>
<tr><th>State</th><th>Description</th></tr>
<tr><td style="vertical-align: top;">Idle</td><td><p>The search is idle; no results are available. This is the initial state of the search.  In this state, the application can set or modify the query, constraints or ordering rules that are applied to the search.</p>
<p>No search results are available in this state &mdash; any calls to <a href="#searchresults-item" class="apiRef">SearchResults.item()</a> SHALL return <code>undefined</code> and the values of the <a href="#searchresults-length" class="apiRef">length</a> and <a href="#searchresults-totalsize" class="apiRef">totalSize</a> properties on the <a href="#searchresults-class" class="apiRef">SearchResults</a> object SHALL return zero.  Any search results that have been cached by the terminal SHALL be  discarded when the Idle state is entered. </p>
<p>Calling the <a href="#searchresults-getresults" class="apiRef">SearchResults.getResults()</a> method SHALL cause a state transition to the Searching state.</p>
</td></tr>
<tr><td style="vertical-align: top;">Searching</td><td><p>Results are being retrieved and are not yet available to applications.</p>
<p>If the terminal has not previously cached the full set of search results, the terminal performs the search to gather the requested results.</p>
<p>If a new version of the metadata is detected (e.g. due to an EIT update) while the search is in this state, results SHALL be retrieved from either the new or original version of the metadata but SHALL NOT be retrieved from a combination of the two versions.</p>
<p>Calls to <a href="#searchresults-item" class="apiRef">SearchResults.item()</a> SHALL return <code>undefined</code>.</p>
<p>Any modification of the search parameters (e.g. changing the query or adding/removing constraints, or calling <a href="#findprogrammesfromstream" class="apiRef">findProgrammesFromStream()</a>) by the application SHALL stop the current search and cause a transition to the Idle state. The terminal SHALL dispatch a <code>MetadataSearch</code> event with <code>state</code>=3.</p>
<p>When all requested results have been found, the terminal SHALL dispatch a <code>MetadataSearch</code> event with <code>state</code>=0 and a state transition to the Found state SHALL occur.</p>
<p>If the search cannot be completed due to a lack of resources or any other reason, the terminal SHALL dispatch a <code>MetadataSearch</code> event with <code>state</code>=4 and a state transition to the Idle state SHALL occur.</p>
<p>Calls to the <a href="#searchresults-getresults" class="apiRef">SearchResults.getResults()</a> method SHALL abort the retrieval of search results and attempt to retrieve the newly-requested set of results instead. </p>
<p>NOTE: Calling <a href="#searchresults-getresults" class="apiRef">getResults()</a> when in the searching state may be used to fetch a group of items starting at a different offset or with a different count.
</p></td></tr>
<tr><td style="vertical-align: top;">Found</td><td><p>Search results are available and can be retrieved by applications. The data exposed via the <a href="#searchresults-item" class="apiRef">SearchResults.item()</a> method is static and never changes as a result of any updates to the underlying metadata database until <a href="#searchresults-getresults" class="apiRef">SearchResults.getResults()</a> is next called.</p>
<p>If a new version of the metadata is detected (e.g. due to an EIT update), a <code>MetadataUpdate</code> event is dispatched with <code>action</code>=1. Subsequent calls to <a href="#searchresults-getresults" class="apiRef">SearchResult.getResults()</a> SHALL return results based on the updated metadata.</p>
<p>Calls to <a href="#searchresults-getresults" class="apiRef">SearchResults.getResults()</a> SHALL cause a state transition to the Searching state.</p>
<p>Any modification of the search parameters (e.g. changing the query or adding/removing constraints, or calling <a href="#findprogrammesfromstream" class="apiRef">findProgrammesFromStream()</a>) by the application SHALL cause the current set of results to be discarded and SHALL cause a transition to the Idle state. The terminal SHALL dispatch a <code>MetadataSearch</code> event with <code>state</code>=3.</p></td></tr>
</table>

<p>The <a href="#findprogrammesfromstream" class="apiRef">findProgrammesFromStream()</a> method acts as a shortcut for setting a query and a set of constraints on the <a href="#metadatasearch-class" class="apiRef">MetadataSearch</a> object. Regardless of whether the query and constraints are set explicitly by the application or via <a href="#findprogrammesfromstream" class="apiRef">findProgrammesFromStream()</a>, results are retrieved using the <a href="#searchresults-getresults" class="apiRef">getResults()</a> method.</p>
<p>Changes to the search parameters (e.g. changing the query or adding/removing constraints or modifying the search target, or calling <a href="#findprogrammesfromstream" class="apiRef">findProgrammesFromStream()</a>) SHALL be applied when the <a href="#searchresults-getresults" class="apiRef">getResults()</a> method on the corresponding <a href="#searchresults-class" class="apiRef">SearchResults</a> object is called. Due to the nature of metadata queries, searches are asynchronous and events are used to notify the application that results are available. <code>MetadataSearch</code> events SHALL be targeted at the application/oipfSearchManager object.</p>
<p>The present document is intentionally silent about the implementation of the search mechanism and the algorithm for retrieving and caching search results except where described in Table <a href="#metadata-search-states" class="tableRef"></a> above. When performing a search, the receiver MAY gather all search results and cache them (or cache a set of pointers into the full database), or gather only the subset of search results determined by the <a href="#searchresults-getresults" class="apiRef">getResults()</a> parameters, or take an alternative approach not described here. </p>

<section id="metadatasearch-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="metadatasearch-searchtarget">
<tr><td class="api-signature">readonly Integer <b>searchTarget</b></td></tr>
<tr><td><p>The target(s) of the search. Valid values are:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>Metadata relating to scheduled content SHALL be searched.</td></tr>
<tr><td>2</td><td>Metadata relating to on-demand content SHALL be searched.</td></tr>
</table>
These values SHALL be treated as a bitfield, allowing searches to be carried out across multiple search targets.
</td></tr>
</table>
<table class="dae-property-table" id="metadatasearch-result">
<tr><td class="api-signature">readonly <a href="#searchresults-class" class="apiRef">SearchResults</a> <b>result</b></td></tr>
<tr><td>The subset of search results that has been requested by the application.
</td></tr>
</table>
</section>
<section id="metadatasearch-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="metadatasearch-setquery">
<tr><td colspan="3" class="api-signature">void <b>setQuery</b>( <a href="#query-class" class="apiRef">Query</a> query )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Set the query terms to be used for this search, discarding any previously-set query terms.</p>
<p>Setting the search parameters using this method will implicitly remove any existing constraints, ordering or queries created by prior calls to methods on this object.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">query</td><td>The query terms to be used</td></tr>
</table>
<table class="dae-method-table" id="metadatasearch-addratingconstraint">
<tr><td colspan="3" class="api-signature">void <b>addRatingConstraint</b>( <a href="#parentalratingscheme-class" class="apiRef">ParentalRatingScheme</a> scheme, Integer threshold )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Constrain the search to only include results whose parental rating value is below the specified threshold.</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">scheme</td><td>The parental rating scheme upon which the constraint SHALL be based. If the value of this argument is <code>null</code>, any existing parental rating constraints SHALL be cleared.</td></tr>
<tr><td class="dae-method-table-argument">threshold</td><td>The threshold above which results SHALL NOT be returned.  If the value of this argument is <code>null</code>, any existing constraint for the specified parental rating scheme SHALL be cleared.</td></tr>
</table>

<table class="dae-method-table" id="metadatasearch-addcurrentratingconstraint">
<tr><td colspan="2" class="api-signature">void <b>addCurrentRatingConstraint</b>(  )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Constrain the search to only include results whose parental rating value is below the threshold currently set by the user.</td></tr>
</table>

<table class="dae-method-table" id="metadatasearch-addchannelconstraint-list">
<tr><td colspan="3" class="api-signature">void <b>addChannelConstraint</b>( <a href="#channellist-class" class="apiRef">ChannelList</a> channels )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Constrain the search to only include results from the specified channels. If a channel constraint has already been set, subsequent calls to <code>addChannelConstraint()</code> SHALL add the specified channels to the list of channels from which results should be returned.</p>
<p>For CoD searches, adding a channel constraint SHALL have no effect.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">channels</td><td>The channels from which results SHALL be returned.  If the value of this argument is <code>null</code>, any existing channel constraint SHALL be removed.</td></tr>
</table>

<table class="dae-method-table" id="metadatasearch-addchannelconstraint">
<tr><td colspan="3" class="api-signature">void <b>addChannelConstraint</b>( <a href="#channel-class" class="apiRef">Channel</a> channel )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Constrain the search to only include results from the specified channel. If a channel constraint has already been set, subsequent calls to <code>addChannelConstraint()</code> SHALL add the specified channel to the list of channels from which results should be returned.</p>
<p>For CoD searches, adding a channel constraint SHALL have no effect.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">channel</td><td>The channel from which results SHALL be returned. If the value of this argument is <code>null</code>, any existing channel constraint SHALL be removed.</td></tr>
</table>

<table class="dae-method-table" id="metadatasearch-orderby">
<tr><td colspan="3" class="api-signature">void <b>orderBy</b>( String field, Boolean ascending )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Set the order in which results SHOULD be returned in future.  Any existing search results SHALL not be re-ordered. Subsequent calls to <code>orderBy()</code> will apply further levels of ordering within the order defined by previous calls. For example:<pre class="javascript">
    orderBy("ServiceName", true);
    orderBy("PublishedStart", true);
</pre>will cause results to be ordered by service name and then by start time for results with the same channel number.
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">field</td><td>The name of the field by which results SHOULD be sorted.  A value of <code>null</code> indicates that any currently-set order SHALL be cleared and the default sort order should be used.</td></tr>
<tr><td class="dae-method-table-argument">ascending</td><td>Flag indicating whether the results SHOULD be returned in ascending or descending order.</td></tr>
</table>

<table class="dae-method-table" id="metadatasearch-createquery">
<tr><td colspan="3" class="api-signature"><a href="#query-class" class="apiRef">Query</a> <b>createQuery</b>( String field, Integer comparison, String value )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Create a metadata query for a specific value in a specific field within the metadata.  Simple queries MAY be combined to create more complex queries. Applications SHALL follow the JavaScript type conversion rules to convert non-string values into their string representation, if necessary.</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">field</td><td>The name of the field to compare. Fields are identified using the format &lt;classname&gt;.&lt;propertyname&gt; where classname SHALL be one of &ldquo;Programme&rdquo;, &ldquo;CODAsset&rdquo;, &ldquo;CODService&rdquo; or &ldquo;CODFolder&rdquo; and &lt;propertyname&gt; SHALL be a valid property name on the corresponding class.</td></tr>
<tr><td class="dae-method-table-argument">comparison</td><td>The type of comparison. One of:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>True if the specified value is equal to the value of the specified field.</td></tr>
<tr><td>1</td><td>True if the specified value is not equal to the value of the specified field.</td></tr>
<tr><td>2</td><td>True if the value of the specified field is greater than the specified value.</td></tr>
<tr><td>3</td><td>True if the value of the specified field is greater than or equal to the specified value.</td></tr>
<tr><td>4</td><td>True if the value of the specified field is less than the specified value.</td></tr>
<tr><td>5</td><td>True if the value of the specified field is less than or equal to the specified value.</td></tr>
<tr><td>6</td><td>True if the string value of the specified field contains the specified value. This operation SHALL be case insensitive, and SHALL match parts of a word as well as whole words (e.g. a value of &ldquo;term&rdquo; will match a field value of &ldquo;Terminator&rdquo;).</td></tr>
</table>
</td></tr>
<tr><td class="dae-method-table-argument">value</td><td>The value to check. Applications SHALL follow the JavaScript type conversion rules to convert non-string values into their string representation, if necessary.</td></tr>
</table>


<table class="dae-method-table" id="findprogrammesfromstream">
<tr><td colspan="3" class="api-signature">void <b>findProgrammesFromStream</b>( <a href="#channel-class" class="apiRef">Channel</a> channel, Integer startTime, Integer count )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Set a query and constraints for retrieving metadata for programmes from a given channel and given start time from metadata contained in the stream as defined in <a href="volume3.html#event-information-tables" class="extRef">section 4.1.3</a> of [[.OIPF_META2]]. Setting the search parameters using this method will implicitly remove any existing constraints, ordering or queries created by prior calls to methods on this object. </p>
<p>This method does not cause the search to be performed; applications must call <a href="#searchresults-getresults" class="apiRef">getResults()</a> to retrieve the results.  Applications SHALL be notified of the progress of the search via MetadataSearch events as described in section <a href="#application-oipfsearchmanager-events" class="sectionRef"></a>.
</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">channel</td><td>The channel for which programme information should be found.</td></tr>
<tr><td class="dae-method-table-argument">startTime</td><td>The start of the time period for which results should be returned measured in seconds since midnight (GMT) on 1/1/1970. The start time is inclusive; any programmes starting at the start time, or which are showing at the start time, will be included in the search results. If <code>null</code>, the search will start from the current time.
</td></tr>
<tr><td class="dae-method-table-argument">count</td><td><p>Optional argument giving the maximum number of programmes for which information should be fetched. This places an upper bound on the number of results that will be present in the result set &mdash; for instance, specifying a value of 2 for this argument will result in at most two results being returned by calls to <a href="#searchresults-getresults" class="apiRef">getResults()</a> even if a call to <a href="#searchresults-getresults" class="apiRef">getResults()</a> requests more results.</p>
<p>If this argument is not specified, no restrictions are imposed on the number of results which may be returned by calls to <a href="#searchresults-getresults" class="apiRef">getResults()</a>.</p></td></tr>
</table>
</section>

</section>

<section id="query-class">
<h3>The Query class</h3>
<p>The <code>Query</code> class represents a metadata query that the user wants to carry out.  This may be a simple search, or a complex search involving Boolean logic.  Queries are immutable; an operation on a query SHALL return a new <code>Query</code> object, allowing applications to continue referring to the original query.</p>
<p>The examples below show how more complex queries can be constructed:</p><pre class="javascript">
	Query qa = mySearch.createQuery("Title", 6, "Terminator");
	Query qb = mySearch.createQuery("SpokenLanguage", 0, "fr-CA");
	Query qc = qb.and(qa.not()); 
</pre>
<section id="query-properties">
<h4>Properties</h4>
This section is intentionally left empty.
</section>
<section id="query-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="query-and">
<tr><td colspan="3" class="api-signature">Query <b>and</b>( Query query )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Create a query based on the logical AND of the predicates represented by the query currently being operated on and the argument <code>query</code>. </td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">query</td><td>The second predicate for the AND operation.</td></tr>
</table>
<table class="dae-method-table" id="query-or">
<tr><td colspan="3" class="api-signature">Query <b>or</b>( Query query )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Create a query based on the logical OR of the predicates represented by the query currently being operated on and the argument <code>query</code>. </td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">query</td><td>The second predicate for the OR operation.</td></tr>
</table>
<table class="dae-method-table" id="query-not">
<tr><td colspan="2" class="api-signature">Query <b>not</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Create a query that is the logical negation of the predicates represented by the query currently being operated on.</td></tr>
</table>
</section>
</section>
<section id="searchresults-class">
<h3>The SearchResults class</h3>
<p>The <code>SearchResults</code> class represents the results of a metadata search.  Since the result set may contain a large number of items, applications request a 'window' on to the result set, similar to the functionality provided by the OFFSET and LIMIT clauses in SQL.</p>
<p>Applications MAY request the contents of the result in groups of an arbitrary size, based on an offset from the beginning of the result set. The data SHALL be fetched from the appropriate source, and the application SHALL be notified when the data is available.</p>
<p>The set of results SHALL only be valid if a call to <a href="#searchresults-getresults" class="apiRef">getResults()</a> has been made and a <code>MetadataSearch</code> event notifying the application that results are available has been dispatched. If this event has not been dispatched, the set of results SHALL be empty (i.e. the value of the <a href="#searchresults-totalsize" class="apiRef">totalSize</a> property SHALL be 0 and calls to <a href="#searchresults-item" class="apiRef">item()</a> SHALL return <code>undefined</code>).</p>
<p>In addition to the properties and methods defined below a <code>SearchResults</code> object SHALL support the array notation to access the results in this collection.</p>
<section id="searchresults-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="searchresults-length">
<tr><td class="api-signature">readonly Integer <b>length</b></td></tr>
<tr><td>The number of items in the current window within the overall result set. The value of this property SHALL be zero until <a href="#searchresults-getresults" class="apiRef">getResults()</a> has been called and a <code>MetadataSearch</code> event notifying the application that results are available has been dispatched. If the current window onto the result set is in fact the whole result set then <code>length</code> will be the same as <a href="#searchresults-totalsize" class="apiRef">totalSize</a>. Otherwise <code>length</code> will be less than <a href="#searchresults-totalsize" class="apiRef">totalSize</a>.</td></tr>
</table>
<table class="dae-property-table" id="searchresults-offset">
<tr><td class="api-signature">readonly Integer <b>offset</b></td></tr>
<tr><td>The current offset into the total result set.</td></tr>
</table>
<table class="dae-property-table" id="searchresults-totalsize">
<tr><td class="api-signature">readonly Integer <b>totalSize</b></td></tr>
<tr><td><p>The total number of items in the result set. </p><p>The value of this property SHALL be zero until <a href="#searchresults-getresults" class="apiRef">getResults()</a> has been called and a MetadataSearch event notifying the application that results are available has been dispatched.</p>
</td></tr>
</table>
</section>
<section id="searchresults-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="searchresults-item">
<tr><td colspan="3" class="api-signature">Object <b>item</b>( Integer index )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Return the item at position index in the collection of currently available results, or <code>undefined</code> if no item is present at that position. This function SHALL only return objects that are instances of <a href="#programme-class" class="apiRef">Programme</a>, <a href="#codasset-class" class="apiRef">CODAsset</a>, <a href="#codfolder-class" class="apiRef">CODFolder</a>, or <a href="#codservice-class" class="apiRef">CODService</a>.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">index</td><td>The index into the result set.</td></tr>
</table>

<table class="dae-method-table" id="searchresults-getresults">
<tr><td colspan="3" class="api-signature">Boolean <b>getResults</b>( Integer offset, Integer count )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Perform the search and retrieve the specified subset of the items that match the query. </p>
<p>Results SHALL be returned asynchronously.  A <code>MetadataSearch</code> event with <code>state</code>=0 SHALL be dispatched when results are available. </p>
<p>This method SHALL always return <code>false</code>.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">offset</td><td>The number of items at the start of the result set to be skipped before data is retrieved.</td></tr>
<tr><td class="dae-method-table-argument">count</td><td>The number of results to retrieve.</td></tr>
</table>

<table class="dae-method-table" id="searchresults-abort">
<tr><td colspan="2" class="api-signature">void <b>abort</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Abort any outstanding request for results and remove any query, constraints or ordering rules set on the <a href="#metadatasearch-class" class="apiRef">MetadataSearch</a> object that is associated with this <a href="#searchresults-class" class="apiRef">SearchResults</a> object. Regardless of whether or not there is an outstanding request for results, items currently in the collection SHALL be removed (i.e. the value of the <a href="#searchresults-length" class="apiRef">length</a> property SHALL be 0 and any calls to <a href="#searchresults-item" class="apiRef">item()</a> SHALL return <code>undefined</code>). All cached search results SHALL be discarded.
</td></tr>
</table>
</section>
</section>
</section>
</section>

<section id="scheduled-content-and-hybrid-tuner-apis">
<h2>Scheduled Content and hybrid tuner APIs</h2>
<p>This section SHALL apply to OITFs that have indicated support for tuner control (i.e.  <code>&lt;video_broadcast&gt;true&lt;/video_broadcast&gt;</code> as defined in section <a href="#tuner-broadcast-capability" class="sectionRef"></a>) in their capability. It describes the <code>video/broadcast</code> embedded object needed to support display and control by a DAE application of scheduled content received over local tuner functionality available to an OITF, including the conveyance of the channel list to the server. The term &ldquo;tuner&rdquo; is used here to identify a piece of functionality to enable switching between different types of scheduled content services that are identified through logical channels. This includes IP broadcast channels, as well as traditional broadcast channels received over a hybrid tuner.</p>
<section id="video-broadcast">
<h3>The video/broadcast embedded object</h3>
<p>The OITF SHALL support the <code>video/broadcast</code> embedded object with the following properties and methods, which SHALL adhere to the tuner related security requirements in section <a href="#security-requirements-for-tuner-control-and-lineup" class="sectionRef"></a>. The MIME type of this object SHALL be &ldquo;<code>video/broadcast</code>&rdquo;.</p>
<section id="video-broadcast-state-diagram">
<h4>State diagram for video/broadcast objects</h4>
<p>The state diagram below shows the states that a video/broadcast object may be in. Dashed lines indicate automatic transitions between states.  The <code>video/broadcast</code> object SHALL be in the <code>unrealized</code> state when it is instantiated.</p>
<figure id="state-diagram-for-embedded-video-broadcast-objects">
<img alt="FIGURE 14" src="images/VideoBroadcast-state-diagram.png" />
<figcaption>Figure ####: State diagram for embedded video/broadcast objects (informative).</figcaption>
</figure>
<p>Transient errors are defined as ones that that the OITF will automatically recover from without intervention by an application. Transient errors persist until either the condition which caused them is corrected or it is determined that it cannot be connected and the error becomes permanent. Permanent errors are defined as ones that the OITF will not automatically attempt to recover from.</p>
<p>Terminals SHALL perform the state changes in Table <a href="#video-broadcast-state-transitions" class="tableRef"></a> under the conditions described and generate the listed event(s). Terminals SHALL not change state in circumstances other than defined in this section.</p>
<table class="simple" id="video-broadcast-state-transitions">
<caption>Table ####: State transitions for the video/broadcast embedded object</caption>
<tr><th>Old State</th><th>Trigger</th><th>New State</th><th>State Transition Events</th><th>Description</th></tr>
<tr><td>All states</td><td><a href="#video-broadcast-setchannel" class="apiRef">setChannel(channel)</a> where <code>channel != null</code> and the channel type is supported and the combination of channel properties is valid and a suitable tuner is available</td><td>Connecting</td><td>PlayStateChange</td><td>The terminal attempts to connect to the requested channel. The <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> object reflects the channel being changed to.</td></tr>
<tr><td>All states</td><td><a href="#video-broadcast-setchannel" class="apiRef">setChannel(channel)</a> where <code>channel != null</code> but either the channel type is not supported or the combination of channel properties is invalid or a suitable tuner is not available</td><td>No change</td><td>ChannelChangeError</td><td>The terminal remains in the same state.</td></tr>
<tr><td>Connecting or Presenting or Stopped</td><td><a href="#video-broadcast-nextchannel" class="apiRef">nextChannel()</a>, <a href="#video-broadcast-prevchannel" class="apiRef">prevChannel()</a> where the <code>video/broadcast</code> object <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> is in the channel list and a suitable tuner is available</td><td>Connecting</td><td>PlayStateChange</td><td>The terminal attempts to connect to the requested channel. The <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> object reflects the channel being changed to.</td></tr>
<tr><td>Connecting</td><td><a href="#video-broadcast-nextchannel" class="apiRef">nextChannel()</a>, <a href="#video-broadcast-prevchannel" class="apiRef">prevChannel()</a> where the <code>video/broadcast</code> object <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> is not in the channel list</td><td>Unrealized</td><td><p>ChannelChangeError</p><p>PlayStateChange</p></td><td></td></tr>
<tr><td>Presenting or Stopped</td><td><a href="#video-broadcast-nextchannel" class="apiRef">nextChannel()</a>, <a href="#video-broadcast-prevchannel" class="apiRef">prevChannel()</a> where the <code>video/broadcast</code> object <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> is not in the channel list</td><td>No change</td><td>ChannelChangeError</td><td>The terminal remains in the same state.</td></tr>
<tr><td>Connecting or Presenting or Stopped</td><td><a href="#video-broadcast-nextchannel" class="apiRef">nextChannel()</a>, <a href="#video-broadcast-prevchannel" class="apiRef">prevChannel()</a> where the <code>video/broadcast</code> object <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> is in the channel list but no suitable tuner is available</td><td>No change</td><td>ChannelChangeError </td><td>The terminal remains in the same state.</td></tr>
<tr><td>Unrealized</td><td><a href="#video-broadcast-bindtocurrentchannel" class="apiRef">bindToCurrentChannel()</a> when at least one channel is currently being presented by the OITF and binding to the necessary resources does not fail</td><td>Presenting</td><td>PlayStateChange</td><td>The terminal binds the video/broadcast object to the current channel being natively presented. The currentChannel object reflects the channel being presented.</td></tr>
<tr><td>Unrealized</td><td><a href="#video-broadcast-bindtocurrentchannel" class="apiRef">bindToCurrentChannel()</a> when there is no channel currently being presented or binding to the necessary resources to play the channel through the video/broadcast object fails</td><td>Unrealized</td><td>PlayStateChange</td><td>The terminal continues to present the current channel, if any.</td></tr>
<tr><td>Connecting</td><td>The terminal successfully connected to the broadcast or IP multicast stream and presented its contents.</td><td>Presenting</td><td><p>ChannelChangeSucceeded</p><p>PlayStateChange</p></td><td>This transition occurs automatically when media presentation starts.</td></tr>
<tr><td>Connecting</td><td>The terminal successfully connected to the broadcast or IP multicast stream but presentation of content is blocked, e.g. by a parental rating mechanism or content protection mechanism</td><td>Connecting</td><td><p>ChannelChangeSucceeded</p><p>PlayStateChange</p></td><td>This is conceptually equivalent to a successful channel change where a  transient error immediately pre-empts media presentation without the video/broadcast object entering the presenting state.</td></tr>
<tr><td>Connecting</td><td><p>Recovery from a transient error, including</p><ul>
<li>presentation of content no longer being blocked by a content protection mechanism (e.g. the start of a free preview period or a channel that changes from being encrypted to being in the clear during the day)
<li>the end-user entering a PIN code or other equivalent authorization to enable access to content protected by parental access control
<li>resumption of delivery of media data</ul></td><td>Presenting</td><td>PlayStateChange</td><td>If a video/broadcast object was forced from the presenting state to the connecting state due to a transient error and that error condition clears while the video/broadcast object remains in the connecting state then the video/broadcast object SHALL automatically transition back to the presenting state. </td></tr>
<tr><td>Connecting or Presenting or Stopped</td><td><a href="#video-broadcast-release" class="apiRef">release()</a> or <a href="#video-broadcast-setchannel" class="apiRef">setChannel(null)</a></td><td>Unrealized</td><td>PlayStateChange</td><td><p>The control is returned to the terminal. The <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> object is set to <code>null</code>.</p>
<p>If an application has modified the set of components being presented (e.g. changing the audio or subtitle stream being presented) then the same set of components will continue to be presented.</p>
</td></tr>
<tr><td>Connecting</td><td><p>Permanent error including</p><ul>
<li>failure to change to a new channel (e.g. the channel cannot be found or none of the media components can be decoded or insufficient resources are available to present the channel)
<li>exhaustion of all possibilities for an end-user to authorize access to content protected by a parental access control mechanism (e.g. timeout on a PIN entry dialogue)
<li>delivery of media data was interrupted and has not resumed after an implementation-dependent timeout</ul></td><td>Unrealized</td><td><p>ChannelChangeSucceeded</p><p>PlayStateChange</p></td><td>The terminal encountered a permanent error</td></tr>
<tr><td>Connecting or Presenting</td><td><a href="#video-broadcast-stop" class="apiRef">stop()</a></td><td>Stopped</td><td>PlayStateChange</td><td></td></tr>
<tr><td>Presenting</td><td><p>Transient error including</p><ul>
<li>presentation of content being blocked by a content protection mechanism,
<li>presentation of content being blocked by a parental rating mechanism,
<li>interruption of delivery of media data (either via IP or hybrid) if either;<ol type="a">
<li>the media data is delivered over a connection and the connection remains intact or
<li>the media data is delivered via a connectionless mechanism </ol></ul></td><td>Connecting</td><td>PlayStateChange</td><td><p>The terminal encountered a transient error.</p><p>During media presentation, transient errors (e.g. transient errors in the bitstream, temporary loss of signal or temporary halting of media decoding due to parental control issues) MAY cause the object to transition from the presenting state to the connecting state. Temporary loss of resources due to presentation being interrupted by playback of audio from memory MAY cause the object to transition from the presenting state to the connecting state.</p></td></tr>
<tr><td>Presenting or Stopped</td><td><p>Permanent error including;</p><ul>
<li>interruption of delivery of media data where the media data is delivered over a connection and the connection terminates</ul></td><td>Unrealized</td><td>PlayStateChange</td><td>The terminal encountered a permanent error.</td></tr>
<tr><td>Stopped</td><td><a href="#video-broadcast-bindtocurrentchannel" class="apiRef">bindToCurrentChannel()</a></td><td>Connecting</td><td>PlayStateChange</td><td>Video and audio presentation is enabled.</td></tr>
<tr><td>All states</td><td>Destroy video/broadcast</td><td>N/A</td><td></td><td><p>When a video/broadcast object is destroyed (e.g. by the video/broadcast object being garbage collected) control of broadcast video SHALL be returned to the terminal. If an application has modified the set of components being presented (e.g. changing the audio or subtitle stream being presented) then the same set of components will continue to be presented.</p><p>When a video/broadcast object is destroyed due to a page transition within an application, terminals MAY delay this operation until the new page is fully loaded in order to avoid display glitches if a video/broadcast object is also present in the new page. Presentation of broadcast video or audio SHALL not be interrupted in either case.</p></td></tr>
</table>
<p>If the channel currently being presented is requested to be changed due to an action outside the application (for example, the user pressing the CH+ key on the remote) then any video/broadcast object presenting that channel (e.g. as the result of a call to <a href="#video-broadcast-bindtocurrentchannel" class="apiRef">bindToCurrentChannel()</a>) SHALL perform the same state transitions and dispatch the same events as if the channel change operation was initiated by the application using the <a href="#video-broadcast-setchannel" class="apiRef">setChannel()</a> method.</p>
<p>If the value of the <a href="#video-broadcast-allocationmethod" class="apiRef">allocationMethod</a> property is <code>DYNAMIC_ALLOCATION</code>, the following apply:</p><ul>
<li>Scarce resources such as media decoders SHALL be claimed while in the <code>connecting</code> state. 
<li>Resources SHALL be released when the <code>video/broadcast</code> object transitions to the <code>unrealized</code> state. 
<li>Video and audio decoding resources SHALL be released when the <code>video/broadcast</code> object transitions to the <code>stopped</code> state. 
<li>Transitioning from the <code>presenting</code> to the <code>connecting</code> state SHOULD not cause scarce resources to be released.</ul>
<p>Applications can use the <a href="#video-broadcast-playstate" class="apiRef">playState</a> property of the <code>video/broadcast</code> object to read its current state. </p>
<p>When a <code>video/broadcast</code> object stops being rendered as defined in section 10.1 of the HTML5 specification as referenced by [[.OIPF_WSTVP2]] an OITF MAY release scarce resources allocated for that object. Vice versa, a <code>video/broadcast</code> object which is not visible but it's still being rendered SHALL still be decoding video if it is in the presenting state and any audio associated with the currently presented channel will still be audible. State transitions caused by calls to methods on the video/broadcast object, or due to permanent or transient errors, will occur as shown above regardless of the visibility of the object.</p>
<p>NOTE: as implied by the text above, rendering state and visibility are not equivalent. This implies, just to give two examples, that <code>display:none</code> will affect the object state while <code>visibility:hidden</code> will not.</p>
</section>
<section id="video-broadcast-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="video-broadcast-width">
<tr><td class="api-signature">Integer <b>width</b></td></tr>
<tr><td>The width of the area used for rendering the video object. This property is only writable if property <a href="#video-broadcast-fullscreen" class="apiRef">fullScreen</a> has value <code>false</code>. Changing the <code>width</code> property corresponds to changing the <code>width</code> property through the <code>HTMLObjectElement</code> interface, and must have the same effect as changing the width through the DOM Level 2 Style interfaces (i.e. <code>CSS2Properties</code> interface <code>style.width</code>), at least for values specified in pixels.</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-height">
<tr><td class="api-signature">Integer <b>height</b></td></tr>
<tr><td>The height of the area used for rendering the video object. This property is only writable if property <a href="#video-broadcast-fullscreen" class="apiRef">fullScreen</a> has value <code>false</code>. Changing the <code>height</code> property corresponds to changing the <code>height</code> property through the <code>HTMLObjectElement</code> interface, and must have the same effect as changing the height through the DOM Level 2 Style interfaces (i.e. <code>CSS2Properties</code> interface <code>style.height</code>), at least for values specified in pixels.</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-fullscreen">
<tr><td class="api-signature">readonly Boolean <b>fullScreen</b></td></tr>
<tr><td>Returns <code>true</code> if this video object is in full-screen mode, <code>false</code> otherwise. The default value is <code>false</code>.</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-data">
<tr><td class="api-signature">readonly String <b>data</b></td></tr>
<tr><td>Setting the value of the data property SHALL have no effect on the <code>video/broadcast</code> object. If this property is read, the value returned SHALL always be the empty string.</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-onchannelchangeerror">
<tr><td class="api-signature">function <b>onChannelChangeError</b>( <a href="#channel-class" class="apiRef">Channel</a> channel, Number errorState )</td></tr>
<tr><td><p>The function that is called when a request to switch a tuner to another channel resulted in an error preventing the broadcasted content from being rendered. The specified function is called with the arguments <code>channel</code> and <code>errorState</code>. This function may be called either in response to a channel change initiated by the application, or a channel change initiated by the OITF (see section <a href="#video-broadcast-state-diagram" class="sectionRef"></a>). These arguments are defined as follows:<ul>
<li><code><a href="#channel-class" class="apiRef">Channel</a> channel</code> &mdash; the <a href="#channel-class" class="apiRef">Channel</a> object to which a channel switch was requested, but for which the error occurred. This object SHALL have the same properties as the channel that was requested, except that for channels of type <code>ID_DVB_*</code> the values for the <a href="#channel-onid" class="apiRef">onid</a> and <a href="#channel-tsid" class="apiRef">tsid</a> properties SHALL be extracted from the transport stream when one was found (e.g. when <code>errorState</code> is 12).
<li><code>Number errorState</code> &mdash; error code detailing the type of error:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>channel not supported by tuner.</td></tr>
<tr><td>1</td><td>cannot tune to given transport stream (e.g. no signal)</td></tr>
<tr><td>2</td><td>tuner locked by other object.</td></tr>
<tr><td>3</td><td>parental lock on channel.</td></tr>
<tr><td>4</td><td>encrypted channel, key/module missing.</td></tr>
<tr><td>5</td><td>unknown channel (e.g. can't resolve DVB or ISDB triplet).</td></tr>
<tr><td>6</td><td>channel switch interrupted (e.g. because another channel switch was activated before the previous one completed).</td></tr>
<tr><td>7</td><td>channel cannot be changed, because it is currently being recorded.</td></tr>
<tr><td>8</td><td>cannot resolve URI of referenced IP channel.</td></tr>
<tr><td>9</td><td>insufficient bandwidth.</td></tr>
<tr><td>10</td><td>channel cannot be changed by <a href="#video-broadcast-nextchannel" class="apiRef">nextChannel()</a>/<a href="#video-broadcast-prevchannel" class="apiRef">prevChannel()</a> methods either because the OITF does not maintain a favourites or channel list or because the video/broadcast object is in the Unrealized state.</td></tr>
<tr><td>11</td><td>insufficient resources are available to present the given channel (e.g. a lack of available codec resources).</td></tr>
<tr><td>12</td><td>specified channel not found in transport stream.</td></tr>
<tr><td>100</td><td>unidentified error.</td></tr>
</table>
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-playstate">
<tr><td class="api-signature">readonly Integer <b>playState</b></td></tr>
<tr><td><p>The current play state of the video/broadcast object. Valid values are:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>unrealized; the application has not made a request to start presenting a channel or has stopped presenting a channel and released any resources. The content of the video/broadcast object should be transparent but if not shall be an opaque black rectangle. Control of media presentation is under the control of the OITF, as defined in section <a href="#display-model-object-interactions" class="sectionRef"></a>.</td></tr>
<tr><td>1</td><td>connecting; the terminal is connecting to the media source in order to begin playback.  Objects in this state may be buffering data in order to start playback. Control of media presentation is under the control of the application, as defined in section <a href="#display-model-object-interactions" class="sectionRef"></a>. The content of the video/broadcast object is implementation dependent.</td></tr>
<tr><td>2</td><td>presenting; the media is currently being presented to the user.  The object is in this state regardless of whether the media is playing at normal speed, paused, or playing in a trick mode (e.g. at a speed other than normal speed). Control of media presentation is under the control of the application, as defined in section <a href="#display-model-object-interactions" class="sectionRef"></a>. The video/broadcast object contains the video being presented.</td></tr>
<tr><td>3</td><td>stopped; the terminal is not presenting media, either inside the video/broadcast object or in the logical video plane. The logical video plane is disabled. The content of the video/broadcast object SHALL be an opaque black rectangle. Control of media presentation is under the control of the application, as defined in section <a href="#display-model-object-interactions" class="sectionRef"></a></td></tr>
</table>
<p>See section <a href="#video-broadcast-state-diagram" class="sectionRef"></a> for a description of the state model for a <code>video/broadcast</code> object.</p>
<p>NOTE: Implementations where the content of the <code>video/broadcast</code> object is transparent in the unrealized state will give a better user experience than ones where it is black. This happens for an application with video in the background between when it includes a <code>video/broadcast</code> object in the page and when a call to <a href="#video-broadcast-bindtocurrentchannel" class="apiRef">bindToCurrentChannel()</a> completes. Applications which do not need to call <a href="#video-broadcast-bindtocurrentchannel" class="apiRef">bindToCurrentChannel()</a> should not do so. The current channel can be obtained from the <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> property on the <a href="#applicationprivatedata-class" class="apiRef">ApplicationPrivateData</a> object which is the same as that on the <code>video/broadcast</code> object under most normal conditions.</p>
</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-onplaystatechange">
<tr><td class="api-signature">function <b>onPlayStateChange</b>( Number state, Number error )</td></tr>
<tr><td><p>The function that is called when the play state of the <code>video/broadcast</code> object changes. This function may be called either in response to an action initiated by the application, an action initiated by the OITF or an error (see section <a href="#video-broadcast-state-diagram" class="sectionRef"></a>).</p>
<p>The specified function is called with the arguments <code>state</code> and <code>error</code>. These arguments are defined as follows:</p><ul>
<li><code>Number state</code> &mdash; the new state of the <code>video/broadcast</code> object. Valid values are given in the definition of the <a href="#video-broadcast-playstate" class="apiRef">playState</a> property above.
<li><code>Number error</code> &mdash; if the state has changed due to an error, this field contains an error code detailing the type of error. See the definition of <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> above for valid values. If no error has occurred, this argument SHALL take the value <code>undefined</code>.
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-onchannelchangesucceeded">
<tr><td class="api-signature">function <b>onChannelChangeSucceeded</b>( <a href="#channel-class" class="apiRef">Channel</a> channel )</td></tr>
<tr><td><p>The function that is called when a request to switch a tuner to another channel has successfully completed. This function may be called either in response to a channel change initiated by the application, or a channel change initiated by the OITF (see section <a href="#video-broadcast-state-diagram" class="sectionRef"></a>). The specified function is called with argument <code>channel</code>, which is defined as follows:</p><ul>
<li><code>Channel channel</code> &mdash; the channel to which the tuner switched. This object SHALL have the same properties with the same values as the <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> object (see section <a href="#video-broadcast-extensions-current-channel-info" class="sectionRef"></a>).
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-onfullscreenchange">
<tr><td class="api-signature">function <b>onFullScreenChange</b>( )</td></tr>
<tr><td>The function that is called when the value of <a href="#video-broadcast-fullscreen" class="apiRef">fullScreen</a> changes.</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-onfocus">
<tr><td class="api-signature">function <b>onfocus</b>( )</td></tr>
<tr><td>The function that is called when the video object gains focus.</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-onblur">
<tr><td class="api-signature">function <b>onblur</b>( )</td></tr>
<tr><td>The function that is called when the video object loses focus.</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-playercapabilities">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>playerCapabilities</b></td></tr>
<tr><td><p>The list of media formats that are supported by the object. Each item SHALL contain a format label according to [[.OIPF_MEDIA2]].</p><p>If scarce resources are not claimed by the object, the value of this property SHALL be <code>null</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-allocationmethod">
<tr><td class="api-signature">readonly Integer <b>allocationMethod</b></td></tr>
<tr><td>Returns the resource allocation method currently in use by the object. Valid values as defined in section <a href="#av-control-resource-management-constants" class="sectionRef"></a> are:<ul>
<li>STATIC_ALLOCATION
<li>DYNAMIC_ALLOCATION</ul></td></tr>
</table>
</section>
<section id="video-broadcast-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="video-broadcast-getchannelconfig">
<tr><td colspan="2" class="api-signature"><a href="#channelconfig-class" class="apiRef">ChannelConfig</a> <b>getChannelConfig</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Returns the channel line-up of the tuner in the form of a <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> object as defined in section <a href="#channelconfig-class" class="sectionRef"></a>. The method SHALL return the value <code>null</code> if the channel list is not (partially) managed by the OITF (i.e., if the channel list information is managed entirely in the network).
</td></tr>
</table>
<table class="dae-method-table" id="video-broadcast-bindtocurrentchannel">
<tr><td colspan="2" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>bindToCurrentChannel</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>If the <code>video/broadcast</code> object is in the unrealized state and video from exactly one channel is currently being presented by the OITF then this binds the <code>video/broadcast</code> object to that video.</p>
<p>If the <code>video/broadcast</code> object is in the stopped state then this restarts presentation of video and audio from the current channel under the control of the <code>video/broadcast</code> object. If video from more than one channel is currently being presented by the OITF then this binds the <code>video/broadcast</code> object to the channel whose audio is being presented.</p>
<p>If there is no channel currently being presented, or binding to the necessary resources to play the channel through the <code>video/broadcast</code> object fails for whichever reason, the OITF SHALL dispatch an event to the <a href="#video-broadcast-onplaystatechange" class="apiRef">onPlayStateChange</a> listener(s) whereby the <code>state</code> parameter is given value 0 (&ldquo;<code>unrealized</code>&rdquo;) and the <code>error</code> parameter is given the appropriate error code.</p>
<p>Calling this method from any other states than the unrealized or stopped states SHALL have no effect.</p>
<p>See section <a href="#video-broadcast-state-diagram" class="sectionRef"></a> for more information of its usage.</p>
<p>NOTE: Returning a <a href="#channel-class" class="apiRef">Channel</a> object from this method does not guarantee that video or audio from that channel is being presented. Applications should listen for the <code>video/broadcast</code> object entering state 2 (&ldquo;<code>presenting</code>&rdquo;) in order to determine when audio or video is being presented.</p>
</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-createchannelobject-dsd">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>createChannelObject</b>( Integer idType, String dsd, Integer sid )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Creates a <a href="#channel-class" class="apiRef">Channel</a> object of the specified <code>idType</code>. This method is typically used to create a <a href="#channel-class" class="apiRef">Channel</a> object of type <code>ID_DVB_SI_DIRECT</code>. The <a href="#channel-class" class="apiRef">Channel</a> object can subsequently be used by the <a href="#video-broadcast-setchannel" class="apiRef">setChannel()</a> method to switch a tuner to this channel, which may or may not be part of the channel list in the OITF. The resulting <a href="#channel-class" class="apiRef">Channel</a> object represents a locally defined channel which, if not already present there, does not get added to the channel list accessed through the <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> class (see section <a href="#channelconfig-class" class="sectionRef"></a>).</p>
<p>Valid value for idType include: <code>ID_DVB_SI_DIRECT</code>. For other values this behaviour is not specified.</p>
<p>If the channel of the given type cannot be created or the delivery system descriptor is not valid, the method SHALL return <code>null</code>.</p>
<p>If the channel of the given type can be created and the delivery system descriptor is valid, the method SHALL return a <a href="#channel-class" class="apiRef">Channel</a> object whereby at a minimum the properties with the same names (i.e. <a href="#channel-idtype" class="apiRef">idType</a>, <a href="#channel-dsd" class="apiRef">dsd</a> and <a href="#channel-sid" class="apiRef">sid</a>) are given the same value as argument <code>idType</code>, <code>dsd</code> and <code>sid</code> of the <code>createChannelObject</code> method. 
</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">idType</td><td>The type of channel, as indicated by one of the <code>ID_*</code> constants defined in section <a href="#channel-constants" class="sectionRef"></a>. Valid values for idType include: <code>ID_DVB_SI_DIRECT</code>. For other values this behaviour is not specified.</td></tr>
<tr><td class="dae-method-table-argument">dsd</td><td>The delivery system descriptor (tuning parameters) represented as a string whose characters shall be restricted to the ISO Latin-1 character set. Each character in the dsd represents a byte of a delivery system descriptor as defined by DVB-SI [[!EN300468]] section 6.2.13, such that a byte at position "i" in the delivery system descriptor is equal the Latin-1 character code of the character at position "i" in the dsd. </td></tr>
<tr><td class="dae-method-table-argument">sid</td><td>The service ID, which must be within the range of 1 to 65535.</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-createchannelobject-onid">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>createChannelObject</b>( Integer idType, Integer onid, Integer tsid, Integer sid, Integer sourceID, String ipBroadcastID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Creates a <a href="#channel-class" class="apiRef">Channel</a> object of the specified <code>idType</code>. The <a href="#channel-class" class="apiRef">Channel</a> object can subsequently be used by the <a href="#video-broadcast-setchannel" class="apiRef">setChannel()</a> method to switch a tuner to this channel,  which may or may not be part of the channel list in the OITF. The resulting <a href="#channel-class" class="apiRef">Channel</a> object represents a locally defined channel which, if not already present there, does not get added to the channel list accessed through the <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> class (see section <a href="#channelconfig-class" class="sectionRef"></a>).</p>
<p>If the channel of the given <code>idType</code> cannot be created or the given (combination of) arguments are not considered valid or complete, the method SHALL return <code>null</code>.</p>
<p>If the channel of the given type can be created and arguments are considered valid and complete, then either:</p><ol>
<li>If the channel is in the channel list then a new object of the same type and with properties with the same values SHALL be returned as would be returned by calling <a href="#channellist-getchannelbytriplet" class="apiRef">getChannelByTriplet()</a> with the same parameters as this method.
<li>Otherwise, the method SHALL return a <a href="#channel-class" class="apiRef">Channel</a> object whereby at a minimum the properties with the same names are given the same value as the given arguments of the <code>createChannelObject()</code> method. The values specified for the remaining properties of the <a href="#channel-class" class="apiRef">Channel</a> object are set to <code>undefined</code>.
</ol></td></tr>
<tr><td class="dae-method-table-label" rowspan="6">Arguments</td>
<td class="dae-method-table-argument">idType</td><td>The type of channel, as indicated by one of the <code>ID_*</code> constants defined in section <a href="#channel-constants" class="sectionRef"></a>.</td></tr>
<tr><td class="dae-method-table-argument">onid</td><td>The original network ID. Optional argument that SHALL be specified when the <code>idType</code> specifies a channel of type <code>ID_DVB_*</code>, <code>ID_IPTV_URI</code>, or <code>ID_ISDB_*</code> and SHALL otherwise be ignored by the OITF.</td></tr>
<tr><td class="dae-method-table-argument">tsid</td><td>The transport stream ID.  Optional argument that MAY be specified when the <code>idType</code> specifies a channel of type <code>ID_DVB_*</code>, <code>ID_IPTV_URI</code>, or <code>ID_ISDB_*</code> and SHALL otherwise be ignored by the OITF.</td></tr>
<tr><td class="dae-method-table-argument">sid</td><td>The service ID.  Optional argument that SHALL be specified when the <code>idType</code> specifies a channel of type <code>ID_DVB_*</code>, <code>ID_IPTV_URI</code>, or <code>ID_ISDB_*</code> and SHALL otherwise be ignored by the OITF.</td></tr>
<tr><td class="dae-method-table-argument">sourceID</td><td>The source_ID.  Optional argument that SHALL be specified when the <code>idType</code> specifies a channel of type <code>ID_ATSC_T</code> and SHALL otherwise be ignored by the OITF.</td></tr>
<tr><td class="dae-method-table-argument">ipBroadcastID</td><td>The DVB textual service identifier of the IP broadcast service, specified in the format &ldquo;<code>ServiceName.DomainName</code>&rdquo; when <code>idType</code> specifies a channel of type <code>ID_IPTV_SDS</code>, or the URI of the IP broadcast service when <code>idType</code> specifies a channel of type <code>ID_IPTV_URI</code>. Optional argument that SHALL be specified when the <code>idType</code> specifies a channel of type <code>ID_IPTV_SDS</code> or <code>ID_IPTV_URI</code> and SHALL otherwise be ignored by the OITF.</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-setchannel">
<tr><td colspan="3" class="api-signature">void <b>setChannel</b>( <a href="#channel-class" class="apiRef">Channel</a> channel, Boolean trickplay, String contentAccessDescriptorURL )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Requests the OITF to switch a (logical or physical) tuner to the channel specified by channel and render the received broadcast content in the area of the browser allocated for the <code>video/broadcast</code> object. </p>
<p>If the channel specifies an <a href="#channel-idtype" class="apiRef">idType</a> attribute value which is not supported by the OITF or a combination of properties that does not identify a valid channel, the request to switch channel SHALL fail and the OITF SHALL trigger the function specified by the <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> property, specifying the value 0 (&ldquo;Channel not supported by tuner&rdquo;) for the <code>errorState</code>, and dispatch the corresponding DOM event (see below). </p> 
<p>If the channel specifies an <a href="#channel-idtype" class="apiRef">idType</a> attribute value supported by the OITF, and the combination of properties defines a valid channel, the OITF SHALL relay the channel switch request to a local physical tuner that is currently not in use by another <code>video/broadcast</code> object and that can tune to the specified channel. If no tuner satisfying these requirements is available (i.e. all physical tuners that could receive the specified channel are in use), the request SHALL fail and OITF SHALL trigger the function specified by the <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> property, specifying the value '2' (&ldquo;tuner locked by other object&rdquo;) for the <code>errorState</code> and dispatch the corresponding DOM event (see below). If multiple tuners satisfying these requirements are available, the OITF selects one.</p>
<p>If the channel specifies an IP broadcast channel, and the OITF supports <a href="#channel-idtype" class="apiRef">idType</a> <code>ID_IPTV_SDS</code> or <code>ID_IPTV_URI</code>, the OITF SHALL relay the channel switch request to a logical 'tuner' that can resolve the URI of the referenced IP broadcast channel. If no logical tuner can resolve the URI of the referenced IP broadcast channel, the request SHALL fail and the OITF SHOULD trigger the function specified by the <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> property, specifying the value 8 (&ldquo;cannot resolve URI of referenced IP channel&rdquo;) for the <code>errorState</code>, and dispatch the corresponding DOM event.</p>
<p>The optional attribute <code>contentAccessDescriptorURL</code> allows for the inclusion of a Content Access Streaming Descriptor (the format of which is defined in Annex <a href="#content-access-streaming-descriptor-format" class="sectionRef"></a>) to provide additional information for dealing with IPTV broadcasts that are (partially) DRM-protected. The descriptor may for example include Marlin action tokens or a previewLicense. The attribute SHALL be <code>undefined</code> or <code>null</code> if it is not applicable. If the attribute <code>contentAccessDescriptorURL</code> is present, the <code>trickplay</code> attribute shall take a value of either <code>true</code> or <code>false</code>.</p>
<p>If the Transport Stream cannot be found, either via the DSD or the (ONID,TSID) pair, then a call to <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> with <code>errorState</code>=5 (&ldquo;unknown channel&rdquo;) SHALL be triggered, and the corresponding DOM event dispatched.</p>
<p>If the OITF succeeds in tuning to a valid transport stream but this transport stream does not contain the requested service in the PAT, the OITF SHALL remain tuned to that location and SHALL trigger a call to <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> with <code>errorState</code>=12 (&ldquo;specified channel not found in transport stream&rdquo;), and dispatch the corresponding DOM event.</p>
<p>If, following this procedure, the OITF selects a tuner that was not already being used to display video inside the <code>video/broadcast</code> object, the OITF SHALL claim the selected tuner and the associated resources (e.g., decoding and rendering resources) on behalf of the <code>video/broadcast</code> object. </p>
<p>If all of the following are true:</p><ul>
<li>the <code>video/broadcast</code> object is successfully switched to the new channel
<li>the <code>channel</code> is a locally defined channel (created using the <a href="#video-broadcast-createchannelobject-dsd" class="apiRef">createChannelObject</a> method)
<li>the new channel has the same tuning parameters as a channel already in the channel list in the OITF
<li>the <code>idType</code> is a value other than <code>ID_IPTV_URI</code>
</ul>
<p>then the result of this operation SHALL be the same as calling <code>setChannel</code> with the <code>channel</code> argument being the corresponding channel object in the channel list, such that:</p><ul>
<li>the values of the properties of the <code>video/broadcast</code> object <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> SHALL be the same as those of the channel in the channel list
<li>any subsequent call to <a href="#video-broadcast-nextchannel" class="apiRef">nextChannel</a> or <a href="#video-broadcast-prevchannel" class="apiRef">prevChannel</a> SHALL switch the tuner to the next or previous channel in the favourite list or channel list as appropriate, as described in the definitions of these methods
</ul>
<p>Otherwise, if any of the above conditions is not true, then:</p><ul>
<li>the values of the properties of the <code>video/broadcast</code> object <a href="#video-broadcast-currentchannel" class="apiRef">currentChannel</a> SHALL be the same as those provided in the channel argument to this method, updated as defined in section <a href="#mapping-apis-to-content-formats-channel" class="sectionRef"></a>
<li>the channel is not considered to be part of the channel list
</ul>
<p>the resulting current channel after any subsequent call to <a href="#video-broadcast-nextchannel" class="apiRef">nextChannel()</a> or <a href="#video-broadcast-prevchannel" class="apiRef">prevChannel()</a> is implementation dependent, however all appropriate functions SHALL be called and DOM events dispatched. The OITF SHALL visualize the video content received over the tuner in the area of the browser allocated for the <code>video/broadcast</code> object. If the OITF cannot visualize the video content following a successful tuner switch (e.g., because the channel is under parental lock), the OITF SHALL trigger the function specified by the <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> property with the appropriate channel and <code>errorState</code> value, and dispatch a corresponding DOM event (see below). If successful, the OITF SHALL trigger the function specified by the <a href="#video-broadcast-onchannelchangesucceeded" class="apiRef">onChannelChangeSucceeded</a> property with the given channel value, and also dispatch a corresponding DOM event.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">channel</td><td><p>The channel to which a switched is requested. </p>
<p>If the <code>channel</code> object specifies a ccid, the ccid identifies the channel to be set. If the channel does not specify a ccid, the <code>idType</code> determines which properties of the channel are used to define the channel to be set, for example, if the channel is of type <code>ID_IPTV_SDS</code> or <code>ID_IPTV_URI</code>, the <code>ipBroadcastID</code> identifies the channel to be set.</p>
<p>If <code>null</code>, the <code>video/broadcast</code> object SHALL transition to the unrealized state and release any resources used for decoding video and/or audio. A <code>ChannelChangeSucceeded</code> event SHALL be generated when the operation has completed.</p></td></tr>
<tr><td class="dae-method-table-argument">trickplay</td><td><p>Optional flag indicating whether resources SHOULD be allocated to support trick play.  This argument provides a hint to the receiver in order that it may allocate appropriate resources. Failure to allocate appropriate resources, due to a resource conflict, a lack of trickplay support, or due to the OITF ignoring this hint, SHALL have no effect on the success or failure of this method.  If trickplay is not supported, this SHALL be indicated through the failure of later calls to methods invoking trickplay functionality.</p>
<p>The <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property defined in section <a href="#video-broadcast-extensions-recording-timeshift-properties" class="sectionRef"></a> shall provide information as to type of trickplay resources that should be allocated.</p>
<p>If argument <code>contentAccessDescriptorURL</code> is included then the <code>trickplay</code> argument SHALL be included.</p>
</td></tr>
<tr><td class="dae-method-table-argument">contentAccessDescriptorURL</td><td>Optional argument containing a Content Access Streaming descriptor (the format of which is defined in Annex <a href="#content-access-streaming-descriptor-format" class="sectionRef"></a>) that can be included to provide additional information for dealing with IPTV broadcasts that are (partially) DRM-protected. The argument SHALL be <code>undefined</code> or <code>null</code> if it is not applicable.</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-prevchannel">
<tr><td colspan="2" class="api-signature">void <b>prevChannel</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Requests the OITF to switch the tuner that is currently in use by the <code>video/broadcast</code> object to the channel that precedes the current channel in the active favourite list, or, if no favourite list is currently selected, to the previous channel in the channel list. If it has reached the start of the favourite/channel list, it SHALL cycle to the last channel in the list. </p> 
<p>If the current channel is not part of the channel list, it is implementation dependent whether the method call succeeds or fails and, if it succeeds, which channel is selected. In both cases, all appropriate functions SHALL be called and DOM events dispatched.</p>
<p>If the previous channel is a channel that cannot be received over the tuner currently used by the <code>video/broadcast</code> object, the OITF SHALL relay the channel switch request to a local physical or logical tuner that is not in use and that can tune to the specified channel. The behaviour is defined in more detail in the description of the <a href="#video-broadcast-setchannel" class="apiRef">setChannel</a> method.</p>
<p>If an error occurs during switching to the previous channel, the OITF SHALL trigger the function specified by the <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> property with the appropriate <code>channel</code> and <code>errorState</code> value, and dispatch the corresponding DOM event (see below).</p>
<p>If the OITF does not maintain the channel list and favourite list by itself, the request SHALL fail and the OITF SHALL trigger the <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> function with the <code>channel</code> property having the value <code>null</code>, and <code>errorState</code>=10 (&ldquo;channel cannot be changed by nextChannel()/prevChannel() methods&rdquo;).</p>
<p>If successful, the OITF SHALL trigger the function specified by the <a href="#video-broadcast-onchannelchangesucceeded" class="apiRef">onChannelChangeSucceeded</a> property with the appropriate channel value, and also dispatch the corresponding DOM event.</p>
<p>Calls to this method are valid in the Connecting, Presenting and Stopped states. They are not valid in the Unrealized state and SHALL fail.</p></td></tr>
</table>
<table class="dae-method-table" id="video-broadcast-nextchannel">
<tr><td colspan="2" class="api-signature">void <b>nextChannel</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Requests the OITF to switch the tuner that is currently in use by the <code>video/broadcast</code> object to the channel that succeeds the current channel in the active favourites list, or, if no favourite list is currently selected, to the next channel in the channel list. If it has reached the end of the favourite/channel list, it SHALL cycle to the first channel in the list. </p>
<p>If the current channel is not part of the channel list, it is implementation dependent whether the method call succeeds or fails and, if it succeeds, which channel is selected. In both cases, all appropriate functions SHALL be called and DOM events dispatched. If the next channel is channel that cannot be received over the tuner currently used by the <code>video/broadcast</code> object, the OITF SHALL relay the channel switch request to a local physical or logical tuner that is not in use and that can tune to the specified channel. The behaviour is defined in more detail in the description of the <a href="#video-broadcast-setchannel" class="apiRef">setChannel</a> method.</p>
<p>If an error occurs during switching to the next channel, the OITF SHALL trigger the function specified by the <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> property with the appropriate <code>channel</code> and <code>errorState</code> value, and dispatch the corresponding DOM event (see below).</p>
<p>If the OITF does not maintain the channel list and favourite list by itself, the request SHALL fail and the OITF SHALL trigger the <a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a> function with the <code>channel</code> property having the value <code>null</code>, and <code>errorState</code>=10 (&ldquo;channel cannot be changed by nextChannel()/prevChannel() methods&rdquo;). </p>
<p>If successful, the OITF SHALL trigger the function specified by the <a href="#video-broadcast-onchannelchangesucceeded" class="apiRef">onChannelChangeSucceeded</a> property with the appropriate <code>channel</code> value, and also dispatch the corresponding DOM event.</p>
<p>Calls to this method are valid in the Connecting, Presenting and Stopped states. They are not valid in the Unrealized state and SHALL fail.</p>
</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-setfullscreen">
<tr><td colspan="3" class="api-signature">void <b>setFullScreen</b>( Boolean fullscreen )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Sets the rendering of the video content to full-screen (<code>fullscreen = true</code>) or windowed (<code>fullscreen = false</code>) mode (as per [Req. 5.7.1.c] of [[!CEA-2014-A]]). If this indicates a change in mode, this SHALL result in a change of the value of property <a href="#video-broadcast-fullscreen" class="apiRef">fullScreen</a>. Changing the mode SHALL NOT affect the z-index of the video object.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">fullScreen</td><td>Boolean to indicate whether video content should be rendered full-screen or not.</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-setvolume">
<tr><td colspan="3" class="api-signature">Boolean <b>setVolume</b>( Integer volume )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Adjusts the volume of the currently playing media to the volume as indicated by <code>volume</code>. Allowed values for the <code>volume</code> argument are all the integer values starting with 0 up to and including 100. A value of 0 means the sound will be muted. A value of 100 means that the volume will become equal to current &ldquo;master&rdquo; volume of the device, whereby the &ldquo;master&rdquo; volume of the device is the volume currently set for the main audio output mixer of the device. All values between 0 and 100 define a linear increase of the volume as a percentage of the current master volume, whereby the OITF SHALL map it to the closest volume level supported by the platform.</p>
<p>The method returns <code>true</code> if the volume has changed. Returns <code>false</code> if the volume has not changed. Applications MAY use the <a href="#video-broadcast-getvolume" class="apiRef">getVolume()</a> method to retrieve the actual volume set.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">volume</td><td>Integer value between 0 up to and including 100 to indicate volume level.</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-getvolume">
<tr><td colspan="2" class="api-signature">Integer <b>getVolume</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Returns the actual volume level set; for systems that do not support individual volume control of players, this method will have no effect and will always return 100.</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-release">
<tr><td colspan="2" class="api-signature">Integer <b>release</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Releases the decoder/tuner used for displaying the video broadcast inside the <code>video/broadcast</code> object, stopping any form of visualization of the video inside the <code>video/broadcast</code> object and releasing any other associated resources. </p>
<p>If the object was created with an <a href="#video-broadcast-allocationmethod" class="apiRef">allocationMethod</a> of STATIC_ALLOCATION, the releasing of resources shall change this to DYNAMIC_ALLOCATION.</p></td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-stop">
<tr><td colspan="2" class="api-signature">void <b>stop</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Stop presenting broadcast video. If the <code>video/broadcast</code> object is in any state other than the unrealized state, it SHALL transition to the stopped state and stop video and audio presentation. This SHALL have no effect on access to non-media broadcast resources such as EIT information.</p>
<p>Calling this method from the unrealized state SHALL have no effect.</p>
<p>See section <a href="#video-broadcast-state-diagram" class="sectionRef"></a> for more information of its usage. </p></td></tr>
</table>

</section>
<section id="video-broadcast-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#video-broadcast-onfocus" class="apiRef">onfocus</a></td><td>focus <div style="font-family: sans-serif;">(as defined in section 5.2.1.2 of the DOM Level 3 Events specification as referenced in [[.OIPF_WSTVP2]])</div></td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
<tr><td><a href="#video-broadcast-onblur" class="apiRef">onblur</a></td><td>blur <div style="font-family: sans-serif;">(as defined in section 5.2.1.2 of the DOM Level 3 Events specification as referenced in [[.OIPF_WSTVP2]])</div></td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
<tr><td><a href="#video-broadcast-onfullscreenchange" class="apiRef">onFullScreenChange</a></td><td>FullScreenChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
<tr><td><a href="#video-broadcast-onchannelchangeerror" class="apiRef">onChannelChangeError</a></td><td>ChannelChangeError</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>channel</code>, <code>errorState</code></td></tr>
<tr><td><a href="#video-broadcast-onchannelchangesucceeded" class="apiRef">onChannelChangeSucceeded</a></td><td>ChannelChangeSucceeded</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>channel</code></td></tr>
<tr><td><a href="#video-broadcast-onplaystatechange" class="apiRef">onPlayStateChange</a></td><td>PlayStateChange</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>state</code>, <code>error</code></td></tr>
</table>
<p>Note: these DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <code>video/broadcast</code> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>
<section id="video-broadcast-styling">
<h4>Styling</h4>
<code>video/broadcast</code> objects SHALL support CSS-property <code>z-index</code>, in both full-screen and windowed mode.
</section>

</section>
<section id="video-broadcast-extensions-recording-timeshift">
<h3>Extensions to video/broadcast for recording and time-shift</h3>
<p>If an OITF has indicated support for recording functionality (i.e. by giving value <code>true</code> to element <code>&lt;recording&gt;</code> as specified in section <a href="#pvr-capability" class="sectionRef"></a> in its capability description), the OITF SHALL support the following additional constants, properties and methods on the <code>video/broadcast</code> object, in order to start a recording and/or time-shift of a current broadcast.</p>
<p>Note that this functionality is subject to the security model as specified in section <a href="#application-service-security" class="sectionRef"></a>.</p>
<p>This functionality is subject to the state transitions represented in the following state diagram:</p>
<figure id="pvr-states-for-recordnow">
<img alt="FIGURE 15" src="images/PVRStates-for-recordNow.png" />
<figcaption>Figure ####: PVR States for recordNow and timeshifting using video/broadcast (normative)</figcaption>
</figure>
<p>Note that when the user switches to another channel whilst the current channel is being recorded using <a href="#video-broadcast-recordnow" class="apiRef">recordNow</a> or the <code>video/broadcast</code> object gets destroyed, the conflict resolution and the release of resources is implementation dependent. The OITF MAY report a recording error using a <code>RecordingEvent></code> with value 0 (&ldquo;Unrealized&rdquo;) for argument <code>state</code> and with value 2 (&ldquo;Tuner conflict&rdquo;) for argument <code>error</code> in that case. </p>
<section id="video-broadcast-extensions-recording-timeshift-constants">
<h4>Constants</h4>
<table class="dae-constant-table">
<tr><th>Name</th><th>Value</th><th>Use</th></tr>
<tr><td>POSITION_START</td><td>0</td><td>Indicates a playback position relative to the start of the buffered content.</td></tr>
<tr><td>POSITION_CURRENT</td><td>1</td><td>Indicates a playback position relative to the current playback position.</td></tr>
<tr><td>POSITION_END</td><td>2</td><td>Indicates a playback position relative to the end of the buffered content.</td></tr>
</table>
</section>
<section id="video-broadcast-extensions-recording-timeshift-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="video-broadcast-onplayspeedchanged">
<tr><td class="api-signature">function <b>onPlaySpeedChanged</b>( Number speed )</td></tr>
<tr><td><p>The function that is called when the playback speed of a channel changes.</p>
<p>The specified function is called with one argument, <code>speed</code>, which is defined as follows:</p><ul>
<li><code>Number speed</code> &mdash; the playback speed of the media at the time the event was dispatched.
</ul>
<p>If the playback reaches the beginning of the time-shift buffer at rewind playback speed, then the play state is changed to 2 ('paused') and a <code>PlaySpeedChanged</code> event with a speed of 0 is generated. If the playback reaches the end of the time-shift buffer at fast-forward playback speed, then the play speed is set to 1.0 and a <code>PlaySpeedChanged</code> event is generated. 
</p></td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-onplaypositionchanged">
<tr><td class="api-signature">function <b>onPlayPositionChanged</b>( Integer position )</td></tr>
<tr><td><p>The function that is called when change occurs in the play position of a channel due to the use of trick play functions.</p>
<p>The specified function is called with one argument, <code>position</code>, which is defined as follows:</p><ul>
<li><code>Integer position</code> &mdash; the playback position of the media at the time the event was dispatched, measured from the start of the timeshift buffer. If the value of the <a href="#video-broadcast-currenttimeshiftmode" class="apiRef">currentTimeShiftMode</a> property is 1, this is measured in milliseconds from the start of the timeshift buffer. If the value of the <a href="#video-broadcast-currenttimeshiftmode" class="apiRef">currentTimeShiftMode</a> property is 2, this is measured in milliseconds from the start of the media item. If the play position cannot be determined, this argument takes the value <code>undefined</code>.
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-playbackoffset">
<tr><td class="api-signature">readonly Integer <b>playbackOffset</b></td></tr>
<tr><td><p>Returns the playback position, specified as the positive offset of the live broadcast in seconds, in the currently rendered (timeshifted) broadcast.</p>
<p>When the <a href="#video-broadcast-currenttimeshiftmode" class="apiRef">currentTimeShiftMode</a> property has the value 1, the value of this property is <code>undefined</code>.</p>
</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-maxoffset">
<tr><td class="api-signature">readonly Integer <b>maxOffset</b></td></tr>
<tr><td><p>Returns the maximum playback offset, in seconds of the live broadcast, which is supported for the currently rendered (timeshifted) broadcast. If the maximum offset is unknown, the value of this property SHALL be <code>undefined</code>.</p>
<p>When the <a href="#video-broadcast-currenttimeshiftmode" class="apiRef">currentTimeShiftMode</a> property has the value 1, the value of this property is <code>undefined</code>.</p>
</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-recordingstate">
<tr><td class="api-signature">readonly Integer <b>recordingState</b></td></tr>
<tr><td>
Returns the state of the OITF's timeshift and recordNow functionality for the channel shown in the video/broadcast object. One of:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Unrealized: user/application has not requested timeshift or recordNow functionality for the channel shown. No timeshift or recording resources are claimed in this state.</td></tr>
<tr><td>1</td><td>Recording has been newly scheduled.</td></tr>
<tr><td>2</td><td>Recording is about to start. The receiver may be monitoring EPG data in order to ensure that the programme scheduled to be recorded has not been moved, or to support "accurate recording" functionality as defined in section 11 of TS 102 323 [[TS102323]], where slight changes in the start time of the recording do not result in the start of the recording being missed. No recording resources have yet been acquired, although the OITF may have tuned to the channel which is to be recorded.</td></tr>
<tr><td>3</td><td>Acquiring recording resources (incl. media connection).</td></tr>
<tr><td>4</td><td>Recording has started.</td></tr>
<tr><td>5</td><td>Recording has been updated.</td></tr>
<tr><td>6</td><td>Recording has successfully completed.</td></tr>
<tr><td>10</td><td>Acquiring timeshift resources (incl. media connection).</td></tr>
<tr><td>11</td><td>Timeshift mode has started.</td></tr>
</table>
</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-onrecordingevent">
<tr><td class="api-signature">function <b>onRecordingEvent</b>( Integer state, Integer error, String recordingId )</td></tr>
<tr><td><p>This function is the DOM 0 event handler for notification of state changes of the recording functionality. The specified function is called with the following arguments:</p><ul>
<li><code>Integer state</code> - The current state of the recording. One of:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Unrealized: user/application has not requested timeshift or recordNow functionality for the channel shown. No timeshift or recording resources are claimed in this state.</td></tr>
<tr><td>1</td><td>Recording has been newly scheduled.</td></tr>
<tr><td>2</td><td>Recording is about to start. The receiver may be monitoring EPG data in order to ensure that the programme scheduled to be recorded has not been moved, or to support "accurate recording" functionality as defined in section 11 of TS 102 323 [[TS102323]], where slight changes in the start time of the recording do not result in the start of the recording being missed. No recording resources have yet been acquired, although the OITF may have tuned to the channel which is to be recorded.</td></tr>
<tr><td>3</td><td>Acquiring recording resources (incl. media connection).</td></tr>
<tr><td>4</td><td>Recording has started.</td></tr>
<tr><td>5</td><td>Recording has been updated.</td></tr>
<tr><td>6</td><td>Recording has successfully completed.</td></tr>
<tr><td>10</td><td>Acquiring timeshift resources (incl. media connection).</td></tr>
<tr><td>11</td><td>Timeshift mode has started.</td></tr>
</table>
<li><code>Integer error</code> - If the state of the recording has changed due to an error, this field contains an error code detailing the type of error.  One of:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>The recording sub-system is unable to record due to resource limitations.</td></tr>
<tr><td>1</td><td>There is insufficient storage space available. (Some of the recording may be available).</td></tr>
<tr><td>2</td><td>Tuner conflict (e.g. due to conflicting scheduled recording).</td></tr>
<tr><td>3</td><td>Recording not allowed due to DRM restrictions.</td></tr>
<tr><td>4</td><td>Recording has stopped before completion due to unknown (probably hardware) failure.</td></tr>
<tr><td>10</td><td>Timeshift not possible due to resource limitations.</td></tr>
<tr><td>11</td><td>Timeshift not allowed due to DRM restrictions.</td></tr>
<tr><td>12</td><td>Timeshift ended due to unknown failure.</td></tr>
</table>
If no error has occurred, this argument SHALL take the value <code>undefined</code>.
<li><code>String recordingId</code> - The identifier of the recording to which this event refers, This SHALL be equal to the value of the id property for the affected recording, if the event is associated with a specific recording.
</ul>
</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-playposition">
<tr><td class="api-signature">readonly Integer <b>playPosition</b></td></tr>
<tr><td><p>If the value of the <a href="#video-broadcast-currenttimeshiftmode" class="apiRef">currentTimeShiftMode</a> property is 1, the current playback position of the media, measured in milliseconds from the start of the timeshift buffer.</p>
<p>If the value of the <a href="#video-broadcast-currenttimeshiftmode" class="apiRef">currentTimeShiftMode</a> property is 2, the current playback position of the media, measured in milliseconds from the start of the media item.</p>
</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-playspeed">
<tr><td class="api-signature">readonly Number <b>playSpeed</b></td></tr>
<tr><td><p>The current play speed of the media.</p>
</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-playspeeds">
<tr><td class="api-signature">readonly Number <b>playSpeeds</b>[ ]</td></tr>
<tr><td><p>Returns the ordered list of playback speeds, expressed as values relative to the normal playback speed (1.0), at which the currently specified A/V content can be played (as a time-shifted broadcast in the video/broadcast object), or <code>undefined</code> if the supported playback speeds are not known or the <code>video/broadcast</code> object is not in timeshift mode.</p>
<p>If the <code>video/broadcast</code> object is in timeshift mode, the <code>playSpeeds</code> array SHALL always include at least values 1.0 and 0.0.</p>
</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-onplayspeedsarraychanged">
<tr><td class="api-signature">function <b>onPlaySpeedsArrayChanged</b>( )</td></tr>
<tr><td>The function that is called when the <a href="#video-broadcast-playspeeds" class="apiRef">playSpeeds</a> array values have changed. An application that makes use of the <a href="#video-broadcast-playspeeds" class="apiRef">playSpeeds</a> array needs to read the values of the <a href="#video-broadcast-playspeeds" class="apiRef">playSpeeds</a> property again.</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-timeshiftmode">
<tr><td class="api-signature">Integer <b>timeShiftMode</b></td></tr>
<tr><td><p>The time shift mode indicates the mode of operation for support of timeshift playback in the video/broadcast object.  Valid values are:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>Timeshift is turned off.</td></tr>
<tr><td>1</td><td>Timeshift shall use &ldquo;local resource&rdquo;.</td></tr>
<tr><td>2</td><td>Timeshift shall use &ldquo;network resources&rdquo;. </td></tr>
<tr><td>3</td><td>Timeshift shall first use &ldquo;local resource&rdquo; when available and fallback to &ldquo;network resources&rdquo;.</td></tr>
</table>
If property is not set the default value of the property is according to <a href="#configuration-preferredtimeshiftmode" class="apiRef">preferredTimeShiftMode</a> in section <a href="#configuration-properties" class="sectionRef"></a>.
</td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-currenttimeshiftmode">
<tr><td class="api-signature">readonly Integer <b>currentTimeShiftMode</b></td></tr>
<tr><td><p>When timeshift is in operation the property indicates which resources are currently being used. Valid values are:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>No timeshift.</td></tr>
<tr><td>1</td><td>Timeshift using &ldquo;local resource&rdquo;.</td></tr>
<tr><td>2</td><td>Timeshift using &ldquo;network resources&rdquo;.</td></tr>
</table>
</td></tr>
</table>
</section>
<section id="video-broadcast-extensions-recording-timeshift-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="video-broadcast-recordnow">
<tr><td colspan="3" class="api-signature">String <b>recordNow</b>( Integer duration )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Starts recording the broadcast currently rendered in the <code>video/broadcast</code> object. If the OITF has buffered the broadcasted content, the recording starts from the current playback position in the buffer, otherwise start recording the broadcast stream as soon as possible after the recording resources have been acquired. The specified duration is used by the OITF to determine the minimum duration of the recording in seconds from the current starting point.</p>
<p>Calling <code>recordNow()</code> while the broadcast that is currently rendered in the <code>video/broadcast</code> object is already being recorded, SHALL have no effect on the recording and SHALL return the value <code>null</code>.</p>
<p>In other cases, this method returns a <code>String</code> value representing a unique identifier to identify the recording. If the OITF provides recording management functionality through the APIs defined in section <a href="#application-oipfrecordingscheduler-control-extension" class="sectionRef"></a>, this SHALL be the value of the <a href="#recording-id" class="apiRef">id</a> property of the associated <a href="#recording-class" class="apiRef">Recording</a> object defined in section <a href="#recording-class" class="sectionRef"></a>. </p>
<p>The OITF SHALL guarantee that recording identifiers are unique in relation to download identifiers and <a href="#codasset-class" class="apiRef">CODAsset</a> identifiers.</p>
<p>The method returns <code>undefined</code> if the given argument is not accepted to trigger a recording.</p>
<p>If the OITF supports metadata processing in the terminal, the fields of the resulting <a href="#recording-class" class="apiRef">Recording</a> object MAY be populated using metadata retrieved by the terminal. Otherwise, the values of these fields SHALL be implementation-dependent.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">duration</td><td>The minimum duration of the recording in seconds. A value of -1 indicates that the recording SHOULD continue until <a href="#video-broadcast-stoprecording" class="apiRef">stopRecording()</a> is called, storage space is exhausted, or an error occurs. In this case it is essential that <a href="#video-broadcast-stoprecording" class="apiRef">stopRecording()</a> is called later.</td></tr>
</table>
<table class="dae-method-table" id="video-broadcast-stoprecording">
<tr><td colspan="2" class="api-signature">void <b>stopRecording</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1">Stops the current recording started by <a href="#video-broadcast-recordnow" class="apiRef">recordNow()</a>.</td></tr>
</table>
<table class="dae-method-table" id="video-broadcast-pause">
<tr><td colspan="2" class="api-signature">Boolean <b>pause</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Pause playback of the broadcast.</p>
<p>The action taken depends on the value of the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property.</p>
<p>If the value of the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property is 0, if trick play is not supported for the channel currently being rendered, or if the current time shift mode is not supported for the type of channel being presented (e.g. attempting to use network resource to time shift a DVB or analogue channel) this method shall return false.</p>
<p>If the timeshift mode is set to 1 or 3 (local resources) and if recording has not yet been started, this method will start recording the broadcast that is currently being rendered live (i.e., not time-shifted) in the <code>video/broadcast</code> object. If the OITF has buffered the 'live' broadcasted content, the recording starts with the content that is currently being rendering in the <code>video/broadcast</code> object. If the recording started successfully, the rendering of the broadcasted content is paused, i.e. a still-image video frame is shown. </p>
<p>If the timeshift mode is set to 2 (network resources) then the OITF shall follow the procedures defined in section <a href="#network-timeshift-of-broadcast-services" class="sectionRef"></a> and returns true. Since this operation is asynchronous when the procedure are executed successful the rendering of the broadcasted content is paused, i.e. a still-image video frame is shown, and <code>PlaySpeedChanged</code> event is generated. </p>
<p>If the specified timeshift mode is not supported, this method shall return false.  Otherwise, this method shall return true.  Acquiring the necessary resources to enable the specified timeshift mode may be an asynchronous operation; applications may receive updates of this process by registering a listener for <code>RecordingEvents</code> as defined in section <a href="#video-broadcast-extensions-recording-timeshift-events" class="sectionRef"></a>.</p>
<p>If trick play is not supported for the channel currently being rendered, this method shall return <code>false</code>, otherwise <code>true</code> is returned.  </p>
<p>This operation may be asynchronous, and presentation of the video may not pause until after this method returns. For this reason, a <code>PlaySpeedChanged</code> event will be generated when the operation has completed, regardless of the success of the operation. If the operation fails, the argument of the event SHALL be set to the previous play speed.</p>
</td></tr>
</table>
<table class="dae-method-table" id="video-broadcast-resume">
<tr><td colspan="2" class="api-signature">Boolean <b>resume</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Resumes playback of the time-shifted broadcast channel that is currently being rendered in the <code>video/broadcast</code> object at the speed specified by <a href="#video-broadcast-setspeed" class="apiRef">setSpeed()</a>. If the desired speed was not set via <a href="#video-broadcast-setspeed" class="apiRef">setSpeed()</a>, playback is resumed at normal speed (i.e. speed 1.0). If the <code>video/broadcast</code> object is currently not rendering a time-shifted channel, the OITF shall ignore the request to start playback and shall return <code>false</code>. If playback cannot be resumed the OITF shall also return <code>false</code>, otherwise <code>true</code> is returned.</p>
<p>This operation may be asynchronous, and presentation of the video may not resume until after this method returns. For this reason, a <code>PlaySpeedChanged</code> event will be generated when the operation has completed, regardless of the success of the operation. If the operation fails, the argument of the event SHALL be set to the previous play speed.</p>
<p>The action taken depends on the value of the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property.</p>
<p>If the value of the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property is 1 or 3 (local resources) then the OITF shall resume playback of the broadcast channel as specified above and return <code>true</code>.</p>
<p>If the value of the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property is 2 (network resources) then the OITF shall follow the procedures defined in section <a href="#video-broadcast-extensions-recording-timeshift-events" class="sectionRef"></a> and return <code>true</code>. Since this operation is asynchronous when the procedure is successfully executed a <code>PlaySpeedChanged</code> event is generated with current speed.</p>
<p>After initial operation of <code>resume()</code> several events may affect the operation.</p>
<p>If during fast forward the end of stream is reached the playback SHALL resume at normal speed and a <code>PlaySpeedChanged</code> event is generated. If the end of stream is reached due to end of content the playback will automatically be paused and a <code>PlaySpeedChanged</code> event is generated. Any resources used for time-shifting SHALL NOT be discarded.</p>
<p>If during rewinding the playback reaches the point that it cannot be rewound further, playback will automatically be paused (i.e. the play speed will be changed to 0) and a  <code>PlaySpeedChanged</code> event is generated.</p>
<p>If for any of these events <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> is set to 3 and local resources are not available anymore then network sources SHALL be used according to the procedures defined in section <a href="#video-broadcast-extensions-recording-timeshift-events" class="sectionRef"></a>. The OITF SHALL perform a smooth transition of the stream between local and network resources.</p></td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-setspeed">
<tr><td colspan="3" class="api-signature">Boolean <b>setSpeed</b>( Number speed )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Sets the playback speed of the time-shifted broadcast to the value <code>speed</code>, without changing the paused/resumed state of the time-shifted broadcast. </p>
<p>When playback is paused (i.e. by setting the play speed to 0), the last decoded frame of video is displayed.</p>
<p>If the time-shifted broadcast cannot be played at the desired speed, specified as a value relative to the normal playback speed, the playback speed will be set to the best approximation of speed.  Applications are not required to pause playback of the broadcast or take any other action before calling <code>setSpeed()</code>.</p>
<p>If the <code>video/broadcast</code> object is currently not rendering a time-shifted channel, the OITF shall ignore the request to change the playback speed and shall return <code>false</code>, otherwise <code>true</code> is returned.</p>
<p>This operation may be asynchronous, and presentation of the video may not be affected until after this method returns. For this reason, a <code>PlaySpeedChanged</code> event will be generated when the operation has completed, regardless of the success of the operation. If the operation fails, the argument of the event SHALL be set to the previous play speed.</p>
<p>The action taken depends on the value of the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property.</p>
<p>If the value of the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property is 1 or 3 (local resources) then the <code>setSpeed()</code> method sets the playback speed of the time-shifted broadcast to the value <code>speed</code>.</p>
<p>If the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> is set to 2 (network resources) the OITF shall follow the procedures defined in section <a href="#video-broadcast-extensions-recording-timeshift-events" class="sectionRef"></a> and return <code>true</code>. Since this operation is asynchronous when the procedure is successfully executed <code>PlaySpeedChanged</code> event is generated with the new speed.</p>
<p>After initial operation of <code>setSpeed()</code> several events may affect the operation.</p>
<p>If during fast forward the end of stream is reached the playback SHALL resume at normal speed and a <code>PlaySpeedChanged</code> event is generated. If the end of stream is reached due to end of content the playback will automatically be paused and a <code>PlaySpeedChanged</code> event is generated. Any resources used for time-shifting SHALL NOT be discarded.</p>
<p>If during rewinding the playback has reaches the point that it cannot be rewound further, playback SHALL resume at normal speed and a  <code>PlaySpeedChanged</code> event is generated.</p>
<p>If for any of these events if <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> is set to 3 and local resources are not available anymore then network sources SHALL be used according to the procedures defined in section <a href="#video-broadcast-extensions-recording-timeshift-events" class="sectionRef"></a>. The OITF SHALL perform a smooth transition of the stream between local and network resources.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">speed</td><td>The desired relative playback speed, specified as a float value relative to the normal playback speed of 1.0. A negative value indicates reverse playback. If the time-shifted broadcast cannot be played at the desired speed, the playback speed will be set to the best approximation.</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-seek">
<tr><td colspan="3" class="api-signature">Boolean <b>seek</b>( Integer offset, Integer reference )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Sets the playback position of the time-shifted broadcast that is being rendered in the <code>video/broadcast</code> object to the position specified by the offset and the reference point as specified by one of the constants defined in section <a href="#video-broadcast-extensions-recording-timeshift-constants" class="sectionRef"></a>. Returns <code>true</code> if the playback position is a valid position to seek to, <code>false</code> otherwise. If the <code>video/broadcast</code> object is currently not rendering a time-shifted channel or if the position falls outside the time-shift buffer, the OITF shall ignore the request to seek and shall return the value <code>false</code>.</p>
<p>Applications are not required to pause playback of the broadcast or take any other action before calling <code>seek()</code>.</p>
<p>This operation may be asynchronous, and presentation of the video may not be affected until after this method returns. For this reason, a <code>PlayPositionChanged</code> event will be generated when the operation has completed, regardless of the success of the operation. If the operation fails, the argument of the event SHALL be set to the previous play position.</p>
<p>The action taken depends on the value of the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> property.</p>
<p>If the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> is set to 1 (local resources) the <code>seek()</code> method sets the playback position of the time-shifted broadcast that is being rendered in the <code>video/broadcast</code> object as defined above. Playback of live content is resumed if the new position equals the end of the time-shift buffer. </p>
<p>If the <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> is set to 2 (network resources) the OITF shall follow the procedures defined in section <a href="#video-broadcast-extensions-recording-timeshift-events" class="sectionRef"></a> and return <code>true</code>. Since this operation is asynchronous when the procedure is successfully executed <code>PlayPositionChanged</code> event is generated with the new position.</p>
<p>Note that if <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> is set to 3 then local resources are used over network resources.</p>
<p>After initial operation of <code>seek()</code> several events may affect the operation.</p>
<p>If during fastforward the end of stream is reached the playback SHALL resume at normal speed and a <code>PlaySpeedChanged</code> event is generated. If the end of stream is reached due to end of content the playback will automatically be paused and a <code>PlaySpeedChanged</code> event is generated. Any resources used for time-shifting SHALL NOT be discarded.</p>
<p>If for any of these events if <a href="#video-broadcast-timeshiftmode" class="apiRef">timeShiftMode</a> is set to 3 and local resources are not available anymore then network sources SHALL be used according to the procedures defined in section <a href="#video-broadcast-extensions-recording-timeshift-events" class="sectionRef"></a>. The OITF SHALL perform a smooth transition of the stream between local and network resources.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">offset</td><td>The offset from the reference position, in seconds. This can be either a positive value to indicate a time later than the reference position or a negative value to indicate a time earlier than the reference position.</td></tr>
<tr><td class="dae-method-table-argument">reference</td><td>The reference point from which the offset SHALL be measured. The reference point can be either <code>POSITION_CURRENT</code>, <code>POSITION_START</code>, or <code>POSITION_END</code>.</td></tr>
</table>

<table class="dae-method-table" id="video-broadcast-stoptimeshift">
<tr><td colspan="2" class="api-signature">Boolean <b>stopTimeshift</b>( )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Stops rendering in time-shifted mode of the broadcast channel in the <code>video/broadcast</code> object and, if applicable, plays the current broadcast from the live point and stops time-shifting the broadcast. The OITF SHALL release all resources that were used to support time-shifted rendering of the broadcast.</p>
<p>Returns <code>true</code> if the time-shifted broadcast was successfully stopped and resources were released and <code>false</code> otherwise. If the <code>video/broadcast</code> object is currently not rendering a time-shifted channel, the OITF shall ignore the request to stop the time-shift and shall return the value <code>false</code>.
</p></td></tr>
</table>

<p>In addition to these methods, the OITF SHALL support an additional optional attribute &ldquo;<code>offSet</code>&rdquo; on the <a href="#video-broadcast-setchannel" class="apiRef">setChannel(Channel channel, Boolean trickplay, String contentAccessDescriptorURL)</a> method of the <code>video/broadcast</code> object as defined in section <a href="#video-broadcast-methods" class="sectionRef"></a>, if the OITF has indicated support for scheduled content over IP by defining one or more <code>ID_IPTV_*</code> values as part of the transport attribute of the <code>&lt;video_broadcast&gt;</code> element in the capability description.</p>

<table class="dae-method-table" id="video-broadcast-setchannel-with-offset">
<tr><td colspan="3" class="api-signature">void <b>setChannel</b>( <a href="#channel-class" class="apiRef">Channel</a> channel, Boolean trickplay, String contentAccessDescriptorURL, Integer offset )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Requests the OITF to switch a (logical or physical) tuner to the specified  channel and render the received broadcast content in the area of the browser allocated for the <code>video/broadcast</code> object, as specified by the <a href="#video-broadcast-setchannel" class="apiRef">setChannel(Channel channel, Boolean trickPlay, String contentAccessDescriptorURL)</a> method in section <a href="#video-broadcast-methods" class="sectionRef"></a>. </p>
<p>The additional <code>offSet</code> attribute optionally specifies the desired offset with respect to the live broadcast in number of seconds from which the OITF SHOULD start playback immediately after the channel switch (whereby offSet is given as a positive value for seeking to a time in the past). If an OITF cannot start playback from the desired position, as indicated by the specified <code>offSet</code> (e.g. because the OITF did not, or could not, record the specified channel prior to the call to <code>setChannel</code>), if the specified <code>offSet</code> is '0', or if the <code>offSet</code> is not specified, the OITF SHALL start playback from the live position after the specified channel switch.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="4">Arguments</td>
<td class="dae-method-table-argument">channel</td><td>As defined for method <a href="#video-broadcast-setchannel" class="apiRef">setChannel()</a> in section <a href="#video-broadcast-methods" class="sectionRef"></a>.</td></tr>
<tr><td class="dae-method-table-argument">trickplay</td><td>Optional flag as defined for method <a href="#video-broadcast-setchannel" class="apiRef">setChannel()</a> in section <a href="#video-broadcast-methods" class="sectionRef"></a>.</td></tr>
<tr><td class="dae-method-table-argument">contentAccessDescriptorURL</td><td>Optional flag as defined for method <a href="#video-broadcast-setchannel" class="apiRef">setChannel()</a> in section <a href="#video-broadcast-methods" class="sectionRef"></a>.</td></tr>
<tr><td class="dae-method-table-argument">offset</td><td>The optional offset attribute MAY be used to specify the desired offset with respect to the live broadcast in number of seconds from which the OITF SHOULD start playback immediately after the channel switch (whereby offset is given as a negative value for seeking to a time in the past).</td></tr>
</table>
</section>
<section id="video-broadcast-extensions-recording-timeshift-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated, in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#video-broadcast-onrecordingevent" class="apiRef">onRecordingEvent</a></td><td>RecordingEvent</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>state</code>, <code>error</code>, <code>recordingId</code></td></tr>
<tr><td><a href="#video-broadcast-onplayspeedchanged" class="apiRef">onPlaySpeedChanged</a></td><td>PlaySpeedChanged</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>speed</code></td></tr>
<tr><td><a href="#video-broadcast-onplaypositionchanged" class="apiRef">onPlayPositionChanged</a></td><td>PlayPositionChanged</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>position</code></td></tr>
<tr><td><a href="#video-broadcast-onplayspeedsarraychanged" class="apiRef">onPlaySpeedsArrayChanged</a></td><td>PlaySpeedsArrayChanged</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: None
</td></tr>
</table>
Note: the DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>video/broadcast</code> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>

<section id="video-broadcast-extensions-eit-pf">
<h3>Extensions to video/broadcast for access to EIT p/f</h3>
<p>The following properties and events SHALL be added to the <code>video/broadcast</code> embedded object, if the OITF has indicated support for accessing DVB-SI EIT p/f information, by giving the value &ldquo;<code>true</code>&rdquo; to element <code>&lt;clientMetadata&gt;</code> and the value &ldquo;<code>eit-pf</code>&rdquo; or &ldquo;<code>dvb-si</code>&rdquo; to the <code>type</code> attribute of that element as defined in section <a href="#OITF-metadata-api-support" class="sectionRef"></a> in their capability profile.</p>
<p>Access to these properties SHALL adhere to the security model in section <a href="#dae-security" class="sectionRef"></a>. The associated permission name is &ldquo;<i>permission_metadata</i>&rdquo;.</p>
<table class="dae-property-table" id="video-broadcast-programmes">
<tr><td class="api-signature">readonly <a href="#programmecollection-class" class="apiRef">ProgrammeCollection</a> <b>programmes</b></td></tr>
<tr><td><p>The collection of programmes available on the currently tuned channel. This list is a <a href="#programmecollection-class" class="apiRef">ProgrammeCollection</a> as defined in section <a href="#programmecollection-class" class="sectionRef"></a> and is ordered by start time, so index 0 will always refer to the present programme (if this information is available).</p>
<p>If the type attribute of the <code>&lt;clientMetadata&gt;</code> element in the OITF's capability description has the value &ldquo;<code>eit-pf</code>&rdquo;, this list SHALL at least provide <a href="#programme-class" class="apiRef">Programme</a> objects as defined in section <a href="#programme-class" class="sectionRef"></a> for the present and the directly following programme on the currently tuned channel, if that information is available. In other words, the DAE application should not expect <code>programmes.length</code> to be larger than 2.</p>
<p>If the <code>video/broadcast</code> object is not currently tuned to a channel, or if the present/following information has not yet been retrieved (e.g. the object has just tuned to a new channel and present/following information has not yet been broadcast), or if present/following information is not available for the current channel, the length of this collection SHALL be 0.</p>
<p>If the type attribute of the <code>&lt;clientMetadata&gt;</code> element in the OITF's capability description has a value other than &ldquo;<code>eit-pf</code>&rdquo;, an OITF MAY populate this field from other metadata sources described in [[.OIPF_META2]].</p>
<p>The programmes.length property SHALL indicate the number of items that are currently known and up to date (i.e. whereby the &ldquo;<a href="#programme-starttime" class="apiRef">startTime</a> + <a href="#programme-duration" class="apiRef">duration</a>&rdquo; is not smaller than the current time). This may be 0 if no programme information is currently known for the currently tuned channel.</p>
<p>In order to prevent misuse of this information, access to this property SHALL adhere to the security model in section <a href="#dae-security" class="sectionRef"></a>. The associated permission name is &ldquo;<i>permission_metadata</i>&rdquo;.</p></td></tr>
</table>
<table class="dae-property-table" id="video-broadcast-onprogrammeschanged">
<tr><td class="api-signature">function <b>onProgrammesChanged</b>( )</td></tr>
<tr><td>The function that is called when the <a href="#video-broadcast-programmes" class="apiRef">programmes</a> property has been updated with new programme information, e.g. when the current broadcast programme is finished and a new one has started. The specified function is called with no arguments.</td></tr>
</table>

<section id="video-broadcast-extensions-eit-pf-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#video-broadcast-onprogrammeschanged" class="apiRef">onProgrammesChanged</a></td><td>ProgrammesChanged</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
</table>
Note: this DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <code>video/broadcast</code> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>

<section id="video-broadcast-extensions-selected-components">
<h3>Extensions to video/broadcast for playback of selected components</h3>
To support the selection of specific A/V components for playback (e.g. a specific subtitle language, audio language, or camera angle), the classes defined in sections <a href="#avcomponent-class" class="sectionRef"></a> &mdash; <a href="#avsubtitlecomponent-class" class="sectionRef"></a> SHALL be supported and the constants, properties and methods defined in section <a href="#media-playback-extensions" class="sectionRef"></a> SHALL be supported on the <code>video/broadcast</code> object.
</section>
<section id="video-broadcast-extensions-parental-ratings">
<h3>Extensions to video/broadcast for parental ratings errors</h3>
For parental rating related errors or changes during playback of A/V content through the <code>video/broadcast</code> object an OITF SHALL support the following intrinsic event properties and corresponding DOM events for the <code>video/broadcast</code> object:

<table class="dae-property-table" id="video-broadcast-onparentalratingchange">
<tr><td class="api-signature">function <b>onParentalRatingChange</b>( String contentID, <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> ratings, String DRMSystemID, Boolean blocked )</td></tr>
<tr><td><p>The function that is called whenever the parental rating of the content being played inside the embedded object changes.</p>
<p>These events may occur at the start of a new content item, or during playback of a content item (e.g. during playback of linear TV content).</p>
<p>The specified function is called with four arguments <code>contentID</code>, <code>ratings</code>, <code>DRMSystemID</code> and <code>blocked</code> which are defined as follows:</p><ul>
<li><code>String contentID</code> &mdash; the content ID to which the parental rating change applies. If the event is generated by the DRM system, it SHALL be the unique identifier for that content in the context of the DRM system  (i.e. in the case of Marlin BB it is the Marlin contentID, in the case of CSPG-CI+ the value of this field is <code>null</code>). Otherwise it MAY be <code>null</code> or <code>undefined</code>.
<li><code><a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> ratings</code> &mdash; the parental ratings of the currently playing content. The <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> object is defined in section <a href="#parentalratingcollection-class" class="sectionRef"></a>.
<li><code>String DRMSystemID</code> &mdash; the DRM System ID of the DRM system that generated the event as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. The value SHALL be <code>null</code> if the parental control is not enforced by a particular DRM system.
<li><code>Boolean blocked</code> &mdash; flag indicating whether consumption of the content is blocked by the parental control system as a result of the new parental rating value.
</ul></td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-onparentalratingerror">
<tr><td class="api-signature">function <b>onParentalRatingError</b>( String contentID, <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> ratings, String DRMSystemID )</td></tr>
<tr><td>
<p>The function that is called when a parental rating error occurs during playback of A/V content inside the embedded object, and is triggered whenever one or more parental ratings are discovered and none of them are valid. A valid parental rating is defined as one which uses a parental rating scheme that is supported by the OITF and which has a parental rating value that is supported by the OITF.</p>
<p>The specified function is called with three arguments <code>contentID</code>, <code>ratings</code> and <code>DRMSystemID</code> which are defined as follows:</p><ul>
<li><code>String contentID</code> &mdash; the content ID to which the parental rating change applies. If the event is generated by the DRM system, it SHALL be the unique identifier for that content in the context of the DRM system  (i.e. in the case of Marlin BB it is the Marlin contentID, in the case of CSPG-CI+ the value of this field is <code>null</code>). Otherwise it MAY be <code>null</code> or <code>undefined</code>.
<li><code><a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> ratings</code> &mdash; the parental ratings of the currently playing content. The <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> object is defined in section <a href="#parentalratingcollection-class" class="sectionRef"></a>.
<li><code>String DRMSystemID</code> &mdash; optional argument that specifies the DRM System ID of the DRM system that generated the event as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. The value SHALL be <code>null</code> if the parental control is not enforced by a particular DRM system.
</ul></td></tr>
</table>

<section id="video-broadcast-extensions-parental-ratings-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated, in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#video-broadcast-onparentalratingchange" class="apiRef">onParentalRatingChange</a></td><td>ParentalRatingChange</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>contentID</code>, <code>ratings</code>, <code>DRMSystemID</code>, <code>blocked</code>
</td></tr>
<tr><td><a href="#video-broadcast-onparentalratingerror" class="apiRef">onParentalRatingError</a></td><td>ParentalRatingError</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>contentID</code>, <code>ratings</code>, <code>DRMSystemID</code>
</td></tr>
</table>
Note: the above DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving a ParentalRatingError event during the bubbling or the capturing phase. The Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>video/broadcast</code> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>


<section id="video-broadcast-extensions-drm-errors">
<h3>Extensions to video/broadcast for DRM rights errors</h3>
<p>This section SHALL apply to OITF and/or server devices which have indicated support for DRM protection by providing one or more <code>&lt;drm&gt;</code> elements as specified in section <a href="#drm-capability-indication" class="sectionRef"></a>:</p>
<p>For notifying JavaScript about DRM licensing errors during playback of DRM protected A/V content through the &ldquo;<code>video/broadcast</code>&rdquo; object, an OITF SHALL support the following intrinsic event property and corresponding DOM event for the &ldquo;<code>video/broadcast</code>&rdquo; object:</p>
<table class="dae-property-table" id="video-broadcast-ondrmrightserror">
<tr><td class="api-signature">function <b>onDRMRightsError</b>( Integer errorState, String contentID, String DRMSystemID, String rightsIssuerURL )</td></tr>
<tr><td>
<p>The function that is called:</p><ul>
<li>Whenever a rights error occurs for the A/V content (no license, license invalid), which has led to blocking consumption of the content.
<li>Whenever a rights change occurs for the A/V content (license valid), which leads to unblocking the consumption of the content.
</ul>
<p>This may occur during playback, recording or timeshifting of DRM protected AV content.</p> 
<p>The specified function is called with four arguments <code>errorState</code>, <code>contentID</code>, <code>DRMSystemID</code> and <code>rightsIssuerURL</code> which are defined as follows:</p><ul>
<li><code>Integer errorState</code> &mdash; error code detailing the type of error:<ul class="nobullet">
<li>0:   no license, consumption of the content is blocked.
<li>1:   invalid license, consumption of the content is blocked.
<li>2:   valid license, consumption of the content is unblocked.
</ul>
<li><code>String contentID</code> &mdash; the unique identifier of the protected content in the scope of the DRM system that raises the error (i.e. in the case of Marlin BB it is the Marlin contentID, in the case of CSPG-CI+ the value of this field is <code>null</code>). 
<li><code>String DRMSystemID</code> &mdash; DRMSystemID as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For example, for Marlin, the DRMSystemID value is &ldquo;<code>urn:dvb:casystemid:19188</code>&rdquo;.
<li><code>String rightsIssuerURL</code> &mdash; optional element indicating the value of the rightsIssuerURL that can be used to non-silently obtain the rights for the content item currently being played for which this DRM error is generated, in cases whereby the <code>rightsIssuerURL</code> is known. Cases whereby the <code>rightsIssuerURL</code> is known include cases whereby the <code>rightsIssuerURL</code> has been extracted from the MPEG2_TS of the protected content, retrieved from the SD&amp;S discovery record or from the associated BCG metadata. The corresponding <code>rightsIssuerURL</code> fields are defined in <mark class="error">section 4.1.3.4 of [[.OIPF_CSP2]]</mark> and in <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]] respectively. If different URLs are retrieved from the stream and the metadata, then the conflict resolution is implementation-dependent.
<div class="editor-note">No version of the OIPF CSP specification has contained a section 4.1.3.4 - the required information/reference may be in a different section</div>
</ul></td></tr>
</table>
<p>For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated, in the following manner:</p>
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#video-broadcast-ondrmrightserror" class="apiRef">onDRMRightsError</a></td><td>DRMRightsError</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>errorState</code>, <code>contentID</code>, <code>DRMSystemID</code>, <code>rightsIssuerURL</code></td></tr>
 </table>
<p>Note: the above DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving a DRMRightsError event during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <code>video/broadcast</code> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>

<section id="video-broadcast-extensions-current-channel-info">
<h3>Extensions to video/broadcast for current channel information</h3>
<p>If an OITF has indicated support for extended tuner control (i.e. by giving value true to element <code>&lt;extendedAVControl&gt;</code> as specified in section <a href="#extended-av-api-support" class="sectionRef"></a> in its capability description), the OITF SHALL support the following additional properties and methods on the video/broadcast object.</p>
<p>The functionality as described in this section is subject to the security model of section <a href="#security-requirements-for-service-provider-controlled-oitf" class="sectionRef"></a>.</p>
<p>Note the property <a href="#channelconfig-onchannelscan" class="apiRef">onChannelScan</a> and methods <a href="#channelconfig-startscan" class="apiRef">startScan</a> and <a href="#channelconfig-stopscan" class="apiRef">stopScan</a> have been moved to section <a href="#channelconfig-class" class="sectionRef"></a>.</p>
<section id="video-broadcast-extensions-current-channel-info-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="video-broadcast-currentchannel">
<tr><td class="api-signature">readonly <a href="#channel-class" class="apiRef">Channel</a> <b>currentChannel</b></td></tr>
<tr><td>
<p>The channel currently being presented by this embedded object if the user has given permission to share this information, possibly through a mechanism outside the scope of this specification. If no channel is being presented, or if this information is not visible to the caller, the value of this property SHALL be null. </p>
<p>The value of this property is not affected during timeshift operations and SHALL reflect the value prior to the start of a timeshift operation, for both local and network timeshift resources.</p></td></tr>
</table>
</section>
</section>

<section id="video-broadcast-extensions-current-channel-lists">
<h3>Extensions to video/broadcast for creating channel lists from SD&amp;S fragments</h3>
NOTE: the method <a href="#channelconfig-createchannellist" class="apiRef">createChannelList()</a> has been moved to section <a href="#channelconfig-class" class="sectionRef"></a>.
</section>

<section id="channelconfig-class">
<h3>The ChannelConfig class</h3>
<p>The <code>ChannelConfig</code> class provides the entry point for applications to get information about the list of channels available. It can be obtained in two ways:</p><ul>
<li>By calling the method <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a> of the <code>video/broadcast</code> embedded object as defined in section <a href="#video-broadcast-methods" class="sectionRef"></a>.
<li>By calling the method <a href="#object-factory-api-non-visual-objects" class="apiRef">createChannelConfig()</a> of the object factory API as defined in section <a href="#object-factory-api-methods" class="sectionRef"></a>.
</ul>
<p>The availability of the properties and methods are dependent on the capabilities description as specified in section <a href="#client-capability-description" class="sectionRef"></a>. The following table provides a list of the capabilities and the associated properties and methods. If the capability is false the properties and methods SHALL NOT be available to the application. Properties and methods not listed in the following table SHALL be available to all applications as long as the OITF has indicated support for tuner control (i.e.  <code>&lt;video_broadcast&gt;true&lt;/video_broadcast&gt;</code> as defined in section <a href="#tuner-broadcast-capability" class="sectionRef"></a>) in their capability.</p>
<table class="simple">
<tr><th>Capability</th><th>Properties</th><th>Methods</th></tr>
<tr><td>Element <code>&lt;extendedAVControl&gt;</code> is set to &ldquo;<code>true</code>&rdquo; as defined in section <a href="#extended-av-api-support" class="sectionRef"></a>.</td><td><a href="#channelconfig-onchannelscan" class="apiRef">onChannelScan</a></td><td><a href="#channelconfig-startscan" class="apiRef">startScan()</a><br /><a href="#channelconfig-stopscan" class="apiRef">stopScan()</a></td></tr>
<tr><td>Element <code>&lt;video_broadcast type="ID_IPTV_SDS"&gt;</code> is set as defined in section <a href="#extended-av-api-support" class="sectionRef"></a>. </td><td></td><td><a href="#channelconfig-createchannellist" class="apiRef">createChannelList()</a></td></tr>
</table>
<p>The functionality as described in this section is subject to the security model of section <a href="#security-requirements-for-exposure-of-the-tuner-channel-lineup" class="sectionRef"></a> (for obtaining a <code>ChannelConfig</code> object) and section <a href="#security-requirements-for-service-provider-controlled-oitf" class="sectionRef"></a> (for properties and methods covered by the <code>&lt;extendedAVControl&gt;</code> capability as defined below).</p>

<section id="channelconfig-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="channelconfig-channellist">
<tr><td class="api-signature">readonly <a href="#channellist-class" class="apiRef">ChannelList</a> <b>channelList</b></td></tr>
<tr><td>
<p>The list of channels. </p>
<p>If an OITF includes a platform-specific application that enables the end-user to choose a channel to be presented from a list then all the channels in the list offered to the user by that application SHALL be included in this ChannelList.</p>
<p>The list of channels will be a subset of all those available to the OITF. The precise algorithm by which this subset is selected will be market and/or implementation dependent. For example;</p><ul>
<li>If an OITF with a DVB-T tuner receives multiple versions of the same channel, one would be included in the list and the duplicates discarded
<li>An OITF with a DVB tuner will often filter services based on service type to discard those which are obviously inappropriate or impossible for that device to present to the end-user, e.g. firmware download services.
</ul>
<p>The order of the channels in the list corresponds to the channel ordering as managed by the OITF. SHALL return the value <code>null</code> if the channel list is not (partially) managed by the OITF (i.e., if the channel list information is managed entirely in the network). </p>
<p>The properties of channels making up the channel list SHALL be set by the OITF to the appropriate values as determined by the tables in section <a href="#mapping-apis-to-content-formats-channel" class="sectionRef"></a>. The OITF SHALL store all these values as part of the channel list. </p>
<p>Some values are set according to the data carried in the broadcast stream. In this case, the OITF MAY set these values to <code>undefined</code> until such time as the relevant data has been received by the OITF, for example after tuning to the channel. Once the data has been received, the OITF SHALL update the properties of the channel in the channel list according to the received data.</p>
<p>Note: There is no requirement for the OITF to pro-actively tune to every channel to gather such data.</p></td></tr>
</table>

<table class="dae-property-table" id="channelconfig-favouritelists">
<tr><td class="api-signature">readonly <a href="#favouritelistcollection-class" class="apiRef">FavouriteListCollection</a> <b>favouriteLists</b></td></tr>
<tr><td>A list of favourite lists. SHALL return the value null if the favourite lists are not (partially) managed by the OITF (i.e., if the favourite lists information is managed entirely in the network).</td></tr>
</table>

<table class="dae-property-table" id="video-broadcast-currentfavouritelist">
<tr><td class="api-signature">readonly <a href="#favouritelist-class" class="apiRef">FavouriteList</a> <b>currentFavouriteList</b></td></tr>
<tr><td><p>Currently active Favourite channel list object.  If <code>currentFavouriteList</code> is <code>undefined</code>, no favourite filter list is currently applied.</p>
<p>The OITF SHALL return the value <code>null</code> if the favourite lists are not (partially) managed by the OITF (i.e. if the favourite lists information is managed entirely in the network).</p></td></tr>
</table>

<table class="dae-property-table" id="channelconfig-onchannelscan">
<tr><td class="api-signature">function <b>onChannelScan</b>( Integer scanEvent, Integer progress, Integer frequency, Integer signalStrength, Integer channelNumber, Integer channelType, Integer channelCount, Integer transponderCount, <a href="#channel-class" class="apiRef">Channel</a> newChannel )</td></tr>
<tr><td><p>This function is the DOM 0 event handler for events relating to channel scanning. On IP-only receivers, setting this property SHALL have no effect.</p>
<p>The specified function is called with the following arguments:</p><ul>
<li><code>Integer scanEvent</code> - The type of event.  Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>0</td><td>A channel scan has started.</td></tr>
<tr><td>1</td><td>Indicates the current progress of the scan.</td></tr>
<tr><td>2</td><td>A new channel has been found.</td></tr>
<tr><td>3</td><td>A new transponder has been found.</td></tr>
<tr><td>4</td><td>A channel scan has completed.</td></tr>
<tr><td>5</td><td>A channel scan has been aborted.</td></tr>
</table>
<li><code>Integer progress</code> - the progress of the scan.  Valid values are in the range 0 - 100, or -1 if the progress is unknown.
<li><code>Integer frequency</code> - The frequency of the transponder in kHz (for scans on RF sources only).
<li><code>Integer signalStrength</code> - The signal strength for the current channel. Valid values are in the range 0 - 100, or   -1 if the signal strength is unknown.
<li><code>Integer channelNumber</code> - The logical channel number of the channel that has been found.
<li><code>Integer channelType</code> - The type of channel that has been found.  Valid values are the same as for <a href="#channel-channeltype" class="apiRef">Channel.channelType</a>.
<li><code>Integer channelCount</code> - The total number of channels found so far during the scan.
<li><code>Integer transponderCount</code> - The total number of transponders found so far during the scan (RF sources only).
<li><code><a href="#channel-class" class="apiRef">Channel</a> newChannel</code> - When scanEvent equals 2, this argument provides a reference to the <a href="#channel-class" class="apiRef">Channel</a> object that represents the newly identified channel. For other <code>scanEvent</code> values this argument SHALL be <code>null</code>
</ul></td></tr>
</table>

<table class="dae-property-table" id="channelconfig-onchannellistupdate">
<tr><td class="api-signature">function <b>onChannelListUpdate</b>( )</td></tr>
<tr><td>This function is the DOM 0 event handler for events relating to channel list updates. Upon receiving a <code>ChannelListUpdate</code> event, if an application has references to any <a href="#channel-class" class="apiRef">Channel</a> objects then it SHOULD dispose of them and rebuild its references. Where possible <a href="#channel-class" class="apiRef">Channel</a> objects are updated rather than removed, but their order in the <code>ChannelConfig.all</code> collection MAY have changed. Any lists created with <a href="#channelconfig-createfilteredlist" class="apiRef">ChannelConfig.createFilteredList()</a> SHOULD be recreated in case channels have been removed.</td></tr>
</table>

<table class="dae-property-table" id="channelconfig-currentchannel">
<tr><td class="api-signature">readonly <a href="#channel-class" class="apiRef">Channel</a> <b>currentChannel</b></td></tr>
<tr><td><p>The current channel of the OITF if the user has given permission to share this information, possibly through a mechanism outside the scope of this specification. If no channel is being  presented, or if this information is not visible to the caller, the value of this property SHALL be <code>null</code>.</p>
<p>In an OITF where exactly one <code>video/broadcast</code> object is in any state other than Unrealized and the channel being presented by that <code>video/broadcast</code> object is the only broadcast channel being presented by the OITF then changes to the channel presented by that <code>video/broadcast</code> object SHALL result in changes to the current channel of the OITF.</p>
<p>In an OITF which is presenting more than one broadcast channel at the same time, the current channel of the OITF is the channel whose audio is being presented (as defined in the <a href="#video-broadcast-bindtocurrentchannel" class="apiRef">bindToCurrentChannel()</a> method). If that current channel is under the control of a DAE application via a <code>video/broadcast</code> object then changes to the channel presented by that <code>video/broadcast</code> object SHALL result in changes to the current channel of the OITF.</p>
</td></tr>
</table>
</section>

<section id="channelconfig-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="channelconfig-createfilteredlist">
<tr><td colspan="3" class="api-signature"><a href="#channellist-class" class="apiRef">ChannelList</a> <b>createFilteredList</b>( Boolean blocked, Boolean favourite, Boolean hidden, String favouriteListID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Create a filtered list of channels. Returns a subset of <a href="#channelconfig-channellist" class="apiRef">ChannelConfig.channelList</a>.</p>
<p>The blocked, favourite and hidden flags indicate whether a channel is included in the returned list.  These flags correspond to the properties on Channel with the same names. Each flag MAY be set to one of three values:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Meaning</th></tr>
<tr><td>true</td><td>The channel is added if and only if the corresponding property has the value true.</td></tr>
<tr><td>false</td><td>The channel is added if and only if the corresponding property has the value false.</td></tr>
<tr><td>undefined</td><td>The channel is added regardless of the state of the corresponding property.</td></tr>
</table>
<p>A channel will only be added to the list if the values of all three flags allow it to be added. </p>
<p>The <code>favouriteListID</code> attribute is used to select a particular <code>favouriteList</code> that the <code>createFilteredList</code> method uses as a basis of the filtering process. If <code>favouriteListID</code> is the empty string (i.e. &ldquo;&rdquo;), then the filtering is performed on all available channels as defined by <a href="#channelconfig-channellist" class="apiRef">ChannelConfig.channelList</a>.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="4">Arguments</td>
<td class="dae-method-table-argument">blocked</td><td>Flag indicating whether manually blocked channels SHALL be added to the list.</td></tr>
<tr><td class="dae-method-table-argument">favourite</td><td>Flag indicating whether favourite channels SHALL be added to the list.</td></tr>
<tr><td class="dae-method-table-argument">hidden</td><td>Flag indicating whether hidden channels SHALL be added to the list.</td></tr>
<tr><td class="dae-method-table-argument">favouriteListID</td><td><p>If the value of the favourite flag is <code>true</code>, indicates which favourites list SHALL be filtered upon.</p></td></tr>
</table>

<table class="dae-method-table" id="channelconfig-startscan">
<tr><td colspan="3" class="api-signature">void <b>startScan</b>( <a href="#channelscanoptions-class" class="apiRef">ChannelScanOptions</a> options, <a href="#channelscanparameters-class" class="apiRef">ChannelScanParameters</a> scanParameters )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Start a scan for new channels on all available sources.  When each source finishes scanning, an <code>UpdateEvent</code> SHALL be raised with the type <code>CHANNELS_INVALIDATED</code> and any channel lists for that source SHALL have been updated.</p>
<p>On IP-only receivers, this method SHALL have no effect.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">options</td><td>The options to the channel scan operation.</td></tr>
<tr><td class="dae-method-table-argument">scanParameters</td><td>The tuning parameters to be scanned. The value of this argument SHALL be one of the classes that implement the <a href="#channelscanparameters-class" class="apiRef">ChannelScanParameters</a> interface and SHALL NOT be an instance of the <a href="#channelscanparameters-class" class="apiRef">ChannelScanParameters</a> class.</td></tr>
</table>

<table class="dae-method-table" id="channelconfig-stopscan">
<tr><td colspan="2" class="api-signature">void <b>stopScan</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Stop a channel scan, if one is in progress.  Any sources that have not finished scanning SHALL have their scans aborted and channel line-ups for SHALL NOT be changed.</p>
<p>On IP-only receivers, this method SHALL have no effect.</p>
</td></tr>
</table>

<table class="dae-method-table" id="channelconfig-createchannellist">
<tr><td colspan="3" class="api-signature"><a href="#channellist-class" class="apiRef">ChannelList</a> <b>createChannelList</b>( String bdr )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Creates a <a href="#channellist-class" class="apiRef">ChannelList</a> object from the specified SD&amp;S Broadcast Discovery Record. Channels in the returned channel list will not be included in the channel list that can be retrieved via calls to <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a>.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">bdr</td><td>An XML-encoded string containing an SD&amp;S Broadcast Discovery Record as specified in [[.OIPF_META2]]. If the string is not a valid Broadcast Discovery Record, this method SHALL return <code>null</code>.</td></tr>
</table>

<table class="dae-method-table" id="channelconfig-createchannelobject">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>createChannelObject</b>( Integer idType, Integer onid, Integer tsid, Integer sid, Integer sourceID, String ipBroadcastID )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Creates a <a href="#channel-class" class="apiRef">Channel</a> object of the specified <code>idType</code>. The <a href="#channel-class" class="apiRef">Channel</a> object can subsequently be used by the <a href="#video-broadcast-setchannel" class="apiRef">setChannel</a> method to switch a tuner to a channel that is not part of the channel list which was conveyed by the OITF to the server. The scope of the resulting <a href="#channel-class" class="apiRef">Channel</a> object is limited to the JavaScript environment (incl. <code>video/broadcast</code> object) to which the <a href="#channel-class" class="apiRef">Channel</a> object is returned, i.e. it does not get added to the channellist available through method <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig</a>.
<p>If the channel of the given <code>idType</code> cannot be created or the given (combination of) arguments are not considered valid or complete, the method SHALL return <code>null</code>.</p>
<p>If the channel of the given type can be created and arguments are considered valid and complete, the method SHALL return a <a href="#channel-class" class="apiRef">Channel</a> object whereby at a minimum the properties with the same names are given the same value as the given arguments of the <code>createChannelObject</code> method. The values specified for the remaining properties of the <a href="#channel-class" class="apiRef">Channel</a> object are set to <code>undefined</code>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="6">Arguments</td>
<td class="dae-method-table-argument">idType</td><td>The type of channel, as indicated by one of the <code>ID_*</code> constants defined in section <a href="#channel-constants" class="sectionRef"></a>.</td></tr>
<tr><td class="dae-method-table-argument">onid</td><td>The original network ID. Optional argument that SHALL be specified when the <code>idType</code> specifies a channel of type <code>ID_DVB_*</code> or <code>ID_ISDB_*</code>.</td></tr>
<tr><td class="dae-method-table-argument">tsid</td><td>The transport stream ID. Optional argument that MAY be specified when the <code>idType</code> specifies a channel of type <code>ID_DVB_*</code> or <code>ID_ISDB_*</code>.</td></tr>
<tr><td class="dae-method-table-argument">sid</td><td>The service ID. Optional argument that SHALL be specified when the <code>idType</code> specifies a channel of type <code>ID_DVB_*</code> or <code>ID_ISDB_*</code>.</td></tr>
<tr><td class="dae-method-table-argument">sourceID</td><td>The source_ID. Optional argument that SHALL be specified when the <code>idType</code> specifies a channel of type <code>ID_ATSC_T</code>.</td></tr>
<tr><td class="dae-method-table-argument">ipBroadcastID</td><td>The DVB textual service identifier of the IP broadcast service, specified in the format &ldquo;<code>ServiceName.DomainName</code>&rdquo;, or the URI of the IP broadcast service. Optional argument that SHALL be specified when the <code>idType</code> specifies a channel of type <code>ID_IPTV_SDS</code> or <code>ID_IPTV_URI</code>.</td></tr>
</table>

<table class="dae-method-table" id="channelconfig-createchannelscanparametersobject">
<tr><td colspan="3" class="api-signature"><a href="#channelscanparameters-class" class="apiRef">ChannelScanParameters</a> <b>createChannelScanParametersObject</b>( Integer idType )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Create an instance of one of the subclasses of the <a href="#channelscanparameters-class" class="apiRef">ChannelScanParameters</a> class (or one of its subclasses).  The exact subclass that will be returned SHALL be determined by the value of the <code>idType</code> parameter.</p>
<p>Initial values of all properties on the returned object SHALL be <code>undefined</code>.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">idType</td><td>The type of object to be created.  Valid values are given by the following constants on the <a href="#channel-class" class="apiRef">Channel</a> class (see section <a href="#channel-constants" class="sectionRef"></a>):<ul>
<li><code>ID_DVB_T</code> or <code>ID_DVB_T2</code> &mdash; returns an instance of the <a href="#dvbtchannelscanparameters-class" class="apiRef">DVBTChannelScanParameters</a> class.
<li><code>ID_DVB_C</code> or <code>ID_DVB_C2</code> &mdash; returns an instance of the <a href="#dvbcchannelscanparameters-class" class="apiRef">DVBCChannelScanParameters</a> class.
<li><code>ID_DVB_S</code> or <code>ID_DVB_S2</code> &mdash; returns an instance of the <a href="#dvbschannelscanparameters-class" class="apiRef">DVBSChannelScanParameters</a> class.
<li><code>ID_ATSC_T</code> &mdash; returns an instance of the <a href="#atsctchannelscanparameters-class" class="apiRef">ATSCTChannelScanParameters</a> class.
</ul>
All other values, or channel types which are not supported by the OITF, SHALL cause this method to return null.
</td></tr>
</table>

<table class="dae-method-table" id="channelconfig-createchannelscanoptionsobject">
<tr><td colspan="2" class="api-signature"><a href="#channelscanoptions-class" class="apiRef">ChannelScanOptions</a> <b>createChannelScanOptionsObject</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1">Create an instance of the <a href="#channelscanoptions-class" class="apiRef">ChannelScanOptions</a> class. Initial values of all properties on the returned object SHALL be <code>undefined</code>.</td></tr>
</table>
</section>

<section id="channelconfig-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated, in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#channelconfig-onchannelscan" class="apiRef">onChannelScan</a></td><td>ChannelScan</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>scanEvent</code>, <code>progress</code>, <code>frequency</code>, <code>signalStrength</code>, <code>channelNumber</code>, <code>channelType</code>, <code>channelCount</code>, <code>transponderCount</code>, <code>newChannel</code>
</td></tr>
<tr><td><a href="#channelconfig-onchannellistupdate" class="apiRef">onChannelListUpdate</a></td><td>ChannelListUpdate</td><td>Bubbles: No<br />Cancellable: No <br />Context Info: None
</td></tr>
</table>
Note: the above DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <code>ChannelConfig</code> object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>


<section id="channellist-class">
<h3>The ChannelList class</h3>
<pre>
typedef Collection&lt;<a href="#channel-class" class="apiRef">Channel</a>&gt; ChannelList
</pre>
<p>A <code>ChannelList</code> represents a collection of <a href="#channel-class" class="apiRef">Channel</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.</p>
<p>In addition to the methods and properties defined for generic collections, the <code>ChannelList</code> class supports the additional properties and methods defined below</p>
<section id="channellist-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="channellist-getchannel">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>getChannel</b>( String channelID )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Return the first channel in the list with the specified channel identifier. Returns <code>null</code> if no corresponding channel can be found.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">channelID</td><td>The channel identifier of the channel to be retrieved, which is a value as defined for the <a href="#channel-ccid" class="apiRef">ccid</a> and <a href="#channel-ipbroadcastid" class="apiRef">ipBroadcastID</a> properties of the <a href="#channel-class" class="apiRef">Channel</a> object as defined in section <a href="#channel-class" class="sectionRef"></a>.</td></tr>
</table>

<table class="dae-method-table" id="channellist-getchannelbytriplet">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>getChannelByTriplet</b>( Integer onid, Integer tsid, Integer sid, Integer nid )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Return the first (IPTV or non-IPTV) channel in the list that matches the specified DVB or ISDB triplet (original network ID, transport stream ID, service ID).</p>
<p>Where no channels of type ID_ISDB_* or ID_DVB_* are available, or no channel identified by this triplet are found, this method SHALL return <code>null</code>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="4">Arguments</td>
<td class="dae-method-table-argument">onid</td><td>The original network ID of the channel to be retrieved.</td></tr>
<tr><td class="dae-method-table-argument">tsid</td><td>The transport stream ID of the channel to be retrieved. If set to <code>null</code> the client SHALL retrieve the channel defined by the combination of onid and sid. This makes it possible to retrieve the correct channel also in case a remultiplexing took place which led to a changed tsid.</td></tr>
<tr><td class="dae-method-table-argument">sid</td><td>The service ID of the channel to be retrieved.</td></tr>
<tr><td class="dae-method-table-argument">nid</td><td>An optional argument, indicating the network id to be used select the channel when the channel list contains more than one entry with the same <code>onid</code>, <code>tsid</code> and <code>sid</code>.</td></tr>
</table>

<table class="dae-method-table" id="channellist-getchannelbysourceid">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>getChannelBySourceID</b>( Integer sourceID )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Return the first (IPTV or non-IPTV) channel in the list with the specified ATSC source ID.</p>
<p>Where no channels of  type ID_ATSC_* are available, or no channel with the specified source ID is found in the channel list, this method SHALL return <code>null</code>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">sourceID</td><td>The ATSC source_ID of the channel to be returned.</td></tr>
</table>
</section>
</section>

<section id="channel-class">
<h3>The Channel class</h3>
<p>The <code>Channel</code> object represents a broadcast stream or service. </p>
<p><code>Channel</code> objects typically represent channels stored in the channel list (see section <a href="#channellist-class" class="sectionRef"></a>). <code>Channel</code> objects may also represent locally defined channels created by an application using the <a href="#video-broadcast-createchannelobject-dsd" class="apiRef">createChannelObject()</a> methods on the <a href="#video-broadcast" class="apiRef">video/broadcast</a> embedded object or the <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> class or the <a href="#channelconfig-createchannellist" class="apiRef">createChannelList()</a> method on the <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> class. Accessing the channel property of a <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> object or <a href="#recording-class" class="apiRef">Recording</a> object which is scheduled on a locally defined channel SHALL return a <code>Channel</code> object representing that locally defined channel.</p>
<p>Except for the <a href="#channel-hidden" class="apiRef">hidden</a> property, writing to the writable properties on a <code>Channel</code> object SHALL have no effect for <code>Channel</code> objects representing channels stored in the channel list. Applications SHOULD only change these writable properties of a locally defined channel before the <code>Channel</code> object is referenced by another object or passed to an API call as an input parameter. The effects of writing to these properties at any other time is implementation dependent.</p>
<p>The <code>Channel</code> class is defined as follows:</p>

<section id="channel-constants">
<h4>Constants</h4>
<table class="dae-constant-table">
<tr><th>Name</th><th>Value</th><th>Use</th></tr>
<tr><td>TYPE_TV</td><td>0</td><td>Used in the <a href="#channel-channeltype" class="apiRef">channelType</a> property to indicate a TV channel.</td></tr>
<tr><td>TYPE_RADIO</td><td>1</td><td>Used in the <a href="#channel-channeltype" class="apiRef">channelType</a> property to indicate a radio channel.</td></tr>
<tr><td>TYPE_OTHER</td><td>2</td><td>Used in the <a href="#channel-channeltype" class="apiRef">channelType</a> property to indicate that the type of the channel is unknown, or known but not of type TV or radio.</td></tr>
<tr><td>TYPE_ALL</td><td>128</td><td>Used during channel scanning to indicate that all TV, radio and other channel types should scanned.</td></tr>
<tr><td>TYPE_HBB_DATA</td><td>256</td><td>Reserved for data services defined by [[TS102796]].</td></tr>
<tr><td>ID_ANALOG</td><td>0</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate an analogue channel identified by the property '<a href="#channel-freq" class="apiRef">freq</a>' and optionally '<a href="#channel-cni" class="apiRef">cni</a>' or '<a href="#channel-name" class="apiRef">name</a>'.</td></tr>
<tr><td>ID_DVB_C</td><td>10</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a DVB-C channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_DVB_S</td><td>11</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a DVB-S channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_DVB_T</td><td>12</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a DVB-T channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_DVB_SI_DIRECT</td><td>13</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a channel that is identified through its delivery system descriptor as defined by DVB-SI [[!EN300468]] section 6.2.13.</td></tr>
<tr><td>ID_DVB_C2</td><td>14</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a DVB-C or DVB-C2 channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_DVB_S2</td><td>15</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a DVB-S or DVB-S2 channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_DVB_T2</td><td>16</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a DVB-T or DVB-T2 channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_ISDB_C</td><td>20</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a ISDB-C channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_ISDB_S</td><td>21</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a ISDB-S channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_ISDB_T</td><td>22</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a ISDB-T channel identified by the three properties: '<a href="#channel-onid" class="apiRef">onid</a>', '<a href="#channel-tsid" class="apiRef">tsid</a>', '<a href="#channel-sid" class="apiRef">sid</a>'.</td></tr>
<tr><td>ID_ATSC_T</td><td>30</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate a ATSC-T channel identified by the property '<a href="#channel-sourceid" class="apiRef">sourceid</a>'.</td></tr>
<tr><td>ID_IPTV_SDS</td><td>40</td><td>Used in the idType property to indicate an IP broadcast channel identified through SD&amp;S by a DVB textual service identifier specified in the format &ldquo;ServiceName.DomainName&rdquo; as value for property '<a href="#channel-ipbroadcastid" class="apiRef">ipBroadcastID</a>', with <code>ServiceName</code> and <code>DomainName</code> as defined in [[!DVB-IPTV]]. This idType SHALL be used to indicate Scheduled content service defined by [[.OIPF_PROT2]].</td></tr>
<tr><td>ID_IPTV_URI</td><td>41</td><td>Used in the <a href="#channel-idtype" class="apiRef">idType</a> property to indicate an IP broadcast channel identified by a DVB MCAST URI (i.e. <code>dvb-mcast://</code>) or by a URI referencing a HAS or MPEG DASH MPD (i.e. <code>http://</code> or <code>https://</code>), as value for property <a href="#channel-ipbroadcastid" class="apiRef">ipBroadcastID</a>.</td></tr>
</table>
</section>

<section id="channel-properties">
<h4>Properties</h4>
<p>This section defines the properties of the <code>Channel</code> object.</p>
<p>Properties that do not apply in a specific circumstance (e.g. <code>onid</code> does not apply unless the channel is of type <code>ID_DVB_*</code> or <code>ID_ISDB_*</code>) SHALL be <code>undefined</code>. The mapping to these properties is defined in section <a href="#mapping-apis-to-content-formats-channel" class="sectionRef"></a>.</p>

<table class="dae-property-table" id="channel-channeltype">
<tr><td class="api-signature">readonly Integer <b>channelType</b></td></tr>
<tr><td><p>The type of channel.  The value MAY be indicated by one of the TYPE_* constants defined above.  If the type of the channel is unknown then the value SHALL be &ldquo;<code>undefined</code>&rdquo;.</p>
<p>NOTE: Values of this type between 256 and 511 are reserved for use by related specifications on request by liaison.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-idtype">
<tr><td class="api-signature">readonly Integer <b>idType</b></td></tr>
<tr><td>The type of identification for the channel, as indicated by one of the ID_* constants defined in section <a href="#channel-constants" class="sectionRef"></a></td></tr>
</table>
<table class="dae-property-table" id="channel-ccid">
<tr><td class="api-signature">readonly String <b>ccid</b></td></tr>
<tr><td><p>Unique identifier of a channel within the scope of the OITF. The ccid is defined by the OITF and SHALL have prefix '<code>ccid</code>': e.g. 'ccid:<i>{tunerID.}</i>majorChannel<i>{.minorChannel}</i>'.  </p>
<p>Note: the format of this string is platform-dependent.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-tunerid">
<tr><td class="api-signature">readonly String <b>tunerid</b></td></tr>
<tr><td>Optional unique identifier of the tuner within the scope of the OITF that is able to receive the given channel.</td></tr>
</table>
<table class="dae-property-table" id="channel-onid">
<tr><td class="api-signature">readonly Integer <b>onid</b></td></tr>
<tr><td>DVB or ISDB original network ID.</td></tr>
</table>
<table class="dae-property-table" id="channel-nid">
<tr><td class="api-signature">readonly Integer <b>nid</b></td></tr>
<tr><td>The DVB or ISDB network ID.</td></tr>
</table>
<table class="dae-property-table" id="channel-tsid">
<tr><td class="api-signature">readonly Integer <b>tsid</b></td></tr>
<tr><td>DVB or ISDB transport stream ID.</td></tr>
</table>
<table class="dae-property-table" id="channel-sid">
<tr><td class="api-signature">readonly Integer <b>sid</b></td></tr>
<tr><td>DVB or ISDB service ID.</td></tr>
</table>
<table class="dae-property-table" id="channel-sourceid">
<tr><td class="api-signature">readonly Integer <b>sourceID</b></td></tr>
<tr><td>ATSC source_ID value.</td></tr>
</table>
<table class="dae-property-table" id="channel-freq">
<tr><td class="api-signature">readonly Integer <b>freq</b></td></tr>
<tr><td>For analogue channels, the frequency of the video carrier in kHz.</td></tr>
</table>
<table class="dae-property-table" id="channel-cni">
<tr><td class="api-signature">readonly Integer <b>cni</b></td></tr>
<tr><td>For analogue channels, the VPS/PDC confirmed network identifier.</td></tr>
</table>
<table class="dae-property-table" id="channel-name">
<tr><td class="api-signature">String <b>name</b></td></tr>
<tr><td>The name of the channel. Can be used for linking analog channels without CNI. Typically, it will contain the call sign of the station (e.g. 'HBO').</td></tr>
</table>
<table class="dae-property-table" id="channel-majorchannel">
<tr><td class="api-signature">readonly Integer <b>majorChannel</b></td></tr>
<tr><td>The major channel number, if assigned. Value <code>undefined</code> otherwise. Typically used for channels of type <code>ID_ATSC_*</code> or for channels of type <code>ID_DVB_*</code> or <code>ID_IPTV_SDS</code> in markets where logical channel numbers are used.</td></tr>
</table>
<table class="dae-property-table" id="channel-minorchannel">
<tr><td class="api-signature">readonly Integer <b>minorChannel</b></td></tr>
<tr><td>The minor channel number, if assigned. Value <code>undefined</code> otherwise. Typically used for channels of type <code>ID_ATSC_*</code>.</td></tr>
</table>
<table class="dae-property-table" id="channel-dsd">
<tr><td class="api-signature">readonly String <b>dsd</b></td></tr>
<tr><td><p>For channels of type <code>ID_DVB_SI_DIRECT</code> created through <a href="#channelconfig-createchannelobject" class="apiRef">createChannelObject()</a>, this property defines the delivery system descriptor (tuning parameters) as defined by DVB-SI [[!EN300468]] section 6.2.13.</p>
<p>The <code>dsd</code> property provides a string whose characters shall be restricted to the ISO Latin-1 character set. Each character in the dsd represents a byte of a delivery system descriptor as defined by DVB-SI [[!EN300468]] section 6.2.13, such that a byte at position "i" in the delivery system descriptor is equal the Latin-1 character code of the character at position "i" in the dsd. </p>
<p>Described in the syntax of JavaScript: let <code>sdd[]</code> be the byte array of a system delivery descriptor, in which <code>sdd[0]</code> is the descriptor_tag, then, <code>dsd</code> is its equivalent string, if:<br />
<code>&nbsp;&nbsp;&nbsp;&nbsp;dsd.length==sdd.length</code>  and<br />
<code>&nbsp;&nbsp;&nbsp;&nbsp;for each integer i : 0&lt;=i&lt;dsd.length</code> holds: <code>&nbsp;&nbsp;sdd[i] == dsd.charCodeAt(i)</code>.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-favourite">
<tr><td class="api-signature">readonly Boolean <b>favourite</b></td></tr>
<tr><td>Flag indicating whether the channel is marked as a favourite channel or not in one of the favourite lists as defined by the property <a href="#channel-favids" class="apiRef">favIDs</a>.</td></tr>
</table>
<table class="dae-property-table" id="channel-favids">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>favIDs</b></td></tr>
<tr><td>The names of the favourite lists to which this channel belongs (see the <a href="#channelconfig-favouritelists" class="apiRef">favouriteLists</a> property on the <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> class).</td></tr>
</table>
<table class="dae-property-table" id="channel-locked">
<tr><td class="api-signature">readonly Boolean <b>locked</b></td></tr>
<tr><td><p>Flag indicating whether the current state of the parental control system prevents the channel from being viewed (e.g. a correct parental control pin has not been entered).</p>
<p>Note that this property supports the option of client-based management of parental control without excluding server-side implementation of parental control.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-manualblock">
<tr><td class="api-signature">readonly Boolean <b>manualBlock</b></td></tr>
<tr><td><p>Flag indicating whether the user has manually blocked viewing of this channel.  Manual blocking of a channel will treat the channel as if its parental rating value always exceeded the system threshold.</p>
<p>Note that this property supports the option of client-based management of manual blocking without excluding server-side management of blocked channels.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-ipbroadcastid">
<tr><td class="api-signature">readonly String <b>ipBroadcastID</b></td></tr>
<tr><td><p>If the channel has an <a href="#channel-idtype" class="apiRef">idType</a> of <code>ID_IPTV_SDS</code>, this property denotes the DVB textual service identifier of the IP broadcast service, specified in the format &ldquo;ServiceName.DomainName&rdquo; with the ServiceName and DomainName as defined in [[!DVB-IPTV]]. </p>
<p>If the channel has an <a href="#channel-idtype" class="apiRef">idType</a> of <code>ID_IPTV_URI</code>, this element denotes a URI of the IP broadcast service.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-channelmaxbitrate">
<tr><td class="api-signature">readonly Integer <b>channelMaxBitRate</b></td></tr>
<tr><td>If the channel has an <a href="#channel-idtype" class="apiRef">idType</a> of <code>ID_IPTV_SDS</code>, this property denotes the maximum bitrate associated to the channel.</td></tr>
</table>
<table class="dae-property-table" id="channel-channelttr">
<tr><td class="api-signature">readonly Integer <b>channelTTR</b></td></tr>
<tr><td>If the channel has an <a href="#channel-idtype" class="apiRef">idType</a> of <code>ID_IPTV_SDS</code>, this property denotes the TimeToRenegotiate associated to the channel.</td></tr>
</table>
<table class="dae-property-table" id="channel-recordable">
<tr><td class="api-signature">readonly Boolean <b>recordable</b></td></tr>
<tr><td>Flag indicating whether the channel is available to the recording functionality of the OITF. If the value of the <a href="#localsystem-pvrsupport" class="apiRef">pvrSupport</a> property on the <a href="#application-oipfconfiguration" class="apiRef">application/oipfConfiguration</a> object as defined in section <a href="#localsystem-properties" class="sectionRef"></a> is 0, this property SHALL be <code>false</code> for all <code>Channel</code> objects.</td></tr>
</table>
</section>

<section id="metadata-extensions-to-channel">
<h4>Metadata extensions to Channel</h4>
<p>This subsection SHALL apply for OITFs that have indicated <code>&lt;clientMetadata&gt;</code> with value &ldquo;<code>true</code>&rdquo; and a <code>type</code> attribute with values &ldquo;<code>bcg</code>&rdquo;, &ldquo;<code>sd-s</code>&rdquo;, &ldquo;<code>eit-pf</code>&rdquo; or &ldquo;<code>dvb-si</code>&rdquo; as defined in section <a href="#OITF-metadata-api-support" class="sectionRef"></a> in their capability profile.</p>
<p>The OITF SHALL extend the <code>Channel</code> class with the properties and methods described below.</p>
<p>The values of many of these properties may be derived from elements in the BCG metadata.  For optional elements that are not present in the metadata, the default value of any property that derives its value from one of those elements SHALL be <code>undefined</code>.</p>
<section id="metadata-extensions-to-channel-properties">
<h5>Properties</h5>
<table class="dae-property-table" id="channel-longname">
<tr><td class="api-signature">String <b>longName</b></td></tr>
<tr><td><p>The long name of the channel. If both short and long names are being transmitted, this property SHALL contain the long name of the station (e.g. 'Home Box Office'). If the long name is not available, this property SHALL be <code>undefined</code>.</p>
<p>The value of this property may be derived from the Name element that is a child of the BCG <code>ServiceInformation</code> element describing the channel, where the <code>length</code> attribute of the <code>Name</code> element has the value 'long'.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-description">
<tr><td class="api-signature">String <b>description</b></td></tr>
<tr><td><p>The description of the channel. If no description is available, this property SHALL be  <code>undefined</code>.</p>
<p>The value of this field may be taken from the <code>ServiceDescription</code> element that is a child of the BCG <code>ServiceInformation</code> element describing this channel.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-authorised">
<tr><td class="api-signature">readonly Boolean <b>authorised</b></td></tr>
<tr><td>Flag indicating whether the receiver is currently authorised to view the channel. This describes the conditional access restrictions that may be imposed on the channel, rather than parental control restrictions.</td></tr>
</table>
<table class="dae-property-table" id="channel-genre">
<tr><td class="api-signature"><a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>genre</b></td></tr>
<tr><td><p>A collection of genres that describe the channel.</p>
<p>The value of this field may be taken from the <code>ServiceGenre</code> elements that are children of the BCG <code>ServiceInformation</code> element describing the channel.</p></td></tr>
</table>
<table class="dae-property-table" id="channel-hidden">
<tr><td class="api-signature">Boolean <b>hidden</b></td></tr>
<tr><td>Flag indicating whether the channel SHALL be included in the default channel list.</td></tr>
</table>
<table class="dae-property-table" id="channel-is3d">
<tr><td class="api-signature">readonly Boolean <b>is3D</b></td></tr>
<tr><td>Flag indicating whether the channel is a 3D channel.</td></tr>
</table>
<table class="dae-property-table" id="channel-ishd">
<tr><td class="api-signature">readonly Boolean <b>isHD</b></td></tr>
<tr><td>Flag indicating whether the channel is an HD channel.</td></tr>
</table>
<table class="dae-property-table" id="channel-logourl">
<tr><td class="api-signature">String <b>logoURL</b></td></tr>
<tr><td><p>The URL for the default logo image for this channel.</p>
<p>The value of this field may be derived from the value of the first <code>Logo</code> element that is a child of the BCG <code>ServiceInformation</code> element describing the channel.  If this element specifies anything other than the URL of an image, the value of this filed SHALL be <code>undefined</code>.</p></td></tr>
</table>
</section>
<section id="metadata-extensions-to-channel-methods">
<h5>Methods</h5>
<table class="dae-method-table" id="channel-getfield">
<tr><td colspan="3" class="api-signature">String <b>getField</b>( String fieldId )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Get the value of the field referred to by <code>fieldId</code> that is contained in the BCG metadata for this channel.  If the field does not exist, this method SHALL return <code>undefined</code>.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">fieldId</td><td>The name of the field whose value SHALL be retrieved.</td></tr>
</table>
<table class="dae-method-table" id="channel-getlogo">
<tr><td colspan="3" class="api-signature">String <b>getLogo</b>( Integer width, Integer height )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Get the URI for the logo image for this channel. The width and height parameters specify the desired width and height of the image; if an image of that size is not available, the URI of the logo with the closest available size not exceeding the specified dimensions SHALL be returned. If no image matches these criteria, this method SHALL return <code>null</code>.</p>
<p>The URI returned SHALL be suitable for use as the <code>SRC</code> attribute in an HTML <code>IMG</code> element or as a background image.</p>
<p>The URIs returned by this method will be derived from the values of the <code>Logo</code> elements that are children of the BCG <code>ServiceInformation</code> element describing the channel.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">width</td><td>The desired width of the image</td></tr>
<tr><td class="dae-method-table-argument">height</td><td>The desired height of the image</td></tr>
</table>
</section>
</section>
</section>

<section id="favouritelistcollection-class">
<h3>The FavouriteListCollection class</h3>
<pre>
typedef Collection&lt;<a href="#favouritelist-class" class="apiRef">FavouriteList</a>&gt; FavouriteListCollection
</pre>
<p>The <code>FavouriteListCollection</code> class represents a collection of <a href="#favouritelist-class" class="apiRef">FavouriteList</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template. In addition to the methods and properties defined for generic collections, the <code>FavouriteListCollection</code> class supports the additional methods defined below.</p>
<section id="favouritelistcollection-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="favouritelistcollection-getfavouritelist">
<tr><td colspan="3" class="api-signature"><a href="#favouritelist-class" class="apiRef">FavouriteList</a> <b>getFavouriteList</b>( String favID )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Return the first favourite list in the collection with the given <code>favID</code>.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">favID</td><td>The ID of a favourite list.</td></tr>
</table>
</section>
<section id="favouritelistcollection-extensions">
<h4>Extensions to FavouriteListCollection</h4>
<p>If an OITF has indicated support for extended tuner control (i.e. by giving value true to element <code>&lt;extendedAVControl&gt;</code> as specified in section <a href="#extended-av-api-support" class="sectionRef"></a> in its capability description), the OITF SHALL support the following additional constants and methods on the <code>FavouriteListCollection</code> object.</p>
<p>The functionality as described in this section is subject to the security model of section <a href="#security-requirements-for-service-provider-controlled-oitf" class="sectionRef"></a>.</p>

<table class="dae-method-table" id="favouritelistcollection-createfavouritelist">
<tr><td colspan="3" class="api-signature"><a href="#favouritelist-class" class="apiRef">FavouriteList</a> <b>createFavouriteList</b>( String name )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Create a new favourite list and add it to the collection. The new favourite list SHALL be returned.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">name</td><td>The name to be associated to the new favourite list.</td></tr>
</table>
<table class="dae-method-table" id="favouritelistcollection-remove">
<tr><td colspan="3" class="api-signature">Boolean <b>remove</b>( Integer index )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Remove the list at the specified index from the collection. This method SHALL return <code>true</code> of the operation succeeded, or <code>false</code> if an invalid index was specified.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">index</td><td>The index of the list  to be removed.</td></tr>
</table>

<table class="dae-method-table" id="favouritelistcollection-commit">
<tr><td colspan="2" class="api-signature">Boolean <b>commit</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Commit any changes to the collection to persistent storage. This method SHALL return <code>true</code> of the operation succeeded, or <code>false</code> if it failed (e.g. due to insufficient space to store the collection).</p>
<p>If a server has indicated that it requires control of the tuner functionality of an OITF in the server capability description for a particular service, then the OITF SHOULD send an updated Client Channel Listing to the server using HTTP POST over TLS as described in section <a href="#method-1-getchannelconfig" class="sectionRef"></a>.</p>
</td></tr>
</table>

<table class="dae-method-table" id="favouritelistcollection-activatefavouritelist">
<tr><td colspan="3" class="api-signature">Boolean <b>activateFavouriteList</b>( String favID )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Active the favourite list from the collection. This method SHALL return <code>true</code> if the operation succeeded, or <code>false</code> if an invalid index was specified. A newly created favourite list has to be committed before it can be activated.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">favID</td><td>The ID of a favourite list.</td></tr>
</table>
</section>
</section>

<section id="favouritelist-class">
<h3>The FavouriteList class</h3>
<pre>
typedef Collection&lt;<a href="#channel-class" class="apiRef">Channel</a>&gt; FavouriteList
</pre>
<p>The <code>FavouriteList</code> class represents a list of favourite channels. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template. In addition to the methods and properties defined for generic collections, the <code>FavouriteList</code> class supports the additional properties and methods defined below.</p>
<p>In order to preserve backwards compatibility with already existing DAE content the JavaScript <code>toString()</code> method SHALL return the <code>FavouriteList.id</code> for <code>FavouriteList</code> objects.</p>
<section id="favouritelist-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="favouritelist-favid">
<tr><td class="api-signature">readonly String <b>favID</b></td></tr>
<tr><td>A unique identifier by which the favourite list can be identified.</td></tr>
</table>
<table class="dae-property-table" id="favouritelist-name">
<tr><td class="api-signature">String <b>name</b></td></tr>
<tr><td>A descriptive name given to the favourite list.</td></tr>
</table>
</section>
<section id="favouritelist-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="favouritelist-getchannel">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>getChannel</b>( String channelID )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Return the first channel in the favourite list with the specified channel identifier. Returns <code>null</code> if no corresponding channel can be found.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">channelID</td><td>The channel identifier of the channel to be retrieved, which is a value as defined for property <a href="#channel-ccid" class="apiRef">ccid</a> of the <a href="#channel-class" class="apiRef">Channel</a> object or a value as defined for property <a href="#channel-ipbroadcastid" class="apiRef">ipBroadcastID</a> of the <a href="#channel-class" class="apiRef">Channel</a> object as defined in section <a href="#channel-class" class="sectionRef"></a>.</td></tr>
</table>

<table class="dae-method-table" id="favouritelist-getchannelbytriplet">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>getChannelByTriplet</b>( Integer onid, Integer tsid, Integer sid )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Return the first (IPTV or non-IPTV) channel in the list that matches the specified DVB or ISDB triplet (original network ID, transport stream ID, service ID).</p>
<p>Where no channels of type ID_ISDB_* or ID_DVB_* are available, or no channel identified by this triplet are found, this method SHALL return <code>null</code>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">onid</td><td>The original network ID of the channel to be retrieved.</td></tr>
<tr><td class="dae-method-table-argument">tsid</td><td>The transport stream ID of the channel to be retrieved. If set to <code>null</code> the client SHALL retrieve the channel defined by the combination of <code>onid</code> and <code>sid</code>. This makes it possible to retrieve the correct channel also in case a remultiplexing took place which led to a changed <code>tsid</code>.</td></tr>
<tr><td class="dae-method-table-argument">sid</td><td>The service ID of the channel to be retrieved.</td></tr>
</table>
<table class="dae-method-table" id="favouritelist-getchannelbysourceid">
<tr><td colspan="3" class="api-signature"><a href="#channel-class" class="apiRef">Channel</a> <b>getChannelBySourceID</b>( Integer sourceID )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Return the first (IPTV or non-IPTV) channel in the list with the specified ATSC source ID.</p>
<p>Where no channels of  type ID_ATSC_* are available, or no channel with the specified source ID is found in the channel list, this method SHALL return <code>null</code>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">sourceID</td><td>The ATSC source_ID of the channel to be returned.</td></tr>
</table>
</section>
<section id="favouritelist-extensions">
<h4>Extensions to FavouriteList</h4>
<p>If an OITF has indicated support for extended tuner control (i.e. by giving value true to element <code>&lt;extendedAVControl&gt;</code> as specified in section <a href="#extended-av-api-support" class="sectionRef"></a> in its capability description), the OITF SHALL support the following additional constants and methods on the <code>FavouriteList</code> object.</p>
<p>When the <code>FavouriteList</code> object is updated with new or removed channels it does not take effect until the object is committed. Only after <a href="#favouritelist-commit" class="apiRef">commit()</a> will the updates of a <code>FavouriteList</code> object become available to other DAE applications.</p>
<p>The <a href="#favouritelist-name" class="apiRef">name</a> property of the <code>FavouriteList</code> object SHALL be read/write for OITFs which are controlled by a service provider. The following methods SHALL also be supported:</p>

<table class="dae-method-table" id="favouritelist-insertbefore">
<tr><td colspan="3" class="api-signature">Boolean <b>insertBefore</b>( Integer index, String ccid )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Insert a new favourite into the favourites list at the specified index. In order to add a ccid at the end of the favourite list the index shall be equal to <code>length</code>. This method SHALL return <code>true</code> of the operation succeeded, or <code>false</code> if an invalid index was specified (e.g. <code>index</code> > (<code>length</code>) ).</td></tr>
<tr><td class="dae-method-table-label" rowspan="2">Arguments</td>
<td class="dae-method-table-argument">index</td><td>The index in the list before which the favourite should be inserted. </td></tr>
<tr><td class="dae-method-table-argument">ccid</td><td>The ccid of the channel to be added. </td></tr>
</table>

<table class="dae-method-table" id="favouritelist-remove">
<tr><td colspan="3" class="api-signature">Boolean <b>remove</b>( Integer index )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Remove the item at the specified index from the favourites list.  Returns <code>true</code> of the operation succeeded, or <code>false</code> if an invalid index was specified.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">index</td><td>The index of the item to be removed.</td></tr>
</table>

<table class="dae-method-table" id="favouritelist-commit">
<tr><td colspan="2" class="api-signature">Boolean <b>commit</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1"><p>Commit any changes to the favourites list to persistent storage. This method SHALL return <code>true</code> if the operation succeeded, or <code>false</code> if it failed (e.g. due to insufficient space to store the list on the OITF).</p>
<p>If a server has indicated that it requires control of the tuner functionality of an OITF in the server capability description for a particular service, then the OITF SHOULD send an updated Client Channel Listing to the server using HTTP POST over TLS as described in section <a href="#method-1-getchannelconfig" class="sectionRef"></a>.</p>
</td></tr>
</table>
</section>

</section>
<section id="video-broadcast-extensions-channel-scan">
<h3>Extensions to video/broadcast for channel scan</h3>
The section has been merged with the <a href="#channelconfig-class" class="apiRef">ChannelConfig</a> class (see section <a href="#channelconfig-class" class="sectionRef"></a> above).
</section>
<section id="channelscanevent-class">
<h3>The ChannelScanEvent class</h3>
The contents of this section have been merged with section <a href="#channelconfig-events" class="sectionRef"></a> above.
</section>
<section id="channelscanoptions-class">
<h3>The ChannelScanOptions class</h3>
The <code>ChannelScanOptions</code> class defines the options that should be applied during a channel scan operation.  This class does not define parameters for the channel scan itself.
<section id="channelscanoptions-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="channelscanoptions-channeltype">
<tr><td class="api-signature">Integer <b>channelType</b></td></tr>
<tr><td>The types of channel that should be discovered during the scan. Valid values are <code>TYPE_RADIO</code>, <code>TYPE_TV</code>, or <code>TYPE_OTHER</code> or <code>TYPE_ALL</code> as defined in section <a href="#channel-constants" class="sectionRef"></a>.</td></tr>
</table>
<table class="dae-property-table" id="channelscanoptions-replaceexisting">
<tr><td class="api-signature">Boolean <b>replaceExisting</b></td></tr>
<tr><td>If <code>true</code>, any existing channels in the channel list managed by the OITF SHALL be removed and the new channel list SHALL consist only of channels found during the channel scan operation. If <code>false</code>, any channels discovered during the channel scan SHALL be added to the existing channel list.</td></tr>
</table>
</section>
</section>
<section id="channelscanparameters-class">
<h3>The ChannelScanParameters class</h3>
This is an empty class that acts as the base interface for channel scan parameters specific to certain types of broadcast network.
</section>
<section id="dvbtchannelscanparameters-class">
<h3>The DVBTChannelScanParemeters class</h3>
<p>The <code>DVBTChannelScanParameters</code> class represents the parameters needed to perform a channel scan on a DVB-T or DVB-T2 network. This class implements the interface defined by <a href="#channelscanparameters-class" class="apiRef">ChannelScanParameters</a>, with the following additions.</p>
<p>The properties that are undefined when performing <a href="#channelconfig-startscan" class="apiRef">startScan()</a> are considered to be auto detected.</p>

<table class="dae-property-table" id="dvbtchannelscanparameters-startfrequency">
<tr><td class="api-signature">Integer <b>startFrequency</b></td></tr>
<tr><td>The start frequency of the scan, in kHz.</td></tr>
</table>
<table class="dae-property-table" id="dvbtchannelscanparameters-endfrequency">
<tr><td class="api-signature">Integer <b>endFrequency</b></td></tr>
<tr><td>The end frequency of the scan, in kHz.</td></tr>
</table>
<table class="dae-property-table" id="dvbtchannelscanparameters-raster">
<tr><td class="api-signature">Integer <b>raster</b></td></tr>
<tr><td>The raster size represented in kHz (typically 7000 or 8000).</td></tr>
</table>
<table class="dae-property-table" id="dvbtchannelscanparameters-ofdm">
<tr><td class="api-signature">String <b>ofdm</b></td></tr>
<tr><td>The Orthogonal Frequency Division Multiplexing (OFDM) for the indicating frequency. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>MODE_1K</td><td>OFDM mode 1K</td></tr>
<tr><td>MODE_2K</td><td>OFDM mode 2K</td></tr>
<tr><td>MODE_4K</td><td>OFDM mode 4K</td></tr>
<tr><td>MODE_8K</td><td>OFDM mode 8K</td></tr>
<tr><td>MODE_16K</td><td>OFDM mode 16K</td></tr>
<tr><td>MODE_32K</td><td>OFDM mode 32K</td></tr>
</table>
</td></tr>
</table>
<table class="dae-property-table" id="dvbtchannelscanparameters-modulationmodes">
<tr><td class="api-signature">Integer <b>modulationModes</b></td></tr>
<tr><td>The modulation modes to be scanned. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>QPSK modulation</td></tr>
<tr><td>4</td><td>QAM16 modulation</td></tr>
<tr><td>8</td><td>QAM32 modulation</td></tr>
<tr><td>16</td><td>QAM64 modulation</td></tr>
<tr><td>32</td><td>QAM128 modulation</td></tr>
<tr><td>64</td><td>QAM256 modulation</td></tr>
</table>
More than one of these values may be ORed together in order to indicate that more than one modulation mode should be scanned.
</td></tr>
</table>
<table class="dae-property-table" id="dvbtchannelscanparameters-bandwidth">
<tr><td class="api-signature">String <b>bandwidth</b></td></tr>
<tr><td>The expected bandwidth. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>BAND_1.7MHZ</td><td>1.7 MHz bandwidth</td></tr>
<tr><td>BAND_5MHz</td><td>5 MHz bandwidth</td></tr>
<tr><td>BAND_6MHz</td><td>6 MHz bandwidth</td></tr>
<tr><td>BAND_7MHz</td><td>7 MHz bandwidth</td></tr>
<tr><td>BAND_8MHz</td><td>8 MHz bandwidth</td></tr>
<tr><td>BAND_10MHz</td><td>10 MHz bandwidth</td></tr>
</table>
</td></tr>
</table>
</section>
<section id="dvbschannelscanparameters-class">
<h3>The DVBSChannelScanParemeters class</h3>

<section id="dvbschannelscanparameters-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="dvbschannelscanparameters-startfrequency">
<tr><td class="api-signature">Integer <b>startFrequency</b></td></tr>
<tr><td>The start frequency of the scan, in kHz.</td></tr>
</table>
<table class="dae-property-table" id="dvbschannelscanparameters-endfrequency">
<tr><td class="api-signature">Integer <b>endFrequency</b></td></tr>
<tr><td>The end frequency of the scan, in kHz.</td></tr>
</table>

<table class="dae-property-table" id="dvbschannelscanparameters-modulationmodes">
<tr><td class="api-signature">Integer <b>modulationModes</b></td></tr>
<tr><td>The modulation modes to be scanned. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>QPSK modulation</td></tr>
<tr><td>2</td><td>8PSK modulation</td></tr>
<tr><td>4</td><td>QAM16 modulation</td></tr>
</table>
More than one of these values may be ORed together in order to indicate that more than one modulation mode should be scanned.
</td></tr>
</table>
<table class="dae-property-table" id="dvbschannelscanparameters-symbolrate">
<tr><td class="api-signature">String <b>symbolRate</b></td></tr>
<tr><td>A comma-separated list of the symbol rates to be scanned, in symbols/sec.</td></tr>
</table>
<table class="dae-property-table" id="dvbschannelscanparameters-polarisation">
<tr><td class="api-signature">Integer <b>polarisation</b></td></tr>
<tr><td>The polarisation to be scanned. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>Horizontal polarisation</td></tr>
<tr><td>2</td><td>Vertical polarisation</td></tr>
<tr><td>4</td><td>Right-handed/clockwise circular polarisation</td></tr>
<tr><td>8</td><td>Left-handed/counter-clockwise circular polarization</td></tr>
</table>
More than one of these values may be ORed together in order to indicate that more than one polarisation should be scanned.
</td></tr>
</table>
<table class="dae-property-table" id="dvbschannelscanparameters-coderate">
<tr><td class="api-signature">String <b>codeRate</b></td></tr>
<tr><td>The code rate, e.g. &ldquo;3/4&rdquo; or &ldquo;5/6&rdquo;.</td></tr>
</table>
<table class="dae-property-table" id="dvbschannelscanparameters-orbitalposition">
<tr><td class="api-signature">Number <b>orbitalPosition</b></td></tr>
<tr><td>The <code>orbitalPosition</code> property is used to resolve DiSEqC switch/motor. The value is the orbital position of the satellite, negative value for west, positive value for east. For example, Astra 19.2 East would have orbitalPosition 19.2. Thor 0.8 West would have orbitalPosition -0.8.</td></tr>
</table>
<table class="dae-property-table" id="dvbschannelscanparameters-networkid">
<tr><td class="api-signature">Integer <b>networkId</b></td></tr>
<tr><td>The network ID of the network to be scanned, or <code>undefined</code> if all networks should be scanned.</td></tr>
</table>
</section>
</section>

<section id="dvbcchannelscanparameters-class">
<h3>The DVBCChannelScanParemeters class</h3>
<p>The <code>DVBCChannelScanParameters</code> class represents the parameters needed to perform a channel scan on a DVB-C or DVB-C2 network. This class implements the interface defined by <a href="#channelscanparameters-class" class="apiRef">ChannelScanParameters</a>, with the following additions.</p>
<p>The properties that are undefined when performing <a href="#channelconfig-startscan" class="apiRef">startScan()</a> are considered to be auto detected.</p>

<section id="dvbcchannelscanparameters-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="dvbcchannelscanparameters-startfrequency">
<tr><td class="api-signature">Integer <b>startFrequency</b></td></tr>
<tr><td>The start frequency of the scan, in kHz.</td></tr>
</table>
<table class="dae-property-table" id="dvbcchannelscanparameters-endfrequency">
<tr><td class="api-signature">Integer <b>endFrequency</b></td></tr>
<tr><td>The end frequency of the scan, in kHz.</td></tr>
</table>
<table class="dae-property-table" id="dvbcchannelscanparameters-raster">
<tr><td class="api-signature">Integer <b>raster</b></td></tr>
<tr><td>The raster size represented in kHz (typically 7000 or 8000).</td></tr>
</table>
<table class="dae-property-table" id="dvbcchannelscanparameters-startnetworkscanonnit">
<tr><td class="api-signature">Boolean <b>startNetworkScanOnNIT</b></td></tr>
<tr><td>The scan mode for scanning. A <code>false</code> value indicates to scan complete range, a <code>true</code> value indicates scan terminates when a valid NIT is found. The frequency scan is replaced by a scan based on NIT. If <a href="#dvbcchannelscanparameters-networkid" class="apiRef">networkId</a> is set and the value of this property is set to <code>true</code> the scan continues until there is a match on both.</td></tr>
</table>
<table class="dae-property-table" id="dvbcchannelscanparameters-modulationmodes">
<tr><td class="api-signature">Integer <b>modulationModes</b></td></tr>
<tr><td>The modulation modes to be scanned. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>4</td><td>QAM16 modulation</td></tr>
<tr><td>8</td><td>QAM32 modulation</td></tr>
<tr><td>16</td><td>QAM64 modulation</td></tr>
<tr><td>32</td><td>QAM128 modulation</td></tr>
<tr><td>64</td><td>QAM256 modulation</td></tr>
<tr><td>128</td><td>QAM1024 modulation</td></tr>
<tr><td>256</td><td>QAM2048 modulation</td></tr>
</table>
More than one of these values may be ORed together in order to indicate that more than one modulation mode should be scanned.
</td></tr>
</table>
<table class="dae-property-table" id="dvbcchannelscanparameters-symbolrate">
<tr><td class="api-signature">String <b>symbolRate</b></td></tr>
<tr><td>A comma-separated list of the symbol rates to be scanned, in symbols/sec.</td></tr>
</table>
<table class="dae-property-table" id="dvbcchannelscanparameters-networkid">
<tr><td class="api-signature">Integer <b>networkId</b></td></tr>
<tr><td>The network ID of the network to be scanned, or <code>undefined</code> if all networks should be scanned.</td></tr>
</table>
</section>
</section>

<section id="video-broadcast-extensions-synchronisation">
<h3>Extensions to video/broadcast for synchronization</h3>
<p>The OITF SHALL support the following additional methods on the video/broadcast object, in order to enable synchronization to broadcast events.</p>

<table class="dae-method-table" id="addstreameventlistener">
<tr><td colspan="3" class="api-signature">void <b>addStreamEventListener</b>( String targetURL, String eventName, EventListener listener )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Add a listener for the specified DSM-CC stream event.</p>
<p>Event triggers are carried in the stream as MPEG private data sections. For robustness, the section describing a particular trigger may be repeated several times. Each section has a version number which is used to disambiguate a new trigger for the same event (which will have a different version number) from a repeated instance of a previous trigger (which will have the same version number).</p>
<p>When OITF detects a trigger corresponding to an event for which a listener has been registered, a DOM <code>StreamEvent</code> SHALL be dispatched.
<p>An event shall also be dispatched in case of error.</p>
<p>An OITF SHALL dispatch only one DOM <code>StreamEvent</code> per unique trigger detected. Repeated instances of the same trigger SHALL NOT cause a new DOM StreamEvent to be dispatched. A new trigger for the same event (i.e. an MPEG private data section for the same event but with an updated version number) SHALL cause a new DOM <code>StreamEvent</code> to be dispatched.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">targetURL</td><td>The URL of the DSM-CC StreamEvent object or the event description file describing the event as defined in section 8.2 of [[!TS102809]]</td></tr>
<tr><td class="dae-method-table-argument">eventName</td><td>The name of the event (in the DSM-CC StreamEvent object) that should be subscribed to.</td></tr>
<tr><td class="dae-method-table-argument">listener</td><td>The listener for the event.</td></tr>
</table>

<table class="dae-method-table" id="removestreameventlistener">
<tr><td colspan="3" class="api-signature">void <b>removeStreamEventListener</b>( String targetURL, String eventName, EventListener listener )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Remove a stream event listener for the specified stream event name.</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">targetURL</td><td>The URL of the DSM-CC StreamEvent object or the event description file describing the event as defined in section 8.2 of [[!TS102809]]</td></tr>
<tr><td class="dae-method-table-argument">eventName</td><td>The name of the event (in the DSM-CC StreamEvent object) that should be subscribed to.</td></tr>
<tr><td class="dae-method-table-argument">listener</td><td>The listener for the event.</td></tr>
</table>

<section id="streamevent-class">
<h4>The StreamEvent class</h4>
<p>The <code>StreamEvent</code> class is a subclass of the DOM <code>Event</code> class which notifies an application that a synchronisation trigger in a broadcast stream has been detected. This event also notifies an application when the event is no longer being monitored.</p>
<p>Instances of this event are directly dispatched to the event target, and will not bubble nor capture.</p>

<table class="dae-property-table" id="streamevent-eventname">
<tr><td class="api-signature">readonly String <b>eventName</b></td></tr>
<tr><td>The name of the stream event.</td></tr>
</table>
<table class="dae-property-table" id="streamevent-data">
<tr><td class="api-signature">readonly String <b>data</b></td></tr>
<tr><td>Data of the DSM-CC StreamEvent's event encoded in hexadecimal. For example: &ldquo;0A10B81033&rdquo; (for a message 5 bytes long).</td></tr>
</table>
<table class="dae-property-table" id="streamevent-text">
<tr><td class="api-signature">readonly String <b>text</b></td></tr>
<tr><td>Text data of the DSM-CC StreamEvent's event as a string, assuming UTF-8 as the encoding for the DSM-CC StreamEvent's event. Characters that cannot be transcoded SHALL be skipped.</td></tr>
</table>
<table class="dae-property-table" id="streamevent-status">
<tr><td class="api-signature">readonly String <b>status</b></td></tr>
<tr><td><p>The status of the event. Equal to &ldquo;<code>trigger</code>&rdquo; when the event is dispatched in response to a trigger in the stream or &ldquo;<code>error</code>&rdquo; when an error occurred (e.g. attempting to add a listener for an event that does not exist, or when a StreamEvent object with registered listeners is removed from the carousel).</p>
<p>An event SHALL be dispatched with an error status if:</p><ul>
<li>the StreamEvent object pointed to by <code>targetURL</code> is not found in the carousel or via broadband
<li>the StreamEvent object pointed to by <code>targetURL</code> does not contain the event specified by the eventName parameter
<li>the carousel containing the event cannot be mounted
<li>the elementary stream which contains the StreamEvent event descriptor is no longer being monitored (e.g. due to another monitoring request or because it disappears from the PMT) 
<li>the event description file pointed to by <code>targetURL</code> is not available or does not have the correct syntax.
</ul>
Once an error is dispatched, the listener SHALL be automatically unregistered by the OITF.
</td></tr>
</table>
</section>
</section>

<section id="atsctchannelscanparameters-class">
<h3>The ATSCTChannelScanParemeters class</h3>
<p>The <code>ATSCTChannelScanParameters</code> class represents the parameters needed to perform a channel scan on an ATSC-T network. This class implements the interface defined by <a href="#channelscanparameters-class" class="apiRef">ChannelScanParameters</a>, with the following additions.</p>
<p>The properties that are <code>undefined</code> when performing <a href="#channelconfig-startscan" class="apiRef">startScan()</a> are considered to be auto detected.</p>

<section id="atsctchannelscanparameters-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="atsctchannelscanparameters-startfrequency">
<tr><td class="api-signature">Integer <b>startFrequency</b></td></tr>
<tr><td>The start frequency of the scan, in kHz.</td></tr>
</table>
<table class="dae-property-table" id="atsctchannelscanparameters-endfrequency">
<tr><td class="api-signature">Integer <b>endFrequency</b></td></tr>
<tr><td>The end frequency of the scan, in kHz.</td></tr>
</table>
<table class="dae-property-table" id="atsctchannelscanparameters-raster">
<tr><td class="api-signature">Integer <b>raster</b></td></tr>
<tr><td>The raster size represented in kHz (typically 7000 or 8000).</td></tr>
</table>
<table class="dae-property-table" id="atsctchannelscanparameters-modulationmodes">
<tr><td class="api-signature">Integer <b>modulationModes</b></td></tr>
<tr><td>The modulation modes to be scanned. Valid values are:
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>2</td><td>2VSB</td></tr>
<tr><td>4</td><td>4VSB</td></tr>
<tr><td>8</td><td>8VSB</td></tr>
<tr><td>16</td><td>16VSB</td></tr>
</table>
More than one of these values may be arithmetically summed in order to indicate that more than one modulation mode should be scanned.</td></tr>
</table>
</section>
</section>
</section>

<section id="media-playback-apis">
<h2>Media playback APIs</h2>
<p>This section specifies several extensions to the audio object and the video object defined in section 5.7.1 of [[!CEA-2014-A]]. It also contains a subsection (i.e. section <a href="#playback-of-memory-audio" class="sectionRef"></a>) that defines the audio playback from memory API.</p>
<section id="av-control-object">
<h3>The A/V Control object</h3>
<p>NOTE: Most of the text in this section was found in Annex B of previous versions of this specification. It has been moved here and re-structured for readability. No additional text has been included from CEA-2014-A.</p>

<p>The HTML object element (defined in section 4.8.4 of the HTML5 specification as referenced in [[.OIPF_WSTVP2]]) SHALL support presentation of video and audio or just audio. This presentation SHALL be indicated by setting the type attribute to one of the &ldquo;video/&rdquo; or &ldquo;audio/&rdquo; MIME types that is listed in <a href="volume2.html#media-section" class="extRef">section 3</a> of [[.OIPF_MEDIA2]] and corresponds to a combination of system layer format, video format and audio format that is supported by the OITF.</p>
<p>When an HTML object is presenting video or audio as defined in this section, the following requirements shall apply:</p><ol>
<li>HTML objects presenting video and/or audio SHALL be accessible through the DOM and SHALL support the properties and methods defined by the tables below in addition to those of <code>HTMLObjectElement</code> as defined in the HTML5 specification as referenced in [[!OIPF_WSTVP2]]. 
<table class="simple" id="av-control-properties-for-video-or-audio">
<caption>Table ####: Properties of the A/V Control Object when the type attribute refers to video or audio</caption>
<tr><th>Property type and name</th><th>Property Definition</th></tr>
<tr><td>String data</td><td>String data [RW] &mdash; media URL. If the value of data is changed while media is playing playback is stopped (resulting in a play state change). The default value is the empty string. If the value of this attribute is changed, the related data-attribute inside the DOM tree SHOULD be changed accordingly. If the value of this attribute is set to an empty string or is changed, the resources (files, server connections, etc&hellip;) currently owned by the object SHALL be released. The value set in this property MAY include a temporal fragment interval according to <a href="http://www.w3.org/TR/media-frags/#naming-time" class="extRef">section 4.2.1</a> of [[!Media-Fragments-URI]] in which case the derived begin time and end time SHALL serve as bounds for playback. The Normal Play Time format SHALL be used. The begin time SHALL behave as start-of-media and the end time SHALL behave as end-of-media. If the value of temporal fragment interval is changed then there will be no change in the play state unless the interval is changed to period outside of the current play position.</td></tr>
<tr><td>readonly Number playPosition</td><td>The play position in number of milliseconds since the beginning as denoted by the server (i.e. in relation to NPT 0.0 as described in <a href="http://tools.ietf.org/html/rfc2326#section-3.6" class="extRef">section 3.6</a> of [[!RTSP]]) of the media referenced by attribute data when data refers to a single media item. If the play position cannot be determined, the playPosition SHALL be undefined.</td></tr>
<tr><td>readonly Number playTime</td><td>The estimated total duration in milliseconds of the media referenced by data when data refers to a single media item. If the duration of the media cannot be determined, the playTime SHALL be undefined.</td></tr>
<tr><td>readonly Number playState</td><td>Indication of the current play state as follows: <ul class="nobullet">
<li>0 - stopped; user (or script) has stopped playback of the current media, or playback has not yet started. 
<li>1 - playing; the current media pointed to by data is currently playing. 
<li>2 - paused; the current media pointed to by data has been paused.
<li>3 - connecting; connect to media server, i.e. waiting for connection to media server to be established, upon first connection or after the connection was lost. In addition, DRM rights necessary for playback of protected content are also retrieved during this state.
<li>4 - buffering; the buffer is being filled in order to have sufficient data available to initiate or continue playback. In this state, playback is stalled due to insufficient data in the buffer to continue playback. The player waits until sufficient data has been buffered to continue playback. For video objects, whilst being in this state, the player SHOULD show the last completed video frame that was shown before entering this state. This playstate is an intermediate state to reach playState 1 ('playing'). The OITF SHOULD buffer the content in the background whilst in playState 2 ('paused'). However, this background buffering does not result into a state change to state 4. 
<li>5 - finished; the playback of the current media has reached the end of the media. 
<li>6 - error; an error occurred during media playback, preventing the current media to start/continue playing.
</ul></td></tr>
<tr><td>readonly Number error</td><td>Error details; only significant if the value of playState equals 6: <ul class="nobullet">
<li>0 - A/V format not supported. 
<li>1 - cannot connect to server or connection lost. 
<li>2 - unidentified error. 
<li>3 &mdash; insufficient resources. 
<li>4 &mdash; content corrupt or invalid. 
<li>5 &mdash; content not available. 
<li>6 &mdash; content not available at given position.
</ul></td></tr>
<tr><td>readonly Number speed</td><td>Play speed relative to real-time as defined by 5.7.1.f.6 of [[!CEA-2014-A]].</td></tr>
<tr><td>Object onPlayStateChange</td><td>DOM-0 event handler called when the value of the playState property changes as defined by 5.7.1.f.9 of [[!CEA-2014-A]].</td></tr>
</table>
<table class="simple" id="av-control-additional-properties-for-video-or-audio">
<caption>Table ####: Additional Properties of the A/V Control Object when the type attribute refers to video</caption>
<tr><th>Property type and name</th><th>Property Definition</th></tr>
<tr><td>String width</td><td>The width of the area used for rendering the video object. This property is only writable if property <code>fullScreen</code> has value <code>false</code>. The effect of changes to <code>width</code> SHALL be in accordance with requirement 5.7.1.c of [[!CEA-2014-A]].</td></tr>
<tr><td>String height</td><td>The height of the area used for rendering the video object. This property is only writable if property <code>fullScreen</code> has value <code>false</code>. The effect of changes to <code>width</code> SHALL be in accordance with requirement 5.7.1.c of [[!CEA-2014-A]].</td></tr>
<tr><td>readonly Boolean fullScreen</td><td>Indicates whether an object presenting video is in full screen mode or not - as defined in by 5.7.1.g.3 of [[!CEA-2014-A]].</td></tr>
<tr><td>Object onFullScreenChange</td><td>DOM-0 event handler called when the value of fullScreen changes as defined in by 5.7.1.g.4 of [[!CEA-2014-A]].</td></tr>
<tr><td>Object onfocus</td><td>DOM-0 event handler called when the object gains focus as defined by 5.7.1.g.7 of [[!CEA-2014-A]].</td></tr>
<tr><td>Object onblur</td><td>DOM-0 event handler called when the object loses focus as defined by 5.7.1.g.8 of [[!CEA-2014-A]].</td></tr>
</table>
<table class="simple" id="av-control-methods-for-video-or-audio">
<caption>Table ####: Methods of the A/V Control Object when the type attribute refers to video or audio</caption>
<tr><th>Method signature</th><th>Method Definition</th></tr>
<tr><td>Boolean play(Number speed)</td><td>Plays the media referenced by data, starting at the current play position denoted by <code>playPosition</code>, at the supported speed closest to the value of attribute speed. Negative speeds reverse playback. If no speed is specified, it defaults to 1. A speed of 0 will pause playback. This method SHALL always return <code>true</code>. If the playback reached the beginning of the media at rewind playback speed, then the play state SHALL be changed to 2 ('paused'). A play speed event (see section <a href="#av-control-trickmodes-events" class="sectionRef"></a> of this specification) SHALL be generated when the operation has completed, regardless of the new play speed. If the play speed is not changed, the argument of the event SHALL be set to the previous play speed.</td></tr>
<tr><td>Boolean stop()</td><td>Stops playback and resets the <code>playPosition</code> to 0 as defined by 5.7.1.f.12 of [[!CEA-2014-A]].</td></tr>
<tr><td>Boolean seek(Number pos)</td><td><p>If <code>seek()</code> is called while the player is in state 1 (&ldquo;playing&rdquo;), then it sets the current play position (in milliseconds) to the value of pos and MAY change play state to 4 ('buffering'). </p>
<p>If the player is in state 2 ('paused'), then the <code>seek()</code> method seeks to the new position, but the play state and the rendered image is not changed.</p>
<p>If the player is in states 0 (&ldquo;stopped&rdquo;), 5 (&ldquo;finished&rdquo;) or 6 (&ldquo;error&rdquo;), then the new play position SHALL be retained and SHALL be used (if possible) as the starting position for playing back the content item indicated by the data property when the <code>play()</code> method is called. NOTE: changing the content item resets the play position to the beginning of the new content item.</p>
<p>If the player is in states 3 (&ldquo;connecting&rdquo;) or 4 (&ldquo;buffering&rdquo;) then the <code>seek()</code> method seeks to the new play position and MAY change play state to 3 (&ldquo;connecting&rdquo;).</p>
<p>If the new playback position is valid, the value of the <code>playPosition</code> attribute SHALL be set to the new value before this method returns.</p>
<p>Returns <code>true</code> if the method succeeded, and <code>false</code> otherwise. A play position event (see section <a href="#av-control-trickmodes-events" class="sectionRef"></a> of this specification) will be generated when the operation has completed, regardless of the success of the operation. If the operation fails, the argument of the event SHALL be set to the previous play position.</p>
</td></tr>
<tr><td>Boolean setVolume(Number volume)</td><td>Sets the audio volume as defined by 5.7.1.f.14 of [[!CEA-2014-A]]</td></tr>
</table>
<table class="simple" id="av-control-additional-methods-for-video-or-audio">
<caption>Table ####: Additional Methods of the A/V Control Object when the type attribute refers to video</caption>
<tr><th>Method signature</th><th>Method Definition</th></tr>
<tr><td>setFullScreen(Boolean fullscreen)</td><td>Sets the object to full screen mode or windowed mode as defined by 5.7.1.g.5 of [[!CEA-2014-A]].</td></tr>
<tr><td>focus()</td><td>Sets the input focus to this object as defined by 5.7.1.g.6 of [[!CEA-2014-A]].</td></tr>
</table>

<li>In addition to the properties and methods listed above, the following table lists other requirements from CEA-2014-A that SHALL also apply for the A/V Control object as defined in this section.
<table class="simple" id="additional-requirements-from-cea-2014">
<caption>Table ####: Additional applicable requirements from CEA-2014</caption>
<tr><th>CEA-2014 Requirement</th><th>Summary</th></tr>
<tr><td>5.7.1.a.3</td><td>Indication of the initial aspect ratio of the video content.</td></tr>
<tr><td>5.7.1.b.3</td><td>Access to both video and audio objects  by name/id through the <code>HTMLDocument</code> interface.</td></tr>
<tr><td>5.7.1.c</td><td>Full-screen or windowed mode for video objects.</td></tr>
<tr><td>5.7.1.d</td><td>CSS properties that apply to video objects.</td></tr>
<tr><td>5.7.1.e</td><td><p>CSS z-index, opacity and RGBA colour values.</p><p>NOTE: In this specification, the value of the &ldquo;<code>&lt;overlay&gt;</code>&rdquo; element is never &ldquo;none&rdquo; and hence <code>z-index</code> and <code>opacity</code> are required to be supported.</p>
</td></tr>
</table>
</ol>
<section id="av-control-state-diagram">
<h4>State diagram for A/V Control objects</h4>
<p>The following state transition diagram SHOULD be used for an A/V Control object:</p>
<figure>
<img alt="FIGURE 16" src="images/AVControlObject-state-diagram.png" />
<figcaption>Figure ####: State diagram for embedded A/V Control objects (normative)</figcaption>
</figure>

<p>The following clarifications apply:</p><ol>
<li>A detailed description for all the states in this state diagram is given above in the definition of the <code>playState</code> property. 
<li>If the value of the <code>allocationMethod</code> property is <code>DYNAMIC_ALLOCATION</code> the following SHALL apply:<ol type="a">
<li>Scarce resources for playback using the A/V Control object, such as the MPEG decoder, are claimed during state 3 ('<code>connecting</code>'), state 4 ('<code>buffering</code>') or during state transitions from state 3 ('<code>connecting</code>') to state 4 ('<code>buffering</code>'), from state 4 ('<code>buffering</code>') to state 1 ('<code>playing</code>') or from state 0 ('<code>stopped</code>') or from state 3 ('<code>connecting</code>') to state 2 ('<code>paused</code>'). 
<li>If at any point in time during playback the scarce resources are not available anymore, due to a resource conflict, then the play state of the A/V Control object SHALL be set to 6 ('<code>error</code>') with a detailed error code of 3 ('<code>insufficient resources</code>'). 
<li>Scarce resources for playback using the A/V Control object SHALL be released when state 6 ('<code>error</code>') or 0 ('<code>stopped</code>') or 5 ('<code>finished</code>') are reached. </ol>
<li>In addition, if the A/V Control object gets destroyed, e.g. because another URL is loaded into the containing window, scarce resources claimed for playback using the A/V Control object SHALL be released, except in cases described for the optional <code>persist</code> property of A/V Control objects.
<li>When the <code>data</code> attribute and/or the type attribute of the <code>HTMLObjectElement</code> representing the A/V Control object is given a different value, the object SHALL go to state 0 ('<code>stopped</code>').
<li>For playback of DRM protected content, the rights for playback are retrieved during state 3 ('<code>connecting</code>').
<li>If the play position reaches the end of the available content the A/V Control object SHALL be set to state 5 ('<code>finished</code>') in addition to generating a playback speed change of zero.
<li>If there is an attempt to <code>play()</code> with a speed in the positive direction (forward or &gt; 0) and there is no content available then the request fails.
<li>If the play position reaches the beginning of the available content the A/V Control object SHALL be set to state 2 ('<code>paused</code>') in addition to generating a playback speed change of zero.
<li>If there is an attempt to <code>play()</code> with a speed in the negative direction (rewind or &lt; 0) and there is no content available then the request fails.
<li>If <code>seek()</code> is performed beyond the available content the request is rejected and the current playout is maintained.
<li>When a A/V Control object stops being rendered as defined in section 10.1 of the HTML5 specification as referenced by [[!OIPF_WSTVP2]] an OITF MAY release scarce resources allocated for that object. Vice versa, an A/V Control object which is not visible but is still being rendered SHALL still be decoding video if it is in the playing state and any audio associated with the currently playing media will still be audible.  State transitions caused by calls to methods on the A/V Control object, or due to permanent or transient errors, will occur as shown above regardless of the visibility of the object. Section <a href="#claiming-scarce-resources" class="sectionRef"></a> describes the effect on scarce resources when an A/V Control object is removed from the DOM tree.
<li>NOTE: as implied by the text above, rendering state and visibility are not equivalent. This implies, just to give two examples, that <code>display:none</code> will affect the object state while <code>visibility:hidden</code> will not. When an A/V Control object is destroyed (e.g. by the A/V Control object being garbage collected, or because of a page transition within the application), presentation of streamed audio or video shall be terminated. 
<li>When not presenting video, the A/V Control object SHALL be rendered as an opaque black rectangle.
</ol>
</section>

<section id="using-av-control-for-streaming-content">
<h4>Using an A/V Control object to play streaming content</h4>
<p>If an A/V Control object is used to play streamed content using either RTSP or HTTP the OITF then the following holds:</p><ol>
<li>If <code>play(0)</code> is called in state 0 ('<code>stopped</code>'), the A/V Control object SHALL automatically go to play state 2 ('<code>paused</code>'). The necessary resources are secured and no external signalling is performed.
<li>If <code>play(0)</code> is called in the connecting or buffering state, the A/V Control object SHALL automatically go to play state 2 ('<code>paused</code>')
<li>If <code>play()</code> is called in the paused state with an argument other than 0, the A/V Control object SHALL transition to one of the following states as follows:<ol type="a">
<li>If there is no connection to the server, the A/V Control object SHALL transition to the connecting state.
<li>If there is a connection to the server but insufficient content is buffered to resume playback immediately, the A/V Control object SHALL transition to the buffering state.
<li>If there is a connection to the server and sufficient content is buffered to resume playback immediately, the A/V Control object SHALL transition to the playing state.
</ol></ol>
</section>
<section id="using-av-control-for-downloaded-content">
<h4>Using an A/V Control object to play downloaded content</h4>
<p>If an A/V Control object is used to play content that has been downloaded and stored on the OITF (by using method <a href="#av-control-setsource" class="apiRef">setSource()</a> as defined in section <a href="#av-control-extensions-for-playing-media-objects" class="sectionRef"></a>) then the following holds:</p><ol>
<li>if the download was triggered using <a href="#downloadtrigger-registerdownloadurl" class="apiRef">registerDownloadURL</a> or the download was triggered using a Content Access Download Descriptor with &lt;TransferType&gt; value &ldquo;playable_download&rdquo; as defined in Annex <a href="#content-access-download-descriptor-format" class="sectionRef"></a>, then:<ol type="a">
<li>if the <code>play()</code> method is called before sufficient data has been download to initiate playback, then the play state of the A/V Control object SHALL be set to 6 ('error') with a detailed error code of 5 (&ldquo;content not available&rdquo;).</ol> 
<li>if the downloaded content was triggered using a Content Access Download Descriptor with &lt;TransferType&gt; value &ldquo;full_download&rdquo; as defined in Annex <a href="#content-access-download-descriptor-format" class="sectionRef"></a>, then:<ol type="a">
<li>if the <code>play()</code> method is called whilst the content is still downloading and has not yet successfully completed, then the play state of the A/V Control object SHALL be set to 6 ('error') with a detailed error code of 5 (&ldquo;content not available&rdquo;).
</ol></ol>
</section>
<section id="using-av-control-for-recorded-content">
<h4>Using an A/V Control object to play recorded content</h4>
<p>If an A/V Control object is used to play content that has been recorded or is being recorded on the OITF (by using method <a href="#av-control-setsource" class="apiRef">setSource()</a> as defined in section <a href="#av-control-extensions-for-playing-media-objects" class="sectionRef"></a>) then the following holds:</p><ol>
<li>if the <code>play()</code> method is called before sufficient data has been recorded to initiate playback, then the play state of the A/V Control object SHALL be set to 6 ('error') with a detailed error code of 5 (&ldquo;content not available&rdquo;).
</ol>
</section>
<section id="using-av-control-for-content_fragments">
<h4>Using the A/V Control object to play content fragments</h4>
<p>If the OITF indicates support through the <code>&lt;temporalClipping&gt;</code> capability indicator (see section <a href="#temporal-clipping-support" class="sectionRef"></a>) for playing content fragments then it SHALL support the Media Fragment URI [[!Media-Fragments-URI]] according to section <a href="#media-fragments-support" class="sectionRef"></a>. </p>
</section>
<section id="user-input-and-av-control-object">
<h4>User Input and the A/V Control object  </h4>
<p>If an A/V Control object has input focus:</p><ul>
<li>The OITF SHALL not block execution of scripts of the document from which the focus was moved to the video object, even when the video is playing full-screen and has input focus.
<li>The OITF SHALL NOT handle the <code>VK_OK</code>, <code>VK_PLAY</code>, <code>VK_PAUSE</code>, <code>VK_PLAY_PAUSE</code>, <code>VK_STOP</code>, <code>VK_FAST_FWD</code>, <code>VK_REWIND</code>, <code>VK_NEXT</code> or <code>VK_PREV</code> keys. 
</ul>
</section>
</section>

<section id="av-control-extensions-for-playback-through-casd">
<h3>Extensions to A/V Control object for playback through Content-Access Streaming Descriptor</h3>
<p>As specified in section <a href="#unicast-streaming" class="sectionRef"></a>, an OITF SHALL support setting up the A/V stream using the information provided by a valid Content Access Streaming Descriptor referred to by the '<code>data</code>' attribute. To this end, the OITF SHALL fetch the Content Access Streaming Descriptor from the URL provided by the <code>data</code> attribute, after which the descriptor SHALL be interpreted, resulting in an appropriate <code>&lt;ContentURL&gt;</code> to be selected (e.g. based on which DRM system the OITF supports). The OITF SHALL then initiate a streaming CoD session to the selected <code>&lt;ContentURL&gt;</code>, after which playback can be started when the <code>play()</code> method is invoked. </p>
<p>The OITF SHALL pass included DRM-information of the selected content and DRM system ID as part of the <code>&lt;DRMControlInformation&gt;</code> elements of a Content Access Streaming Descriptor to the DRM agent, if it supports a DRM agent with a matching <code>DRMSystemID</code> as per section <a href="#drm-capability-indication" class="sectionRef"></a>.</p>
<p>If the Content Access Streaming Descriptor is not valid according to the XML Schema and semantics as defined in Annex <a href="#content-access-streaming-descriptor-format" class="sectionRef"></a>, the A/V Control object SHALL go to playState 6 (i.e. error), with error value 4, which is defined as follows in addition to the error states identified by bullet 5 of [Req. 5.7.1.f] of CEA-2014-A:</p><ul class="nobullet">
<li>4: content corrupt or invalid.
</ul>
<p>For more information about setting up the A/V stream based on a Content Access Streaming descriptor, see section <a href="#unicast-streaming" class="sectionRef"></a>, section <a href="#dae-system-integration-aspects" class="sectionRef"></a> and Annex <a href="#cod-clarification" class="sectionRef"></a>.</p>

</section>

<section id="av-control-extensions-for-trickmodes">
<h3>Extensions to A/V Control object for trickmodes</h3>
<p>The following additional properties SHALL be supported on the audio object and video object defined in section 5.7.1 of [[!CEA-2014-A]].</p>
<section id="av-control-trickmodes-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="av-control-onplayspeedchanged">
<tr><td class="api-signature">function <b>onPlaySpeedChanged</b>( Number speed )</td></tr>
<tr><td><p>The function that is called when the playback speed of the media changes.</p>
<p>The specified function is called with one argument, <code>speed</code>, which is defined as follows:</p><ul>
<li><code>Number speed</code> &mdash; the playback speed of the media at the time the event was dispatched.
</ul>
<p>The behaviour of the A/V Control object when the end of media (or the end of the currently-available media) is reached is defined in section <a href="#av-control-object" class="sectionRef"></a>.</p>
</td></tr>
</table>
<table class="dae-property-table" id="av-control-onplaypositionchanged">
<tr><td class="api-signature">function <b>onPlayPositionChanged</b>( Integer position )</td></tr>
<tr><td><p>The function that is called when change occurs in the play position of the media due to the use of trick play functions.</p>
<p>The specified function is called with one argument, <code>position</code>, which is defined as follows:</p><ul>
<li><code>Integer position</code> &mdash; the playback position of the media at the time the event was dispatched, measured in milliseconds since the beginning of the referenced media as denoted by the server.
</ul>
<p>The behaviour of the A/V Control object when the end of media (or the end of the currently-available media) is reached is defined in section <a href="#av-control-object" class="sectionRef"></a>.</p>
</td></tr>
</table>
<table class="dae-property-table" id="av-control-playspeeds">
<tr><td class="api-signature">readonly Number <b>playSpeeds</b>[ ]</td></tr>
<tr><td>Returns an ordered list of playback speeds, expressed as values relative to the normal playback speed (1.0), at which the currently specified A/V content can be played (either through an CEA-2014 audio or video object), or <code>undefined</code> if the supported playback speeds are not (yet) known.</td></tr>
</table>
<table class="dae-property-table" id="av-control-onplayspeedsarraychanged">
<tr><td class="api-signature">function  <b>onPlaySpeedsArrayChanged</b>( )</td></tr>
<tr><td>The function that is called when the <a href="#av-control-playspeeds" class="apiRef">playSpeeds</a> array values have changed. An application that makes use of the <a href="#av-control-playspeeds" class="apiRef">playSpeeds</a> array needs to read the values of the <a href="#av-control-playspeeds" class="apiRef">playSpeeds</a> property again.</td></tr>
</table>
<table class="dae-property-table" id="av-control-oitfsourceipaddress">
<tr><td class="api-signature">readonly String <b>oitfSourceIPAddress</b></td></tr>
<tr><td>The OITF source IP address for RTSP or HTTP signalling, as well as, the address where the RTSP stream is expected to arrive. The information shall be available in &ldquo;<code>buffering</code>&rdquo;, &ldquo;<code>paused</code>&rdquo; or &ldquo;<code>playing</code>&rdquo; states.</td></tr>
</table>
<table class="dae-property-table" id="av-control-oitfsourceportaddress">
<tr><td class="api-signature">readonly String <b>oitfSourcePortAddress</b></td></tr>
<tr><td>The OITF Port Address where the RTSP stream is expected to arrive. The information shall be available in &ldquo;<code>buffering</code>&rdquo;, &ldquo;<code>paused</code>&rdquo; or &ldquo;<code>playing</code>&rdquo; states.</td></tr>
</table>
<table class="dae-property-table" id="av-control-oitfnortspsessioncontrol">
<tr><td class="api-signature">Boolean <b>oitfNoRTSPSessionControl</b></td></tr>
<tr><td>When the <code>oitfNoRTSPSessionControl</code> is set to <code>true</code> then the OITF SHALL NOT signal the RTSP messages DESCRIBE, SETUP or TEARDOWN. </td></tr>
</table>
<table class="dae-property-table" id="av-control-oitfrtspsessionid">
<tr><td class="api-signature">String <b>oitfRTSPSessionId</b></td></tr>
<tr><td>The sessionId to be used by the A/V Control object when signalling RTSP. This property is only applicable when property <a href="#av-control-oitfnortspsessioncontrol" class="apiRef">oitfNoRTSPSessionControl</a> is set to <code>true</code>.</td></tr>
</table>
</section>
<section id="av-control-trickmodes-events">
<h4>Events</h4>
<p>For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:</p>
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#av-control-onplayspeedchanged" class="apiRef">onPlaySpeedChanged</a></td><td>PlaySpeedChanged</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>speed</code></td></tr>
<tr><td><a href="#av-control-onplaypositionchanged" class="apiRef">onPlayPositionChanged</a></td><td>PlayPositionChanged</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>position</code></td></tr>
<tr><td><a href="#av-control-onplayspeedsarraychanged" class="apiRef">onPlaySpeedsArrayChanged</a></td><td>PlaySpeedsArrayChanged</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: None</td></tr>
</table>
Note: the DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the A/V Control object itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>

</section>
<section id="av-control-extensions-for-playback-of-selected-components">
<h3>Extensions to A/V Control object for playback of selected components</h3>
<p>To support the selection of specific A/V components for playback (e.g. a specific subtitle language, audio language, or camera angle), the classes defined in sections <a href="#avcomponent-class" class="sectionRef"></a> &mdash; <a href="#avsubtitlecomponent-class" class="sectionRef"></a> SHALL be supported and the constants, properties and methods defined in section <a href="#media-playback-extensions" class="sectionRef"></a> SHALL be supported on the A/V Control object.</p>
</section>
<section id="av-control-extensions-for-parental-rating-errors">
<h3>Extensions to A/V Control object for parental rating errors</h3>
<p>For parental rating errors during playback of A/V content through the CEA-2014 A/V Control object (as defined in section 5.7.1 of [[!CEA-2014-A]]) an OITF SHALL support the following intrinsic event properties and corresponding DOM events for the CEA-2014 A/V Control object.</p>
<table class="dae-property-table" id="av-control-onparentalratingchange">
<tr><td class="api-signature">function <b>onParentalRatingChange</b>( String contentID, <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> ratings, String DRMSystemID, Boolean blocked )</td></tr>
<tr><td><p>The function that is called whenever the parental rating of the content being played inside the A/V Control object changes. </p>
<p>These events may occur at the start of a new content item, or during playback of a content item (e.g. during playback of A/V streaming content).</p>
<p>The specified function is called with four arguments <code>contentID</code>, <code>ratings</code>, <code>DRMSystemID</code>, and <code>blocked</code> which are defined as follows:</p><ul>
<li><code>String contentID</code> &mdash; the content ID to which the parental rating change applies. If the event is generated by the DRM system, it SHALL be the unique identifier for that content in the context of the DRM system  (i.e. in the case of Marlin BB it is the Marlin contentID, in the case of CSPG-CI+ the value of this field is <code>null</code>). Otherwise, it MAY be <code>null</code> or <code>undefined</code>.
<li><code><a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> ratings</code> &mdash; the parental ratings of the currently playing content. The <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> object is defined in section <a href="#parentalratingcollection-class" class="sectionRef"></a>.
<li><code>String DRMSystemID</code> &mdash; the DRM System ID of the DRM system that generated the event as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. The value SHALL be <code>null</code> if the parental control is not enforced by a particular DRM system.
<li><code>Boolean blocked</code> &mdash; flag indicating whether consumption of the content is blocked by the parental control system as a result of the new parental rating value.
</ul></td></tr>
</table>

<table class="dae-property-table" id="av-control-onparentalratingerror">
<tr><td class="api-signature">function <b>onParentalRatingError</b>( String contentID, <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> ratings, String DRMSystemID )</td></tr>
<tr><td><p>The function that is called when a parental rating error occurs during playback of A/V content inside the A/V Control object, and is triggered whenever one or more parental ratings are discovered and none of them are valid. A valid parental rating is defined as one which uses a parental rating scheme that is supported by the OITF and which has a parental rating value that is supported by the OITF.</p>
<p>The specified function is called with three arguments <code>contentID</code>, <code>ratings</code>, amd <code>DRMSystemID</code> which are defined as follows:</p><ul>
<li><code>String contentID</code> &mdash; the content ID to which the parental rating error applies. If the event is generated by the DRM system, it SHALL be the unique identifier for that content in the context of the DRM system  (i.e. in the case of Marlin BB it is the Marlin contentID, in the case of CSPG-CI+ the value of this field is <code>null</code>). Otherwise, it MAY be <code>null</code> or <code>undefined</code>.
<li><code><a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> ratings</code> &mdash; the parental ratings of the currently playing content. The <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> object is defined in section <a href="#parentalratingcollection-class" class="sectionRef"></a>.
<li><code>String DRMSystemID</code> &mdash; optional argument that specifies the DRM System ID of the DRM system that generated the event as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. The value SHALL be <code>null</code> if the parental control is not enforced by a particular DRM system.
</ul></td></tr>
</table>

<section id="av-control-parental-rating-events">
<h4>Events</h4>
<p>For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:</p>
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#av-control-onparentalratingchange" class="apiRef">onParentalRatingChange</a></td><td>ParentalRatingChange</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>contentID</code>, <code>ratings</code>, <code>DRMSystemID</code>, <code>blocked</code></td></tr>
<tr><td><a href="#av-control-onparentalratingerror" class="apiRef">onParentalRatingError</a></td><td>ParentalRatingError</td><td>Bubbles: No <br />Cancellable: No <br />Context Info: <code>contentID</code>, <code>ratings</code>, <code>DRMSystemID</code></td></tr>
</table>
<p>Note: the above DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. The applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the CEA-2014 A/V embedded object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
</section>

</section>
<section id="av-control-extensions-for-drm-rights-errors">
<h3>Extensions to A/V Control object for DRM rights errors</h3>
<p>This section SHALL apply to OITF and/or server devices which have indicated support for DRM protection by providing one or more <code>&lt;drm&gt;</code> elements as specified in section <a href="#drm-capability-indication" class="sectionRef"></a>:</p>
<p>For notifying JavaScript about DRM licensing errors during playback of DRM protected A/V content through the CEA-2014 A/V Control object (as defined by as defined in section 5.7.1 of CEA-2014-A)  an OITF SHALL support the following intrinsic event property and corresponding DOM event, for the CEA-2014 A/V Control object.</p>

<table class="dae-property-table" id="av-control-ondrmrightserror">
<tr><td class="api-signature">function <b>onDRMRightsError</b>( Integer errorState, String contentID, String DRMSystemID, String rightsIssuerURL )</td></tr>
<tr><td><p>The function that is called:</p><ul>
<li>Whenever a rights error occurs for the A/V content (no license, license invalid), which has led to blocking consumption of the content.
<li>Whenever a rights change occurs for the A/V content (license valid), which leads to unblocking the consumption of the content.
</ul>
<p>This may occur during playback, recording or timeshifting of DRM protected AV content.</p>
<p>The specified function is called with four arguments <code>errorState</code>, <code>contentID</code>, <code>DRMSystemID</code> and <code>rightsIssuerURL</code> which are defined as follows:</p><ul>
<li><code>Integer errorState</code> &mdash; error code detailing the type of error:<ul class="nobullet">
<li>0:   no license, consumption of the content is blocked
<li>1:   invalid license, consumption of the content is blocked
<li>2:   valid license, consumption of the content is unblocked</ul>
<li><code>String contentID</code> &mdash; the unique identifier of the protected content in the scope of the DRM system that raises the error (i.e. in the case of Marlin BB it is the Marlin contentID, in the case of CSPG-CI+ the value of this field is <code>null</code>). 
<li><code>String DRMSystemID</code> &mdash; DRMSystemID as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For example, for Marlin, the DRMSystemID value is &ldquo;<code>urn:dvb:casystemid:19188</code>&rdquo;.
<li><code>String rightsIssuerURL</code> &mdash; optional element indicating the value of the rightsIssuerURL that can be used to non-silently obtain the rights for the content item currently being played for which this DRM error is generated, in cases whereby the rightsIssuerURL is known. Cases whereby the rightsIssuerURL is known include cases whereby the rightsIssuerURL has been extracted from the MPEG2_TS of the protected content, retrieved from the SD&amp;S discovery record or from the associated BCG metadata. The corresponding rightsIssuerURL fields are defined in <mark class="error">section 4.1.3.4 of [[.OIPF_CSP2]]</mark> and in <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]] respectively. If different URLs are retrieved from the stream and the metadata, then the conflict resolution is implementation-dependent.<div class="editor-note">No version of the OIPF CSP specification has contained a section 4.1.3.4 - the required information/reference may be in a different section</div>
</ul></td></tr>
</table>
<p>For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:</p>
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#av-control-ondrmrightserror" class="apiRef">onDRMRightsError</a></td><td>DRMRightsError</td><td>Bubbles: No<br />Cancellable: No <br />Context Info: <code>errorState</code>, <code>contentID</code>, <code>DRMSystemID</code>, <code>rightsIssuerURL</code>
</td></tr>
</table>
Note: the above DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving a DRMRightsError event during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the CEA-2014 A/V Control object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.

</section>
<section id="av-control-extensions-for-playing-media-objects">
<h3>Extensions to A/V Control object for playing media objects</h3>
<p>OITFs that support the API defined in sections <a href="#metadata-apis" class="sectionRef"></a>, <a href="#drmcontrolinformation-class" class="sectionRef"></a> and <a href="#content-download-apis" class="sectionRef"></a> SHALL support playback of downloaded and / or recorded content as follows:</p><ol>
<li>Firstly, by setting the data attribute of the A/V Control object to that returned from the <code>uri</code> property of the <a href="#download-class" class="apiRef">Download</a> or <a href="#recording-class" class="apiRef">Recording</a> object to be played back.
<li>Using the method defined below on the A/V Control object which SHALL be supported if any of the APIs defined in those sections are supported.
<li>where the HTML5 media elements are supported (see section <a href="#html5-video-capability" class="sectionRef"></a>), by setting the <code>src</code> attribute of a <code>&lt;video&gt;</code> element to that returned from the <code>uri</code> property of the <a href="#download-class" class="apiRef">Download</a> or <a href="#recording-class" class="apiRef">Recording</a> object to be played back.
</ol>

<table class="dae-method-table" id="av-control-setsource">
<tr><td colspan="3" class="api-signature">Boolean <b>setSource</b>( String id )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<script>

</script>

<td colspan="2"><p>Change the content item to be played by the A/V Control object to the content item represented by id. Valid IDs include:</p><ul>
<li>Download identifiers (i.e. corresponding to property <a href="#download-id" class="apiRef">Download.id</a>)
<li>Recording identifiers (i.e. corresponding to property <a href="#recording-id" class="apiRef">Recording.id</a>)
<li>CODAsset identifiers (i.e. corresponding to <mark class="error">property <a href="#codasset-uid" class="apiRef">CODAsset.uid</a></mark>)
<div class="editor-note">This property is present only in the following DAE versions (1.0, 1.1)</div>
</ul>
<p>Support for each of these identifier types depends on the support for the individual sections in which they are defined.</p>
<p>Depending on the type of content for id, the following semantics apply:<p>
<p>If <code>id</code> is a download identifier, the OITF SHALL change the content item to be played to the downloaded item, or item being downloaded, for which the <a href="#download-id" class="apiRef">Download.id</a> property (as defined in section <a href="#download-properties" class="sectionRef"></a>) corresponds to the given download identifier. The <code>type</code> attribute of the A/V Control object SHOULD change to the MIME type of the content item represented by the download identifier, or the MIME type of the content item corresponding to the first content item listed in the Content Access Download Descriptor in case the download identifier represents a download of a Content Access Download Descriptor that contains multiple <code>&lt;ContentItem&gt;</code> elements. The <code>data</code> attribute SHALL change to the same value as the download identifier. Section <a href="#using-av-control-for-downloaded-content" class="sectionRef"></a> defines more details about playback of downloaded content, and how it relates to the states of the A/V Control object.</p>
<p>If <code>id</code> is a recording identifier, the OITF SHALL change the content item to be played to the recorded item, or item being recorded, for which the <a href="#recording-id" class="apiRef">Recording.id</a> property (as defined in section <a href="#recording-properties" class="sectionRef"></a>) corresponds to the given recording identifier. The <code>type</code> attribute of the A/V Control object SHOULD change to the MIME type of the format in which the content was recorded. The <code>data</code> attribute SHALL change to the same value as the recording identifier.</p>
<p>If <code>id</code> is a COD asset identifier, the OITF SHALL change the content item to be played to the CODAsset, for <mark class="error">which the <a href="#codasset-uid" class="apiRef">CODAsset.uid</a> property (as defined in section <a href="#codasset-properties" class="sectionRef"></a>) </mark>corresponds to the given COD asset identifier. The <code>type</code> attribute of the A/V Control object SHOULD change to the MIME type of the COD Asset. The <code>data</code> attribute SHALL change to the same value as to COD asset identifier. </p>

<div class="editor-note">This property is present only in the following DAE versions (1.0, 1.1)</div>
<p>If the content item represented by <code>id</code> can be accepted by the A/V Control object for playback, the method returns <code>true</code>. The method returns <code>false</code> if the item cannot be accepted for playback.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">id</td><td>The ID of the item to be played.</td></tr>
</table>

</section>
<section id="av-control-extensions-for-ui-feedback-of-buffering">
<h3>Extensions to A/V Control object for UI feedback of buffering A/V content</h3>
<p>If an OITF has indicated support for playback control as defined in section <a href="#buffer-control-of-playback-support" class="sectionRef"></a> in its capability description, the A/V Control object defined in section 5.7.1 of [[!CEA-2014-A]] SHALL support the properties and methods defined in this section as follows;</p><ul>
<li>If the <code>type</code> attribute of the <code>&lt;playbackControl&gt;</code> element includes &ldquo;<code>buffering</code>&rdquo; then <a href="#av-control-onreadytoplay" class="apiRef">onReadyToPlay</a>, <a href="#av-control-readytoplay" class="apiRef">readyToPlay</a>, <a href="#av-control-supportedstrategies" class="apiRef">supportedStrategies</a>, <a href="#av-control-getavailableplaytime" class="apiRef">getAvailablePlayTime</a> and <a href="#av-control-setbufferingstrategy" class="apiRef">setBufferingStrategy</a> SHALL be supported.
<li>If the <code>type</code> attribute of the <code>&lt;playbackControl&gt;</code> element includes &ldquo;<code>has</code>&rdquo; then <a href="#av-control-onrepresentationchange" class="apiRef">onRepresentationChange</a>, <a href="#av-control-onperiodchange" class="apiRef">onPeriodChange</a>, <a href="#av-control-availablerepresentationsbandwidth" class="apiRef">availableRepresentationsBandwidth</a>, <a href="#av-control-currentrepresentation" class="apiRef">currentRepresentation</a>, <a href="#av-control-maxrepresentation" class="apiRef">maxRepresentation</a>, <a href="#av-control-minrepresentation" class="apiRef">minRepresentation</a> and <a href="#av-control-setrepresentationstrategy" class="apiRef">setRepresentationStrategy</a> SHALL be supported.
<li>If the <code>type</code> attribute of the <code>&lt;playbackControl&gt;</code> element  includes &ldquo;<code>dash</code>&rdquo; then <a href="#av-control-onrepresentationchange" class="apiRef">onRepresentationChange</a>, <a href="#av-control-onperiodchange" class="apiRef">onPeriodChange</a>, <a href="#av-control-availablerepresentationsbandwidth" class="apiRef">availableRepresentationsBandwidth</a>, <a href="#av-control-currentrepresentation" class="apiRef">currentRepresentation</a>, <a href="#av-control-maxrepresentation" class="apiRef">maxRepresentation</a>, <a href="#av-control-minrepresentation" class="apiRef">minRepresentation</a>, <a href="#av-control-setrepresentationstrategy" class="apiRef">setRepresentationStrategy</a>, <a href="#av-control-availablerepresentationids" class="apiRef">availableRepresentationIds</a> and <a href="#av-control-currentrepresentationid" class="apiRef">currentRepresentationId</a> SHALL be supported
</ul>
<section id="av-control-ui-feedback-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="av-control-readytoplay">
<tr><td class="api-signature">Boolean <b>readyToPlay</b></td></tr>
<tr><td><p>Property that can be used to inspect whether or not enough (as determined by the OITF) of the media after the current play position has been buffered to start playback. </p>
<p>Returns <code>true</code> if enough data has been buffered. Returns <code>false</code> if not enough data has been buffered. </p></td></tr>
</table>
<table class="dae-property-table" id="av-control-onreadytoplay">
<tr><td class="api-signature">function <b>onReadyToPlay</b></td></tr>
<tr><td><p>The function that gets called when enough (as determined by the OITF) of the media after the current play position has been buffered to start/continue playback.</p>
<p>This event SHALL be generated whenever there is a state transition between state 4 (&ldquo;<code>buffering</code>&rdquo;) and state 1 (&ldquo;<code>playing</code>&rdquo;). The event SHALL also be generated at the moment that enough data has been buffered to start playback, whilst in state 2 ('<code>paused</code>'). </p></td></tr>
</table>

<table class="dae-property-table" id="av-control-onrepresentationchange">
<tr><td class="api-signature">function <b>onRepresentationChange</b>( Integer bandwidth, Integer position, String id )</td></tr>
<tr><td><p>When a HAS stream is being presented the function that SHALL be called when the stream changes Representation and the bandwidth is modified. The bandwidth relates to the bandwidth attribute in the Representation element of HTTP Adaptive Streaming manifest.</p><p>The stream change relates to presentation changes and not necessarily how the stream is buffered. Note that multiple streams representing different qualities may be buffered and therefore is unreliable to indicate bandwidth change.</p>
<p>The specified function SHALL be called with three arguments <code>bandwidth</code>, <code>position</code> and <code>id</code> which are defined as follows:</p><ul>
<li><code>Integer bandwidth</code> &mdash; the bandwidth associated with the new Representation. The unit used to represent bandwidth is the same as the bandwidth attribute in the manifest (i.e. bits per second (bps)). 
<li><code>Integer position</code> &mdash; the position at which the transition to the new list of Representations associated with the new Period occurs. This should be in advance of the current play position but may not be.
<li><code>String id</code> &mdash; the identifier of the new Representation. This identifier SHALL be provided if the MPD includes an &ldquo;id&rdquo; attribute on the representation.
</ul></td></tr>
</table>

<table class="dae-property-table" id="av-control-onperiodchange">
<tr><td class="api-signature">function <b>onPeriodChange</b>( <a href="#integercollection-class" class="apiRef">IntegerCollection</a> bandwidths, Integer position, <a href="#stringcollection-class" class="apiRef">StringCollection</a> ids )
</td></tr>
<tr><td><p>When a HAS stream or a DASH stream is being presented the function that SHALL be called immediately when a new manifest for a new Period is loaded AND the Representations and associated bandwidth are different to the current manifest. The bandwidth relates to the bandwidth attribute in the Representation element of the manifest.</p>
<p>Note this should allow for an application to influence the buffering strategy before the position is reached but it not guaranteed. In which case the buffering strategy may take effect after presentation of the new Period has been initiated. When the function is called it should be possible to modify the selected max and min Representation. </p>
<p>The specified function SHALL be called with three arguments <code>bandwidths</code>, <code>position</code> and <code>ids</code> which are defined as follows:</p><ul>
<li><code><a href="#integercollection-class" class="apiRef">IntegerCollection</a> bandwidths</code> &mdash; the list of bandwidths associated with the new Period. 
<li><code>Integer position</code> &mdash; the position at which the transition to a new Representation occurs. This should be in advance of the current <code>playPosition</code> but may not be.
<li><code><a href="#stringcollection-class" class="apiRef">StringCollection</a> ids</code> &mdash; These identifiers SHALL be provided if the MPD includes an &ldquo;id&rdquo; attribute on the representation.	
</ul></td></tr>
</table>

<table class="dae-property-table" id="av-control-availablerepresentationsbandwidth">
<tr><td class="api-signature">readonly <a href="#integercollection-class" class="apiRef">IntegerCollection</a> <b>availableRepresentationsBandwidth</b></td></tr>
<tr><td>When a HAS stream or a DASH stream is being presented, return an ordered list of the available Representations. Each Representation SHALL be identified by its respective bandwidth.  Each Representation is identified by the bandwidth attribute in the Representation element of the MPD (as defined in [[!OIPF_HAS2]] or [[!DASH]]).</td></tr>
</table>

<table class="dae-property-table" id="av-control-availablerepresentationids">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>availableRepresentationIds</b></td></tr>
<tr><td>If a stream is being presented that is described by an MPD and the MPD includes an <code>id</code> attribute on the representation then return an ordered list of the available Representations identified by the <code>id</code>. If the MPD does not include this attribute or if the player is a state other than play state 1 (<code>playing</code>) then the value SHALL be undefined.</td></tr>
</table>

<table class="dae-property-table" id="av-control-currentrepresentation">
<tr><td class="api-signature">readonly Integer <b>currentRepresentation</b></td></tr>
<tr><td>When a HAS stream or DASH stream is being presented return Representation that is being presented. The Representation is identified by the bandwidth attribute in the Representation element of the MPD (as defined in [[!OIPF_HAS2]] or [[!DASH]]). The bandwidth is only available in play state 1 ('<code>playing</code>'), in other states the value is undefined.</td></tr>
</table>

<table class="dae-property-table" id="av-control-currentrepresentationid">
<tr><td class="api-signature">readonly String <b>currentRepresentationId</b></td></tr>
<tr><td>If a stream is being presented that is described by an MPD and the MPD includes an <code>id</code> attribute on the representation then return the <code>id</code> of the Representation that is being presented. If any other type of stream is being presented or if the player is in a state other than play state 1 ('<code>playing</code>') then the value is undefined.</td></tr>
</table>

<table class="dae-property-table" id="av-control-maxrepresentation">
<tr><td class="api-signature">readonly Integer <b>maxRepresentation</b></td></tr>
<tr><td>Returns the maximum supported bandwidth from the <a href="#av-control-availablerepresentationsbandwidth" class="apiRef">availableRepresentationsBandwidth</a> property. Note that calling the <a href="#av-control-setrepresentationstrategy" class="apiRef">setRepresentationStrategy()</a> method may modify the maximum bandwidth.</td></tr>
</table>
<table class="dae-property-table" id="av-control-minrepresentation">
<tr><td class="api-signature">readonly Integer <b>minRepresentation</b></td></tr>
<tr><td>Returns the minumum supported bandwidth from the <a href="#av-control-availablerepresentationsbandwidth" class="apiRef">availableRepresentationsBandwidth</a> property. Note that calling the <a href="#av-control-setrepresentationstrategy" class="apiRef">setRepresentationStrategy()</a> method may modify the minimum bandwidth.</td></tr>
</table>

<table class="dae-property-table" id="av-control-supportedstrategies">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>supportedStrategies</b></td></tr>
<tr><td>The list of the supported buffering strategies. The supported strategy names are listed below. Note that other strategies may be supported.<ul>
<li>&ldquo;<code>sustained_playback</code>&rdquo;: if this strategy is supported then the method <a href="#av-control-setbufferingstrategy" class="apiRef">setBufferingStrategy()</a> SHALL be supported with this strategy. 
<li>&ldquo;<code>low_latency</code>&rdquo;: if this strategy is supported then the method <a href="#av-control-setbufferingstrategy" class="apiRef">setBufferingStrategy()</a> SHALL be supported with this strategy.
<li>&ldquo;<code>representation_strategy</code>&rdquo;: if this strategy is supported then the method <a href="#av-control-setrepresentationstrategy" class="apiRef">setRepresentationStrategy()</a> SHALL be supported.
</ul></td></tr>
</table>
</section>
<section id="av-control-ui-feedback-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="av-control-getavailableplaytime">
<tr><td colspan="3" class="api-signature">Integer <b>getAvailablePlayTime</b>( Boolean fromPlayPosition )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Returns how much content is available  for playback.</p>
<p>If argument <code>fromPlayPosition</code> has value <code>true</code>, this method returns an estimate of how much data in milliseconds is available in the buffer for play back after the current play position. </p>
<p>If argument <code>fromPlayPosition</code> has value <code>false</code>, this method returns an estimate of the total buffer length in milliseconds (i.e. this includes all data available in the buffer before and after the current play position).</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">fromPlayPosition</td><td>Indicates whether the available play time should be calculated from the current play position onwards, or from the start of the buffer.</td></tr>
</table>

<table class="dae-method-table" id="av-control-setbufferingstrategy">
<tr><td colspan="3" class="api-signature">Boolean <b>setBufferingStrategy</b>( String name )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Request to change the buffering strategy to that given by name. </p>
<p>This method can be called during any play state, including play state 1 ('<code>playing</code>').</p>
<p>This method returns <code>true</code> if the buffering strategy has been successfully changed to the preferred buffering strategy. The method returns <code>false</code> if the buffering strategy has not been successfully changed.</p>
<p>If the OITF does not distinguish between the two modes, the method returns <code>false</code>.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">name</td><td><p>The name of the requested buffering strategy. Valid values include:</p>
<p>&ldquo;<code>sustained_playback</code>&rdquo;: this is the default strategy, whereby the incoming video stream should be rendered with as little hickups or lost frames as possible. This means that the buffering threshold for triggering an <a href="#av-control-onreadytoplay" class="apiRef">onReadyToPlay</a> event is chosen to be sufficiently large to deal with variations in network throughput.</p>
<p>&ldquo;<code>low_latency</code>&rdquo;: this is a strategy whereby the incoming video stream should be rendered with an as low as possible latency between receiving the content and the actual playback of the content. This means that buffering threshold for triggering an <a href="#av-control-onreadytoplay" class="apiRef">onReadyToPlay</a> event needs to be made sufficiently small in order to playback the content as soon as possible after it has been received. </p>
<p>These values are not case sensitive. The default strategy if the method is not called is &ldquo;<code>sustained_playback</code>&rdquo;.</p>
</td></tr>
</table>

<table class="dae-method-table" id="av-control-setrepresentationstrategy">
<tr><td colspan="3" class="api-signature">Boolean <b>setRepresentationStrategyStrategy</b>( Integer maxBandwidth, Integer minBandwidth, 	Integer position )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Request to change the strategy for selecting which Representation to use from the specified position for HTTP Adaptive Streaming or MPEG DASH. The indicated bandwidth represents the maximum and minimum bandwidth to be allowed. Representations outside of the upper and lower limits SHALL NOT be selected. If data has already been fetched outside these limits then there is no requirement to discard that data.</p>
<p>This method can be called during any play state, including play state 1 ('<code>playing</code>'). Only one change in strategy is in effect and any previous strategy that has not taken effect is overwritten. This method returns <code>true</code> if the strategy has been successfully changed. The method returns <code>false</code> if the buffering strategy has not been successfully changed. </p>
<p>The value of <code>maxBandwidth</code> shall be greater than <code>minBandwidth</code> otherwise the method shall return <code>false</code>. The range between the bandwidth from <code>maxBandwidth</code> and <code>minBandwidth</code> shall allow for at least one of the values from property <a href="#av-control-availablerepresentationsbandwidth" class="apiRef">availableRepresentationsBandwidth</a> otherwise the method shall return <code>false</code>.</p>
<p>If the Period changes and no Representations remain that are within the set Representation strategy then the <code>maxBandwidth</code> and <code>minBandwidth</code> SHALL be reset to <code>undefined</code>. In order to avoid this from occurring the max and/or min bandwidth have to be immediately modified when the <a href="#av-control-onperiodchange" class="apiRef">onPeriodChange</a> function is called.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">maxBandwidth</td><td>The maximum bandwidth allowed for the presentation of adaptive content. If value set to undefined the limit is set by the OITF.</td></tr>
<tr><td class="dae-method-table-argument">minBandwidth</td><td>The minimum  bandwidth allowed for the presentation of adaptive content. If value set to undefined the limit is set by the OITF.</td></tr>
<tr><td class="dae-method-table-argument">position</td><td>This argument is optional. If present it indicates the position at which the new Representation strategy shall be applied. The position should be the same as the position returned in <a href="#av-control-onperiodchange" class="apiRef">onPeriodChange()</a> to make for a smooth transition to a new strategy.</td></tr>
</table>
</section>
<section id="av-control-ui-feedback-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#av-control-onreadytoplay" class="apiRef">onReadyToPlay</a></td><td>ReadyToPlay</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
<tr><td><a href="#av-control-onrepresentationchange" class="apiRef">onRepresentationChange</a></td><td>RepresentationChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>bandwidth</code>, <code>position</code></td></tr>
<tr><td><a href="#av-control-onperiodchange" class="apiRef">onPeriodChange</a></td><td>PeriodChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>bandwidths</code>, <code>position</code></td></tr>
</table>
Note: these DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the CEA-2014 A/V Control object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>

</section>
<section id="av-control-DOM-events">
<h3>DOM events for A/V Control object</h3>
To make the A/V Control object as defined in CEA-2014-A in line with the other scripting objects in section <a href="#dae-apis" class="sectionRef"></a> of this specification, for the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td>onfocus</td><td>focus <div style="font-family: sans-serif;">(as defined in section 5.2.1.2 of the DOM Level 3 Events specification as referenced in [[.OIPF_WSTVP2]])</div></td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
<tr><td>onblur</td><td>blur <div style="font-family: sans-serif;">(as defined in section 5.2.1.2 of the DOM Level 3 Events specification as referenced in [[.OIPF_WSTVP2]])</div></td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
<tr><td>onPlayStateChange</td><td>PlayStateChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
<tr><td>onFullScreenChange</td><td>FullScreenChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: None</td></tr>
</table>
<p>Note: these DOM events are directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the CEA-2014 A/V Control object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.</p>
<p>When handling <code>PlayStateChange</code> events, since the property "<code>playState</code>" of the A/V Control object always returns the current play state, there are a number of considerations:</p><ul>
<li>When accessing the <code>playState</code> property inside a <code>PlayStateChange</code> event handler, its value will be the current state of the related media object that may be different from the state transition that caused the handler to be called.
<li>The <code>playState</code> property may change value during the execution of the <code>PlayStateChange</code> event handler.
<li>For an A/V Control object there is no way to detect which state transition caused the event handler to be executed.
</ul>
</section>

<section id="playback-of-memory-audio">
<h3>Playback of memory audio</h3>
<p>This section describes how an A/V Control object can be used for the playback of audio from memory.</p>
<section id="memory-audio-via-ce-html">
<h4>Usage of CE-HTML tags</h4>
<p>The A/V Control object SHALL be used to play audio clips from memory.  The value of the A/V Control object's type attribute SHALL be set to one of the values defined in <a href="volume2.html#audible-notifications-clips" class="extRef">section 8.2.1</a> of [[.OIPF_MEDIA2]]. The <code>&lt;object&gt;</code> element representing the A/V Control object MAY contain <code>&lt;param</code> elements to set the value of parameters affecting the playback of the clip,  For audio from memory, valid parameters are:</p><ul>
<li><code>cache</code> &mdash; a value of &ldquo;<code>true</code>&rdquo; indicates that the audio clip should be played from memory.  This parameter SHALL be included for all clips to be played from memory.  For formats which can not be played from memory, or for values of the parameter other than &ldquo;true&rdquo;, this parameter SHALL have no effect. The default value of this parameter SHALL be &ldquo;<code>false</code>&rdquo;.
<li><code>loop</code> &mdash; indicates the number of times the audio clip SHALL be played when <code>play()</code> is called. The value SHALL be positive integers or the string &ldquo;<code>infinite</code>&rdquo;, which SHALL play the audio clip continuously until <code>stop()</code> is called or the data property is set to <code>null</code>. The default value of this parameter SHALL be &ldquo;1&rdquo;. 
</ul>
<p>Simultaneous playback of multiple audio clips from memory, or simultaneous playback of audio clips from memory and streaming audio or video presentation SHALL follow the behaviour described in section <a href="#media-control" class="sectionRef"></a>.</p>
</section>
<section id="memory-audio-via-dom">
<h4>Usage of the DOM interface</h4>
<p>For A/V Control objects used to play audio from memory, the following properties and methods SHALL be supported:</p><ul>
<li>The properties <code>data</code>, <code>playState</code>, <code>error</code> and <code>onPlayStateChange</code>, as defined in Req. 5.7.1.f of [[!CEA-2014-A]].
<li>The methods <code>play()</code> and <code>stop()</code>, as defined in Req. 5.7.1.f of [[!CEA-2014-A]].  
</ul>
<p>When the <code>play()</code> method is called, if a <code>&lt;param&gt;</code> element as described above is present where the <code>cache</code> parameter is set to the value &ldquo;<code>true</code>&rdquo;, the OITF SHALL:</p><ul>
<li>attempt to pre-load the audio clip specified by the value of its data property and play the audio clip from memory.  If the terminal cannot pre-load the audio clip due to insufficient memory, the terminal SHALL play the clip as streaming audio.
<li>attempt to retain the audio clip in its cache once playback has finished, until the A/V Control object's data property is modified or the A/V Control object is destroyed. 
</ul>
<p>If the A/V Control object's data property refers to a file in a format other than those listed in <a href="volume2.html#audible-notifications-clips" class="extRef">section 8.2.1</a> of [[.OIPF_MEDIA2]], the A/V Control object SHALL NOT attempt to play the file from memory.</p>
<p>The <code>&lt;param&gt;</code> element as defined in section <a href="#memory-audio-via-dom" class="sectionRef"></a> of this document SHALL be made accessible through a DOM <code>HTMLParamElement</code> object.</p>
</section>
<section id="memory-audio-example">
<h4>Example usage (Informative)</h4>
<p>The following HTML document shows an example of a script to start the playback of memory audio:</p><pre class="javascript">
&lt;head&gt;
 :
&lt;script type="text/javascript"&gt;
     function startBGM() {
         document.getElementById("aid1").play(1);
     }
     :
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;object type="audio/mp4" id="aid1" data="http://www.avsource.com/audio/bgm.aac"&gt;
    &lt;param name="cache" value="true"/&gt;
    &lt;param name="loop" value="infinite"/&gt;
&lt;/object&gt;
 :
&lt;div id="btn1" onclick="startBGM()"&gt;&lt;img src="start1.gif"/&gt;&lt;/div&gt;
 :
&lt;/body&gt;
</pre>
<p>The following HTML document shows an example of a script to stop the playback of memory audio:</p><pre class="javascript">
&lt;head&gt;
  :
&lt;script type="text/javascript"&gt;
     function stopBGM() {
         document.getElementById("aid1").stop();
     }
  :
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;object type="audio/mp4" id="aid1" data="http://www.avsource.com/audio/bgm.aac"&gt;
&lt;param name="cache" value="true"/&gt;
&lt;param name="loop" value="infinite"/&gt;
&lt;/object&gt;
 :
&lt;div id="btn2" onclick="stopBGM()"&gt;&lt;img src="stop1.gif"/&gt;&lt;/div&gt;
  :
&lt;/body&gt;
</pre>
</section>
</section>
<section id="av-control-extensions-for-media-queuing">
<h3>Extensions to A/V Control object for media queuing</h3>
<p>The following additional method SHALL be supported on the audio object and video object defined in section 5.7.1 of [[!CEA-2014-A]].</p>
<table class="dae-method-table" id="av-control-queue">
<tr><td colspan="3" class="api-signature">Boolean <b>queue</b>( String uri )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Queue the media referred to by <code>uri</code> for playback after the current media item has finished playing. If a media item is already queued, <code>uri</code> will not be queued for playback and this method will return <code>false</code>. If the item is queued successfully, this method returns <code>true</code>. If no media is currently playing, the queued item will be played immediately.</p>
<p>If <code>uri</code> is <code>null</code>, any currently queued item will be removed from the queue and this method will return <code>true</code>.</p>
<p>If an A/V Control object is an audio object as defined by section 5.7.1.b.1 of [[!CEA-2014-A]] then queued media items shall only contain audio. If an A/V Control object is a video object as defined by section 5.7.1.b.2 of [[!CEA-2014-A]] then queued media items shall always contain video and may also contain audio and other media components. Applications SHOULD ensure the value of <code>uri</code> refers to a media format appropriate to the instance of the A/V Control object. There are no requirements on queued media items apart from the preceding ones. Specifically, there is no requirement for the MIME type of queued media items to match the contents of the <code>type</code> attribute of the <code>object</code> element. If the value of the <code>type</code> attribute differs from the MIME type of the queued media item, the MIME type SHALL take precedence.</p>
<p>When the current media item has finished playing, the A/V Control object shall transition to the finished state, update the value of the <code>data</code> property with the URL of the queued media item and automatically start playback of the queued media item. The A/V Control object MAY transition to the connecting or buffering states (and generate the necessary <code>PlayStateChange</code> events) before entering the playing state when the queued media item is being presented. Implementations may pre-buffer data from the queued URL before the current media item has finished playing in order to reduce the delay between items.</p>
<p>If the queued media item can be played without transitioning to the connecting or buffering states, then the A/V Control object SHALL generate a <code>PlayStateChange</code> event to the playing state to indicate that the queued media item has started playing.</p>
<p>If playback of the current media item is stopped using the <code>stop()</code> method, or if the <code>data</code> and/or <code>type</code> property is modified, the queued media item SHALL NOT be played and the queued media item shall be discarded as if no item was queued.</p>
<p>Play speed is not affected by transitioning between the current and queued media item.</p>
<p>To avoid race conditions when queuing multiple items for playback, applications should wait for the currently queued item to begin playback before queuing subsequent items, e.g. by queuing the subsequent item when the A/V Control object transitions to the <code>connecting</code>, <code>buffering</code> or <code>playing</code> state for the currently queued item.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">uri</td><td>The media item to be queued, or <code>null</code> to remove the currently-queued item.</td></tr>
</table>
<section id="uri-support-and-queue">
<h4>URI support and the queue method</h4>
<p>All URIs that are supported by the OITF as the <code>data</code> property of the <code>object</code> element SHALL be supported as the <code>uri</code> argument to the queue method. Further;</p><ul>
<li>URIs that directly reference a media item SHALL be supported both with and without a media fragment (as defined in section <a href="#media-fragments-support" class="sectionRef"></a>). 
<li>Using a URI referencing a content access streaming descriptor as the uri argument SHALL be supported. In such a content access streaming descriptor, all URIs for non-local content (i.e. excluding local PVR and Download) that are supported as the <code>uri</code> argument to the <code>queue()</code> method SHALL be supported in the <code>&lt;contentURL&gt;</code> element.
</ul>
<p>For example, an OITF supporting HTTP streaming and downloaded content but none of local PVR, HTTP adaptive streaming or RTSP streaming will support the following as the uri element;</p><ul>
<li>HTTP URL directly referencing the complete media item (i.e. without a fragment)
<li>HTTP URL directly referencing part of the media item (i.e. with a media time fragment)
<li>HTTP URL referencing a content access streaming descriptor where the <code>&lt;contentURL&gt;</code> element is an HTTP URL referencing the complete media item (i.e. without a fragment)
<li>HTTP URL referencing a content access streaming descriptor where the <code>&lt;contentURL&gt;</code> element is an HTTP URL referencing part of the media item (i.e. with a media time fragment)
<li>Private URI directly identifying a complete downloaded content item (i.e. without a fragment)
<li>Private URI directly referencing part of a downloaded content item (i.e. with a fragment)
</ul>
<p>Further, the OITF SHALL support all combinations of all URIs that can be used as the uri argument with all URIs that can be used as the data property of the object element.</p>

</section>
<section id="implementation-requirements-on-queue">
<h4>Implementation Requirements on the Queue Method</h4>
<p>When the queue method is used, once the last required data of the current content item has been read, the OITF SHALL start reading from the queued content item without waiting for the last required data of the current content item to be decoded and presented. If the current content item was identified by a URL without a fragment or with a fragment not including an end time then the last required data is the last data of the content item. If the current content item was identified by a URL with a fragment including an end time then the last required data is the last data needed to decode and present the frame corresponding to that end time.</p>
</section>

</section>
<section id="av-control-extensions-for-volume-control">
<h3>Extensions to A/V Control object for volume control</h3>
<section id="av-control-volume-control-methods">
<h4>Methods</h4>
<p>The following additional method SHALL be supported on the audio object and video object defined in section 5.7.1 of [[!CEA-2014-A]].</p>
<table class="dae-method-table" id="av-control-getvolume">
<tr><td colspan="2" class="api-signature">Integer <b>getVolume</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1">Returns the actual volume level set; for systems that do not support individual volume control of players, this method will have no effect and will always return 100.</td></tr>
</table>
</section>
</section>

<section id="av-control-extensions-for-resource-management">
<h3>Extensions to A/V Control object for resource management</h3>
<p>This section defines APIs related to resource capabilities allocated to the A/V Control object. </p>
<section id="av-control-resource-management-constants">
<h4>Constants</h4>
<table class="dae-constant-table">
<tr><th>Name</th><th>Value</th><th>Description</th></tr>
<tr><td>STATIC_ALLOCATION</td><td>1</td><td>Scarce resources are allocated at instantiation time</td></tr>
<tr><td>DYNAMIC_ALLOCATION</td><td>2</td><td>Scarce resources are allocated to the object as required</td></tr>
</table>
</section>
<section id="av-control-resource-management-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="av-control-playercapabilities">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>playerCapabilities</b></td></tr>
<tr><td><p>The list of media formats that are supported by the object. Each item SHALL contain a format label according to [[.OIPF_MEDIA2]].</p><p>If scarce resources are not claimed by the object, the value of this property SHALL be <code>null</code>.</p>
</td></tr>
</table>
<table class="dae-property-table" id="av-control-allocationmethod">
<tr><td class="api-signature">readonly Integer <b>allocationMethod</b></td></tr>
<tr><td>Returns the resource allocation method currently in use by the object. Valid values as defined in section <a href="#av-control-resource-management-constants" class="sectionRef"></a> are:<ul>
<li>STATIC_ALLOCATION
<li>DYNAMIC_ALLOCATION</ul></td></tr>
</table>
</section>
</section>
</section>

<section id="miscellaneous-apis">
<h2>Miscellaneous APIs</h2>
<section id="application-oipfmdtf">
<h3>The application/oipfMDTF embedded object</h3>
<p>If an OITF has indicated support for the multicast delivery terminating function (MDTF) (i.e., <code>&lt;mdtf&gt;true&lt;/mdtf&gt;</code>) as defined in section <a href="#MDTF-support" class="sectionRef"></a> in its capability description, the OITF SHALL support MDTF through the use of the following non-visual object:</p><pre class="javascript">
&lt;object type="application/oipfMDTF"/&gt;
</pre>
<p>The MDTF API provides the necessary JavaScript methods to indicate to the MDTF what FLUTE multicast channel it should join, and what tags it should listen for on those channels.</p>
<section id="oipfmdtf-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="oipfmdtf-onfluteresultlistener">
<tr><td class="api-signature">function <b>onFLUTEListenerResult</b>( String multicastAddress, Integer resultMsg )</td></tr>
<tr><td><p>This function is called with return result from the methods <a href="#oipfmdtf-addflutelistener" class="apiRef">addFLUTEListener</a> and <a href="#oipfmdtf-removeflutelistener" class="apiRef">removeFLUTEListener</a>.</p>
<p>The specified script function is called with two arguments &mdash; <code>multicastAddress</code> and <code>resultMsg</code>.<ul>
<li><code>String multicastAddress</code> &mdash; The multicast address associated with the callback.
<li><code>Integer resultMsg</code> &mdash; result message. Valid values include: 
<table class="dae-api-values-table">
<tr><th>Result message</th><th>Description</th><th>Semantics</th></tr>
<tr><td>0</td><td>Successful</td><td>The action performed by the underlying functionality was successful.</td></tr>
<tr><td>1</td><td>Unknown error</td><td>The action performed by the underlying functionality failed because an unspecified error occurred.</td></tr>
<tr><td>2</td><td>Invalid multicast address</td><td>The multicast address is not valid, e.g. bad syntax or out of range.</td></tr>
<tr><td>3</td><td>Multicast address does not exist</td><td>The multicast address does not exist in the listener table.</td></tr>
<tr><td>4</td><td>No resources</td><td>There was not enough resources in the OITF to join the multicast address (only valid for <a href="#oipfmdtf-addflutelistener" class="apiRef">addFLUTEListener()</a>).</td></tr>
</table>
</ul>
</td></tr>
</table>
</section>
<section id="oipfmdtf-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="oipfmdtf-addflutelistener">
<tr><td colspan="3" class="api-signature">void <b>addFLUTEListener</b>( String multicastAddress )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>This method adds a FLUTE channel listener in the OITF.</p>
<p>The result from this method is sent to the callback method <a href="#oipfmdtf-onfluteresultlistener" class="apiRef">onFLUTEListenerResult</a>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">multicastAddress</td><td>The multicast address that the OITF should join in order to listen.</td></tr>
</table>

<table class="dae-method-table" id="oipfmdtf-addflutelistenertags">
<tr><td colspan="3" class="api-signature">void <b>addFLUTEListenerTags</b>( String multicastAddress, String tags, function downloadCallBack  )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>This method adds tags that the FLUTE listener should listen for.</p>
<p>The result from this method is sent to the callback method <a href="#oipfmdtf-onfluteresultlistener" class="apiRef">onFLUTEListenerResult</a>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">multicastAddress</td><td>The multicast address that the OITF should join in order to listen.</td></tr>
<tr><td class="dae-method-table-argument">tags</td><td>A comma separated list of tags that the OITF should listen for on the FLUTE channel.</td></tr>
<tr><td class="dae-method-table-argument">downloadCallback</td><td>Optional. This callback function is called when an object has been downloaded. The arguments to this function are the Content Location URI of the downloaded object and the Content-Type.</td></tr>
</table>

<table class="dae-method-table" id="oipfmdtf-getflutelisteners">
<tr><td colspan="2" class="api-signature"><a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>getFLUTEListeners</b>( )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="1">Returns a collection of multicast addresses for the FLUTE channels that the OITF listens to.</td></tr>
</table>
<table class="dae-method-table" id="oipfmdtf-gettags">
<tr><td colspan="3" class="api-signature">String <b>getTags</b>( String multicastAddress )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Returns a comma-separated list of the tags associated with a particular multicast address.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">multicastAddress</td><td>The multicast address that the OITF should return tags for.</td></tr>
</table>
<table class="dae-method-table" id="oipfmdtf-removeflutelistener">
<tr><td colspan="3" class="api-signature">String <b>removeFLUTEListener</b>( String multicastAddress )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Removes the associated listener.</p>
<p>The result from this method is sent to the callback method <a href="#oipfmdtf-onfluteresultlistener" class="apiRef">onFLUTEListenerResult</a>.</p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">multicastAddress</td><td>The multicast address that the OITF should leave.</td></tr>
</table>


</section>
<section id="oipfmdtf-events">
<h4>Events</h4>
For the intrinsic events listed in the table below, a corresponding DOM event SHALL be generated in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#oipfmdtf-onfluteresultlistener" class="apiRef">onFLUTEListenerResult</a></td><td>FLUTEListenerResult</td><td>Bubbles: No<br />Cancellable: No <br />Context Info: <code>multicastAddress</code>, <code>resultMsg</code></td></tr>
</table>
NOTE: the above DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving a <code>FLUTEListenerResult</code> event during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method on the <code>application/oipfMDTF</code> object. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>

<section id="application-oipfstatusview">
<h3>The application/oipfStatusView embedded object</h3>
<section id="oipfstatusview-overview-of-downloads">
<h4>Overview of download status</h4>
<p>The following embedded objects allow a visualization of the native download manager to be included as part of the UI coming from a (third party) server, without the need for any security model, and without compromising security and privacy.</p>
<p>An OITF SHALL support the <code>application/oipfStatusView</code> embedded object. This is a visual object that can be included in a HTML document, and is subject to the following CSS properties: <code>width</code>, <code>height</code>, <code>position</code>, <code>float</code>, <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code>, <code>vertical-align</code>, <code>padding</code>, and <code>padding-*</code> properties, <code>margin</code>, and <code>margin-*</code> properties, <code>border</code>, and <code>border-*</code> properties, <code>visibility</code>, and <code>display</code>. This embedded object SHALL provide an overall consistent graphical view of the status of the current downloads, the content that has been downloaded, and/or the content that has been recorded, as denoted by the states: </p><ul>
<li>&ldquo;list_of_recent_downloads&rdquo;: shows the progress of the most recently started downloads, with the amount of items shown as specified by a <code>&lt;param&gt;</code> element with the name &ldquo;<code>nritems</code>&rdquo;.
<li>&ldquo;list_of_downloaded_content&rdquo;: shows the list of items that have been successfully downloaded, with the amount of items shown as specified by a <code>&lt;param&gt;</code> element with the name &ldquo;<code>nritems</code>&rdquo;.
</ul>
<p>The object SHALL support a <code>&lt;param&gt;</code> element with the name &ldquo;<code>state</code>&rdquo;, which indicates the state that SHALL be visualized inside the object. An OITF that has indicated support for downloading content in its capability description (i.e. <code>&lt;download&gt;true&lt;/download&gt;</code>) SHALL at least support the monitor states &ldquo;list_of_recent_downloads&rdquo; and &ldquo;list_of_downloaded_content&rdquo;. An OITF MAY support the visualization of additional states. An OITF SHALL silently ignore a request to visualize a state that it does not support; if this results in no state information being visualized at all (because the each <code>&lt;param&gt;</code> element with name state referred to a non-supported state), the <code>application/oipfStatusView</code> object SHALL NOT be visualized and the object will have CSS width and height values of 0.</p>
<p>The object SHALL support a <code>&lt;param&gt;</code> element with the name &ldquo;<code>nritems</code>&rdquo;, which indicates the number of items that should be shown for the given state.</p>
<p>The object SHALL also support the inclusion of style hints through <code>&lt;param&gt;</code> elements. At least the &ldquo;<code>background-color</code>&rdquo; and &ldquo;<code>font-size</code>&rdquo; style hints SHALL be supported using the syntax defined by CSS 2.1. An OITF MAY support additional style hints in addition to &ldquo;<code>background-color</code>&rdquo; and &ldquo;<code>font-size</code>&rdquo;. Additional style hints SHALL also follow the CSS 2.1 syntax.  An OITF SHALL silently ignore any style hints that it does not support.</p>
<p>Next to these parameters, the object SHALL support methods &ldquo;<a href="#statusview-getminimumitemwidth" class="apiRef">getMinimumItemWidth()</a>&rdquo; and &ldquo;<a href="#statusview-getminimumitemheight" class="apiRef">getMinimumItemHeight()</a>&rdquo; as defined in section <a href="#oipfstatusview-overview-of-downloads-methods" class="sectionRef"></a>.</p>
Example usage:<pre class="javascript">
&lt;object id="d1" type="application/oipfStatusView" width="200" height="100"&gt;
    &lt;param name="state" value="list_of_recent_downloads"/&gt;
    &lt;param name="nritems" value="2"/&gt;
    &lt;param name="background-color" value="black"/&gt;
    &lt;param name="font-size" value="16px"/&gt;
&lt;/object&gt; 
</pre>
<p>NOTE: this object is intended to allow services to link in to the privileged functionality of accessing privacy sensitive download information, without the need for certificates and privileged access requests. In certain managed deployments this may not be sufficient. The <a href="#application-oipfdownloadmanager" class="apiRef">application/oipfDownloadManager</a> API described in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> provides more extensive APIs which provide JavaScript control for a service platform provider over such highly privileged functionality.</p>

<section id="oipfstatusview-overview-of-downloads-methods">
<h5>Methods</h5>
<table class="dae-method-table" id="statusview-getminimumitemwidth">
<tr><td colspan="3" class="api-signature">Integer <b>getMinimumItemWidth</b>( String state )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Returns the minimum width needed for rendering the name, status and other data of the downloaded items for the given state (e.g. &ldquo;list_of_recent_downloads&rdquo;).</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">state</td><td>The state for which the visualization is requested. This is one of the strings that are defined for <code>&lt;param&gt;</code> element with the name &ldquo;<code>state</code>&rdquo; (e.g. &ldquo;<code>list_of_recent_downloads</code>&rdquo;).</td></tr>
</table>
<table class="dae-method-table" id="statusview-getminimumitemheight">
<tr><td colspan="3" class="api-signature">Integer <b>getMinimumItemHeight</b>( String state )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2">Returns the minimum height needed for rendering the name, status and other data of the downloaded items for the given state (e.g. &ldquo;list_of_recent_downloads&rdquo;).</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">state</td><td>The state for which the visualization is requested. This is one of the strings that are defined for <code>&lt;param&gt;</code> element with the name &ldquo;<code>state</code>&rdquo; (e.g. &ldquo;<code>list_of_recent_downloads</code>&rdquo;).</td></tr>
</table>
</section>
</section>
<section id="oipfstatusview-overview-of-recordings">
<h4>Overview of recordings</h4>
<p>An OITF that has indicated support for control of its recording functionality by a server (i.e., <code>&lt;record&gt;true&lt;/record&gt;</code>) SHALL support the <code>application/oipfStatusView</code> embedded object defined in section <a href="#oipfstatusview-overview-of-downloads" class="sectionRef"></a>, for which it SHALL at least support the following additional monitor state:</p><ul>
<li>&ldquo;list_of_recorded_content&rdquo;: shows the list of items that have been recorded or that are currently being recorded, with the amount of items shown as specified by <code>&lt;param&gt;</code> element with the name &ldquo;<code>nritems</code>&rdquo;.
</ul>
<p>NOTE: this object is intended to allow services to link in to highly privileged functionality, without the need for certificates and privileged access requests. In certain managed deployments this may not be sufficient. Therefore, section <a href="#application-oipfrecordingscheduler-control-extension" class="sectionRef"></a> defines more extensive APIs which provide JavaScript control for a service platform provider over such highly privileged functionality.</p>
</section>
</section>

<section id="application-oipfcapabilities">
<h3>The application/oipfCapabilities embedded object</h3>
<p>The OITF SHALL support following non-visual embedded object with the mime type &ldquo;<code>application/oipfCapabilities</code>&rdquo;.</p>
<section id="oipfcapabilities-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="oipfcapabilities-xmlcapabilities">
<tr><td class="api-signature">readonly Document <b>xmlCapabilities</b></td></tr>
<tr><td>Returns the OITF's capability description as an XML Document object using the syntax as defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a> without using any namespace definitions.</td></tr>
</table>
<table class="dae-property-table" id="oipfcapabilities-extrasdvideodecodes">
<tr><td class="api-signature">readonly Number <b>extraSDVideoDecodes</b></td></tr>
<tr><td><p>This property holds the number of possible additional decodes for SD video. Depending on the current usage of system resources this value may vary. The value of this property is likely to change if an HD video is started.</p>
<p>Adding an A/V Control object or <code>video/broadcast</code> object may still fail, even if <code>extraSDVideoDecodes</code> is larger than 0. For A/V Control objects, in case of failure the play state for the A/V Control object shall be set to 6 ('<code>error</code>') with a detailed error code of 3 ('<code>insufficient resources</code>'). For <code>video/broadcast</code> objects, in case of failure the play state of the <code>video/broadcast</code> object shall be set to 0 ('<code>unrealized</code>') with a detailed error code of 11 ('<code>insufficient resources</code>').</p></td></tr>
</table>
<table class="dae-property-table" id="oipfcapabilities-extrahdvideodecodes">
<tr><td class="api-signature">readonly Number <b>extraHDVideoDecodes</b></td></tr>
<tr><td><p>This property holds the number of possible additional decodes for HD video. Depending on the current usage of system resources this value may vary. The value of this property is likely to change if an SD video is started.</p>
<p>Adding an A/V Control object or <code>video/broadcast</code> object may still fail, even if <code>extraHDVideoDecodes</code> is larger than 0. For A/V Control objects, in case of failure the play state for the A/V Control object shall be set to 6 ('<code>error</code>') with a detailed error code of 3 ('<code>insufficient resources</code>'). For <code>video/broadcast</code> objects, in case of failure the play state of the <code>video/broadcast</code> object shall be set to 0 ('<code>unrealized</code>') with a detailed error code of 11 ('<code>insufficient resources</code>').</p></td></tr>
</table>
</section>
<section id="oipfcapabilities-methods">
<h4>Methods</h4>
<table class="dae-method-table" id="oipfcapabilities-hascapability">
<tr><td colspan="3" class="api-signature">Boolean <b>hasCapability</b>( String profileName )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Check if the OITF supports the passed capability.</p><p>Returns true if the OITF supports the passed capability, false otherwise. </p></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">profileName</td><td><p>An OIPF base UI profile string or a UI Profile name fragment string as defined in section <a href="#default-ui-profiles" class="sectionRef"></a>.</p><p>Examples of valid profileName: &ldquo;<code>OITF_HD_UIPROF</code>&rdquo; or &ldquo;<code>+PVR</code>&rdquo;.</p></td></tr>
</table>
</section>
</section>

<section id="navigator-class">
<h3>The Navigator class</h3>
The navigator object is defined by the HTML5 specification as referenced by [[.OIPF_WSTVP2]].
</section>

<section id="debug-print-api">
<h3>Debug print API</h3>
<p>The following method is available on the script's global object as defined in the HTML5 specification as referenced by [[.OIPF_WSTVP2]].</p>
<table class="dae-method-table" id="debugprint-debug">
<tr><td colspan="3" class="api-signature">void <b>debug</b>( DOMString arg )</td></tr>
<tr><td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Let the application developer print debug information on the debug output (for example, a console, a serial link or a file). The means to access this debug output is outside the scope of this specification and implementation-dependent.</p>
<p>A line feed character SHALL NOT be inserted automatically at the end of the string by the implementation.</p>
<p>Example:</p><pre class="javascript">
debug("[APP] value = " + value + "\n");
</pre></td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">arg</td><td>String to print on the debug output.</td></tr>
</table>
</section>
</section>

<section id="shared-utility-classes-and-features">
<h2>Shared Utility classes and features</h2>
<section id="base-collections">
<h3>Base collections</h3>
<section id="stringcollection-class">
<h4>The StringCollection class</h4>
<pre>
typedef Collection&lt;String&gt; StringCollection
</pre>
The <code>StringCollection</code> class represents a collection of <code>String</code> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>
<section id="integercollection-class">
<h4>The IntegerCollection class</h4>
<pre>
typedef Collection&lt;Integer&gt; IntegerCollection
</pre>
The <code>IntegerCollection</code> class represents a collection of <code>Integer</code> values. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>
</section>
<section id="programme-class">
<h3>The Programme class</h3>
<p>The <code>Programme</code> class represents an entry in a programme schedule.</p>
<p>Note: as described in the record( Programme programme ) method of the <a href="#application-oipfrecordingscheduler" class="apiRef">application/oipfRecordingScheduler</a> object, only the <code>programmeID</code> property of the programme object is used to determine the programme or series that will be recorded. The other properties are solely used for annotation of the (scheduled) recording with programme metadata. The use of these metadata properties is optional. If such programme metadata is provided, it is retained in the <code>ScheduledRecording</code> object that is returned if the recording of the programme was scheduled successfully.</p>
<section id="programme-constants">
<h4>Constants</h4>
<table class="dae-constant-table">
<tr><th>Name</th><th>Value</th><th>Use</th></tr>
<tr><td>ID_TVA_CRID</td><td>0</td><td>Used in the <a href="#programme-programmeidtype" class="apiRef">programmeIDType</a> property to indicate that the programme is identified by its TV-Anytime CRID (Content Reference Identifier).</td></tr>
<tr><td>ID_DVB_EVENT</td><td>1</td><td>Used in the <a href="#programme-programmeidtype" class="apiRef">programmeIDType</a> property to indicate that the programme is identified by a DVB URL referencing a DVB-SI event as enabled by section 4.1.3 of [[.OIPF_META2]]. OPTIONAL.</td></tr>
<tr><td>ID_TVA_GROUP_CRID</td><td>2</td><td>Used in the <a href="#programme-programmeidtype" class="apiRef">programmeIDType</a> property to indicate that the Programme object represents a group of programmes identified by a TV-Anytime group CRID.</td></tr>
</table>
</section>
<section id="programme-properties">
<h4>Properties</h4>
<table class="dae-property-table" id="programme-name">
<tr><td class="api-signature">String <b>name</b></td></tr>
<tr><td>The short name of the programme, e.g. 'Star Trek: DS9'.</td></tr>
</table>
<table class="dae-property-table" id="programme-longname">
<tr><td class="api-signature">String <b>longName</b></td></tr>
<tr><td>The long name of the programme, e.g. 'Star Trek: Deep Space Nine'. If the long name is not available, this property will be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="programme-description">
<tr><td class="api-signature">String <b>description</b></td></tr>
<tr><td>The description of the programme, e.g. an episode synopsis. If no description is available, this property will be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="programme-longdescription">
<tr><td class="api-signature">String <b>longDescription</b></td></tr>
<tr><td>The long description of the programme. If no description is available, this property will be <code>undefined</code>.</td></tr>
</table>
<table class="dae-property-table" id="programme-starttime">
<tr><td class="api-signature">Integer <b>startTime</b></td></tr>
<tr><td>The start time of the programme, measured in seconds since midnight (GMT) on 1/1/1970.</td></tr>
</table>
<table class="dae-property-table" id="programme-duration">
<tr><td class="api-signature">Integer <b>duration</b></td></tr>
<tr><td>The duration of the programme (in seconds).</td></tr>
</table>
<table class="dae-property-table" id="programme-channelid">
<tr><td class="api-signature">String <b>channelID</b></td></tr>
<tr><td>The identifier of the channel from which the broadcasted content is to be recorded. Specifies either a ccid or ipBroadcastID (as defined by the <a href="#channel-class" class="apiRef">Channel</a> object in section <a href="#channel-class" class="sectionRef"></a>)</td></tr>
</table>
<table class="dae-property-table" id="programme-episode">
<tr><td class="api-signature">Integer <b>episode</b></td></tr>
<tr><td>The episode number for the programme if it is part of a series.  This property is <code>undefined</code> when the programme is not part of a series or the information is not available.</td></tr>
</table>
<table class="dae-property-table" id="programme-totalepisodes">
<tr><td class="api-signature">Integer <b>totalEpisodes</b></td></tr>
<tr><td>If the programme is part of a series, the total number of episodes in the series.  This property is <code>undefined</code> when the programme is not part of a series or the information is not available.</td></tr>
</table>
<table class="dae-property-table" id="programme-is3d">
<tr><td class="api-signature">readonly Boolean <b>is3D</b></td></tr>
<tr><td>Flag indicating whether the programme has 3D video.</td></tr>
</table>
<table class="dae-property-table" id="programme-programmeid">
<tr><td class="api-signature">String <b>programmeID</b></td></tr>
<tr><td>The unique identifier of the programme or series, e.g., a TV-Anytime CRID (Content Reference Identifier).</td></tr>
</table>
<table class="dae-property-table" id="programme-programmeidtype">
<tr><td class="api-signature">Integer <b>programmeIDType</b></td></tr>
<tr><td>The type of identification used to reference the programme, as indicated by one of the ID_* constants defined in section <a href="#programme-constants" class="sectionRef"></a>.</td></tr>
</table>
<table class="dae-property-table"  id="programme-imi">
<tr><td class="api-signature">readonly String <b>IMI</b></td></tr>
<tr><td>The TV-Anytime Instance Metadata ID for this programme.</td></tr>
</table>
<table class="dae-property-table"  id="programme-parentalratings">
<tr><td class="api-signature">readonly <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> <b>parentalRatings</b></td></tr>
<tr><td><p>A collection of parental rating values for the programme for zero or more parental rating schemes supported by the OITF. For instances of the <a href="#programme-class" class="apiRef">Programme</a> class created by the <a href="#oipfrecordingscheduler-createprogrammeobject" class="apiRef">createProgrammeObject()</a> method defined in section <a href="#application-oipfrecordingscheduler-methods" class="sectionRef"></a>, the initial value of this property (upon creation of the <a href="#programme-class" class="apiRef">Programme</a> object) is an instance of the <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> object (as defined in section <a href="#parentalratingcollection-class" class="sectionRef"></a>) with length 0. Parental rating values can be added to this empty readonly parental rating collection by using the addParentalRating() method of the <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> object. The <a href="#parentalratingcollection-class" class="apiRef">ParentalRatingCollection</a> is defined in section <a href="#parentalratingcollection-class" class="sectionRef"></a>. The related ParentalRating and ParentalRatingScheme objects are defined in sections <a href="#parentalrating-class" class="sectionRef"></a> and <a href="#parentalratingscheme-class" class="sectionRef"></a> respectively.</p>
<p>For instances of the <a href="#programme-class" class="apiRef">Programme</a> class returned through the metadata APIs defined in section <a href="#metadata-apis" class="sectionRef"></a> or through the programmes property of the video/broadcast object defined in section <a href="#video-broadcast-extensions-eit-pf" class="sectionRef"></a>, the initial value of this property SHALL include the parental rating value(s) carried in the metadata or DVB-SI entry describing the programme, if this information is included.</p>
<p>Note that if the service provider specifies a certain parental rating (e.g.  PG-13) through this property and the actual parental rating extracted from the stream says that the content is rated PG-16, then the conflict resolution is implementation dependent.</p>
</td></tr>
</table>
<table class="dae-property-table"  id="programme-groupcrids">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>groupCRIDs</b></td></tr>
<tr><td>The group CRIDs associated with this programme.</td></tr>
</table>
</section>
<section id="programme-metadata-extensions">
<h4>Metadata extensions to Programme</h4>
<p>The OITF SHALL extend the Programme class defined in section <a href="#programme-class" class="sectionRef"></a> with the properties and methods described below.</p>
<p>This subsection SHALL apply for OITFs that have indicated <code>&lt;clientMetadata&gt;</code> with value &ldquo;<code>true</code>&rdquo; and a &ldquo;<code>type</code>&rdquo; attribute with values &ldquo;<code>bcg</code>&rdquo;, &ldquo;<code>eit-pf</code>&rdquo; or &ldquo;<code>dvb-si</code>&rdquo; as defined in section <a href="#OITF-metadata-api-support" class="sectionRef"></a> in their capability profile.</p>
<section id="programme-metadata-extensions-properties">
<h5>Properties</h5>
<table class="dae-property-table"  id="programme-channel">
<tr><td class="api-signature">readonly <a href="#channel-class" class="apiRef">Channel</a> <b>channel</b></td></tr>
<tr><td><p>Reference to the broadcast channel where the programme is available.</p>
<p>The value of this field is derived from the <code>serviceIDref</code> attribute of the <code>Schedule</code> element that refers to this programme.</p></td></tr>
</table>
<table class="dae-property-table" id="programme-blocked">
<tr><td class="api-signature">readonly Boolean <b>blocked</b></td></tr>
<tr><td><p>Flag indicating whether the programme is blocked due to parental control settings or conditional access restrictions.</p>
<p>The <code>blocked</code> and <a href="#programme-locked" class="apiRef">locked</a> properties work together to provide a tri-state flag describing the status of a programme.  This can best be described  by the following table:</p>
<table class="dae-api-left-values-table">
<tr><th>Description</th><th>blocked</th><th>locked</th></tr>
<tr><td>No parental control applies.</td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td>Item is above the parental rating threshold (or manually blocked); no PIN has been entered to view it and so the item cannot currently be viewed.</td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td>Item is above the parental rating threshold (or manually blocked); the PIN has been entered and so the item can be viewed.</td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td>Invalid combination &mdash; OITFs SHALL NOT support this combination</td><td><code>false</code></td><td><code>true</code></td></tr>
</table>
</td></tr>
</table>

<table class="dae-property-table"  id="programme-showtype">
<tr><td class="api-signature">Integer <b>showType</b></td></tr>
<tr><td><p>Flag indicating the type of show (live, first run, rerun, etc,). </p>
<p>The value of this property is determined by the child elements of the programme's <code>BroadcastEvent</code> or <code>ScheduleEvent</code> element from the Program Location Table.  Values are determined as follows:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>The programme is live; indicated by the presence of a <code>Live</code> element with a value attribute set to true.</td></tr>
<tr><td>2</td><td>The programme is a first-run show; indicated by the presence of a <code>FirstShowing</code> element with a value attribute set to true.</td></tr>
<tr><td>3</td><td>The programme is a rerun; indicated by the presence of a <code>Repeat</code> element with a value attribute set to true.</td></tr>
</table>
<p>If none of the above conditions are met, the default value of this field SHALL be 2.</p></td></tr>
</table>
<table class="dae-property-table"  id="programme-subtitles">
<tr><td class="api-signature">Boolean <b>subtitles</b></td></tr>
<tr><td><p>Flag indicating whether subtitles or closed-caption information is available.</p>
<p>This flag SHALL be <code>true</code> if one or more BCG <code>CaptionLanguage</code> elements are present in this programme's description, <code>false</code> otherwise.</p></td></tr>
</table>
<table class="dae-property-table"  id="programme-ishd">
<tr><td class="api-signature">Boolean <b>isHD</b></td></tr>
<tr><td><p>Flag indicating whether the programme has high-definition video.</p>
<p>This flag SHALL be <code>true</code> if a <code>VerticalSize</code> element is present in the programme's description and has a value greater than 576, <code>false</code> otherwise.</p></td></tr>
</table>
<table class="dae-property-table" id="programme-audiotype" >
<tr><td class="api-signature">Integer <b>audioType</b></td></tr>
<tr><td><p>Bitfield indicating the type of audio that is available for the programme. </p>
<p>The value of this field is determined by the NumOfChannels elements in a programme's A/V attributes.  Values are determined as follows:</p>
<table class="dae-api-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>1</td><td>A mono audio stream is available (at least one <code>AvAttributes.AudioAttributes</code> element is present which has a child <code>NumOfChannels</code> element whose value is 1).</td></tr>
<tr><td>2</td><td>A stereo audio stream is available (at least one <code>AvAttributes.AudioAttributes</code> element is present which has a child <code>NumOfChannels</code> element whose value is 2).</td></tr>
<tr><td>4</td><td>A multi-channel audio stream is available (at least one <code>AvAttributes.AudioAttributes</code> element is present which has a child <code>NumOfChannels</code> element whose value is greater than 2).</td></tr>
</table>
<p>For programmes with multiple audio streams, these values may be ORed together.</p></td></tr>
</table>
<table class="dae-property-table" id="programme-ismultilingual" >
<tr><td class="api-signature">Boolean <b>isMultilingual</b></td></tr>
<tr><td><p>Flag indicating whether more than one audio language is available for the programme.</p>
<p>This flag SHALL be <code>true</code> if more than one BCG <code>Language</code> element is present in the programme's description, <code>false</code> otherwise.</p></td></tr>
</table>
<table class="dae-property-table"  id="programme-genre">
<tr><td class="api-signature"><a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>genre</b></td></tr>
<tr><td><p>A collection of genres that describe this programme.</p>
<p>The value of this field is the concatenation of the values of any <code>Name</code> elements that are children of <code>Genre</code> elements in the programme's description.</p></td></tr>
</table>
<table class="dae-property-table"  id="programme-hasrecording">
<tr><td class="api-signature">readonly Boolean <b>hasRecording</b></td></tr>
<tr><td>Flag indicating whether the <code>Programme</code> has a recording associated with it (either scheduled, in progress, or completed).</td></tr>
</table>
<table class="dae-property-table"  id="programme-audiolanguages">
<tr><td class="api-signature"><a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>audioLanguages</b></td></tr>
<tr><td>Supported audio languages, indicated by their ISO.639-2 language codes as defined in [[!ISO639-2]].</td></tr>
</table>
<table class="dae-property-table"  id="programme-subtitlelanguages">
<tr><td class="api-signature"><a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>subtitleLanguages</b></td></tr>
<tr><td>Supported subtitle languages, indicated by their ISO.639-2 language codes as defined in [[!ISO639-2]].</td></tr>
</table>
<table class="dae-property-table" id="programme-locked">
<tr><td class="api-signature">readonly Boolean <b>locked</b></td></tr>
<tr><td>Flag indicating whether the current state of the parental control system prevents the programme from being viewed (e.g. a correct parental control PIN has not been entered to allow the programme to be viewed).</td></tr>
</table>
</section>
<section id="programme-metadata-extensions-methods">
<h5>Methods</h5>
<table class="dae-method-table" id="programme-getfield">
<tr><td colspan="3" class="api-signature">String <b>getField</b>( String fieldId )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Get the value of the field referred to by <code>fieldId</code> that is contained in the metadata for this programme.  If the field does not exist, this method SHALL return <code>undefined</code>.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">fieldId</td><td>The name of the field whose value SHALL be retrieved.</td></tr>
</table>
</section>
</section>
<section id="programme-dvb-si-extensions">
<h4>DVB-SI extensions to Programme</h4>
<p>The following method SHALL be added to the <a href="#programme-class" class="apiRef">Programme</a> object, if the OITF has indicated support for accessing DVB-SI information, by giving the value &ldquo;<code>true</code>&rdquo; to element <code>&lt;clientMetadata&gt;</code> and the value &ldquo;<code>dvb-si</code>&rdquo; or &ldquo;<code>eit-pf</code>&rdquo; to the &ldquo;<code>type</code>&rdquo; attribute of that element as defined in section <a href="#OITF-metadata-api-support" class="sectionRef"></a> in their capability profile.</p>

<table class="dae-method-table" id="programme-getsidescriptors">
<tr><td colspan="3" class="api-signature"><a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>getSIDescriptors</b>( Integer descriptorTag, Integer descriptorTagExtension, Integer privateDataSpecifier )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">
<p>Get the contents of the descriptor specified by <code>descriptorTag</code> from the DVB SI EIT programme's descriptor loop. If more than one descriptor with the specified tag is available for the given programme, the contents of all matching descriptors SHALL be returned in the order the descriptors are found in the stream.</p>
<p>The descriptor content bytes SHALL be encoded in a string whose characters shall be restricted to the ISO Latin-1 character set. Each character in the string represents a byte of a DVB-SI descriptor, such that a byte at position "<code>i</code>" in the descriptor is equal the Latin-1 character code of the character at position "<code>i</code>" in the string. </p>
<p>Described in the syntax of JavaScript: let desc[ ] be the byte array of a descriptor, in which desc[0] is the descriptor_tag, then, the returned string (retval in the example below) is its equivalent string, if :</p>
<p>  
  <code>desc.length==retval.length</code>  and<br />
  <code>for each integer i : 0&lt;=i&lt;desc.length</code>    holds<br />
  <code>desc[i] == retval.charCodeAt(i)</code>.</p>
<p>If the descriptor specified by <code>descriptorTag</code> and (optionally) <code>descriptorTagExtension</code> and <code>privateDataSpecifier</code> does not exist, or if the metadata for this programme was retrieved from a source other than DVB-SI, this method SHALL return <code>null</code>.</p>
<p>If metadata for this programme has not yet been retrieved, this method SHALL return <code>undefined</code>. If the OITF supports the <a href="#application-oipfsearchmanager" class="apiRef">application/oipfSearchManager</a> object as defined in section <a href="#application-oipfsearchmanager" class="sectionRef"></a>, the OITF SHALL notify applications of the availability of additional metadata via <code>MetadataSearch</code> events targeted at the <a href="#application-oipfsearchmanager" class="apiRef">application/oipfSearchManager</a> object used to retrieve the programme metadata.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="3">Arguments</td>
<td class="dae-method-table-argument">descriptorTag</td><td>The descriptor tag as specified by [[!EN300468]]. </td></tr>
<tr><td class="dae-method-table-argument">descriptorTagExtension</td><td>An optional argument giving the descriptor tag extension as specified by [[!EN300468]]. This argument is mandatory when descriptorTag is 0x7f and ignored in all other cases.</td></tr>
<tr><td class="dae-method-table-argument">privateDataSpecifier</td><td>An optional argument giving the private_data_specifier as specified by [[!EN300468]]. If this argument is present, only descriptors related to the identified specifier will be returned.</td></tr>
</table>
</section>
<section id="programme-recording-extensions">
<h4>Recording extensions to Programme</h4>
<p>The OITF SHALL support the following extensions to the <a href="#programme-class" class="apiRef">Programme</a> class.</p>
<p>Clients supporting the recording management APIs defined in this section SHALL indicate this by adding the attribute "<code>manageRecordings</code>" to the <code>&lt;recording&gt;</code> element with a value unequal to '<code>none</code>' in the client capability description as defined in section <a href="#pvr-capability" class="sectionRef"></a>.</p>
<p>The functionality as described in this section is subject to the security model of section <a href="#dae-security" class="sectionRef"></a>.</p>
<table class="dae-property-table"  id="programme-recording">
<tr><td class="api-signature">readonly <a href="#scheduledrecording-class" class="apiRef">ScheduledRecording</a> <b>recording</b></td></tr>
<tr><td>If available, this property represents the recording associated with this programme (either scheduled, in-progress or completed). Has value <code>undefined</code> if this programme has no scheduled recording associated with it.</td></tr>
</table>
</section>
</section>
<section id="programmecollection-class">
<h3>The ProgrammeCollection class</h3>
<pre>
typedef Collection&lt;<a href="#programme-class" class="apiRef">Programme</a>&gt; ProgrammeCollection
</pre>
The <code>ProgrammeCollection</code> class represents a collection of <a href="#programme-class" class="apiRef">Programme</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>
<section id="discinfo-class">
<h3>The DiscInfo class</h3>
<p>The <code>DiscInfo</code> class provides details of the storage usage and capacity in the OITF.</p>
<p>A <code>DiscInfo</code> instance obtained from the <a href="#application-oipfdownloadmanager" class="apiRef">oipfDownloadManager</a> provides reports relating to downloads. A <code>DiscInfo</code> instance obtained from <a href="#application-oipfrecordingscheduler" class="apiRef">oipfRecordingScheduler</a> provides reports relating to recordings. If recordings and downloads use the same pool of storage space (e.g. disc partition), <code>DiscInfo</code> instances obtained via either route would have the same values for the properties. If recordings and downloads use different pools of storage space (e.g. different disc partitions) the <code>DiscInfo</code> instances obtained by each route would report the correct values for the route in which they were obtained.
<section id="discinfo-properties">
<h4>Properties</h4>
<table class="dae-property-table" >
<tr><td class="api-signature">readonly Integer <b>free</b></td></tr>
<tr><td>The space (in megabytes) available on the storage device.</td></tr>
</table>
<table class="dae-property-table" >
<tr><td class="api-signature">readonly Integer <b>total</b></td></tr>
<tr><td>The total capacity (in megabytes) of the storage device. Depending upon the system, <code>free</code> MAY be less than <code>total</code> as some of the disc space MAY be used for management purposes.</td></tr>
</table>
<table class="dae-property-table" >
<tr><td class="api-signature">readonly Integer <b>reserved</b></td></tr>
<tr><td>The space (in megabytes) reserved.</td></tr>
</table>
</section>
</section>
<section id="extensions-for-playback-of-selected-media-components">
<h3>Extensions for playback of selected media components</h3>
<p>This section defines APIs for the selection of specific A/V components for playback. </p>
<p>NOTE: The term component may correspond to MPEG_2 components, but is not restricted to that.</p>
<section id="media-playback-extensions">
<h4>Media playback extensions</h4>
<section id="media-playback-extensions-constants">
<h5>Constants</h5>
<p>The following constants are defined as properties on any objects implementing this section:</p>
<table class="dae-constant-table">
<tr><th>Name</th><th>Value</th><th>Use</th></tr>
<tr><td>COMPONENT_TYPE_VIDEO</td><td>0</td><td>Represents a video component.  This constant is used for all video components regardless of encoding.</td></tr>
<tr><td>COMPONENT_TYPE_AUDIO</td><td>1</td><td>Represents an audio component.  This constant is used for all audio components regardless of encoding.</td></tr>
<tr><td>COMPONENT_TYPE_SUBTITLE </td><td>2</td><td>Represents a subtitle component.  This constant is used for all subtitle components regardless of subtitle format. NOTE: A subtitle component may also be related to closed captioning as part of a video stream.</td></tr>
</table>
</section>
<section id="media-playback-extensions-properties">
<h5>Properties</h5>
<table class="dae-property-table" id="onselectedcomponentchanged">
<tr><td class="api-signature">function <b>onSelectedComponentChanged</b>( Integer componentType )</td></tr>
<tr><td>
<p>This function is called when there is a change in the set of components being presented. This may occur if one of the currently selected components is no longer available and an alternative is chosen based on user preferences, or when presentation has changed due to a different component or set of components being selected.</p>
<p>OITFs MAY optimise event dispatch by dispatching a single event in response to several calls to <code>selectComponent()</code> or <code>unselectComponent()</code> made in rapid succession.</p>
<p>The specified function is called with one argument:</p><ul>
<li><code>Integer componentType</code> - The type of component whose presentation has changed, as represented by one of the constant values listed in section <a href="#media-playback-extensions-constants" class="sectionRef"></a>. If more than one component type has changed, this argument will take the value <code>undefined</code>.
</ul></td></tr>
</table>
</section>
<section id="media-playback-extensions-methods">
<h5>Methods</h5>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature"><a href="#avcomponentcollection-class" class="apiRef">AVComponentCollection</a> <b>getComponents</b>( Integer componentType )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>If the set of components is known, returns a collection of <code>AVComponent</code> values representing the components of the specified type in the current stream. If <code>componentType</code> is set to <code>null</code> or <code>undefined</code> then all components are returned if they are known.</p>
<p>For a video/broadcast object, the set of components SHALL be known if the video/broadcast object is in the presenting state and MAY be known if the object is in other states. For an A/V Control object, the set of components SHALL be known if the A/V Control object is in the playing state and MAY be known if the object is in other states.</p>
<p>NOTE: In the case of broadcast MPEG-2 transport streams, this method returns in formation from the PMT but the PMT is not always accurate. Components may be signalled in the PMT which are not actually present all the time. Components may be present but carrying information inconsistent with the PMT, for example a secondary audio stream may be signalled but carrying a copy of the primary audio stream when content for the secondary audio has not been produced. Applications can use the <a href="#programme-getsidescriptors" class="apiRef">getSIDescriptors()</a> method defined in section <a href="#programme-dvb-si-extensions" class="sectionRef"></a> to obtain descriptors from the EIT where these subtleties are normally signalled. Exactly how they are &ldquo;normally signalled&rdquo; is generally market specific.</p>
<p>One or more of the components returned MAY be passed back to one of the other methods unchanged (e.g. <code>selectComponent()</code>). </p>
<p>If property <a href="#configuration-preferredaudiolanguage" class="apiRef">preferredAudioLanguage</a> in the <a href="#configuration-class" class="apiRef">Configuration</a> object (refer to section <a href="#configuration-class" class="sectionRef"></a>) is set then a component is by default selected and is considered as an active component.</p>
<p>If property <a href="#configuration-preferredsubtitlelanguage" class="apiRef">preferredSubtitleLanguage</a> in the <a href="#configuration-class" class="apiRef">Configuration</a> object (refer to section <a href="#configuration-class" class="sectionRef"></a>) is set and property <a href="#avoutput-subtitleenabled" class="apiRef">subtitleEnabled</a> in <a href="#avoutput-class" class="apiRef">AVOutput</a> class (refer to section <a href="#avoutput-properties" class="sectionRef"></a>) is enabled then a component is by default selected and is considered as an active component.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">componentType</td><td>The type of component to be returned, as represented by one of the constant values listed in section <a href="#media-playback-extensions-constants" class="sectionRef"></a>.</td></tr>
</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature"><a href="#avcomponentcollection-class" class="apiRef">AVComponentCollection</a> <b>getCurrentActiveComponents</b>( Integer componentType )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>If the set of components is known, returns a collection of <code>AVComponent</code> values representing the currently active components of the specified type that are being rendered. Otherwise returns <code>undefined</code>.</p>
<p>For a video/broadcast object, the set of components SHALL be known if the video/broadcast object is in the presenting state and MAY be known if the object is in other states. For an A/V Control object, the set of components SHALL be known if the A/V Control object is in the playing state and MAY be known if the object is in other states.</p>
<p>One or more of the components returned MAY be passed back to one of the other methods unchanged (e.g. <code>selectComponent()</code>). </p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">componentType</td><td>The type of component to be returned, represented by one of the constant values listed in section <a href="#media-playback-extensions-constants" class="sectionRef"></a>.</td></tr>
</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">void <b>selectComponent</b>( <a href="#avcomponent-class" class="apiRef">AVComponent</a> component )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Select the component that will be subsequently rendered when A/V playback starts or select the component for rendering if A/V playback has already started.</p>  
<p>If playback has started, this SHALL replace any other components of the same type that are currently playing.</p>
<p>If property <a href="#configuration-preferredaudiolanguage" class="apiRef">preferredAudioLanguage</a> in the <a href="#configuration-class" class="apiRef">Configuration</a> object (refer to section <a href="#configuration-class" class="sectionRef"></a>) is set then a component is by default selected and is considered as an active component.</p>
<p>If property <a href="#configuration-preferredsubtitlelanguage" class="apiRef">preferredSubtitleLanguage</a> in the <a href="#configuration-class" class="apiRef">Configuration</a> object (refer to section <a href="#configuration-class" class="sectionRef"></a>) is set and property <a href="#avoutput-subtitleenabled" class="apiRef">subtitleEnabled</a> in <a href="#avoutput-class" class="apiRef">AVOutput</a> class (refer to section <a href="#avoutput-properties" class="sectionRef"></a>) is enabled then a component is by default selected and is considered as an active component.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">component</td><td>A component object available in the stream currently being played.</td></tr>
</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">void <b>unselectComponent</b>( <a href="#avcomponent-class" class="apiRef">AVComponent</a> component )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Stop rendering of the specified component of the stream.</p>  
<p>If property <a href="#configuration-preferredaudiolanguage" class="apiRef">preferredAudioLanguage</a> in the <a href="#configuration-class" class="apiRef">Configuration</a> object (see section <a href="#configuration-class" class="sectionRef"></a>) is set then unselecting a specific component returns to the default preferred audio language.</p>
<p>If property <a href="#configuration-preferredsubtitlelanguage" class="apiRef">preferredSubtitleLanguage</a> in the <a href="#configuration-class" class="apiRef">Configuration</a> object (refer to section <a href="#configuration-class" class="sectionRef"></a>) is set and property <a href="#avoutput-subtitleenabled" class="apiRef">subtitleEnabled</a> in <a href="#avoutput-class" class="apiRef">AVOutput</a> class (see section <a href="#avoutput-properties" class="sectionRef"></a>) is enabled unselecting a specific component returns to the default preferred subtitle language. In order to stop rendering subtitles completely it is necessary to disable subtitles with property <a href="#avoutput-subtitleenabled" class="apiRef">subtitleEnabled</a> in <a href="#avoutput-class" class="apiRef">AVOutput</a> class.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">component</td><td>A component object available in the stream currently being played.</td></tr>
</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">void <b>selectComponent</b>( Integer componentType )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>If A/V playback has already started, start rendering the default component of the specified type in the current stream.  This SHALL replace any other components of the same type that are currently playing.</p>
<p>If A/V playback has not started, the default component of the specified type will be subsequently rendered once playback does start.</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">componentType</td><td>The type of component for which the default component should be rendered.</td></tr>
</table>

<table class="dae-method-table">
<tr><td colspan="3" class="api-signature">void <b>unselectComponent</b>( Integer componentType )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">If A/V playback has already started, stop rendering of the specified type of component.  If A/V playback has not started, no components of the specified type will be subsequently rendered once playback does start.</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">componentType</td><td>The type of component to  be stopped.</td></tr>
</table>
</section>
<section id="media-playback-extensions-events">
<h5>Events</h5>
For the intrinsic event &ldquo;onSelectedComponentChange&rdquo;, corresponding DOM events SHALL be generated, in the following manner:
<table class="dae-event-table">
<tr><th>Intrinsic event</th><th>Corresponding DOM event</th><th>DOM Event properties</th></tr>
<tr><td><a href="#onselectedcomponentchanged" class="apiRef">onSelectedComponentChange</a></td><td>SelectedComponentChange</td><td>Bubbles: No<br />Cancellable: No<br />Context Info: <code>componentType</code></td></tr>
</table>
Note: this DOM event is directly dispatched to the event target, and will not bubble nor capture. Applications SHOULD NOT rely on receiving these events during the bubbling or the capturing phase. Applications that use DOM event handlers SHALL call the <code>addEventListener()</code> method  on the <code>video/broadcast</code> object or AV Control object  itself. The third parameter of <code>addEventListener</code>, i.e. &ldquo;<code>useCapture</code>&rdquo;, will be ignored.
</section>
</section>
<section id="avcomponent-class">
<h4>The AVComponent class</h4>
<p><code>AVComponent</code> represents a component within a complete media stream - a single stream of video, audio or data that can be played or manipulated. This is not necessary for basic playback, record or EPG services. However, it provides a mechanism to get at extended streams for enhanced services.</p>
<p>For forward compatibility the DAE application SHALL check the value of the type property to ensure that it is accessing an <code>AVComponent</code> object of the correct type.</p>
<section id="avcomponent-properties">
<h5>Properties</h5>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>componentTag</b></td></tr>
<tr><td>The component tag identifies a component. The component tag identifier corresponds to the component_tag in the component descriptor in the ES loop of the stream in the PMT [[!EN300468]], or <code>undefined</code> if the component is not carried in an MPEG-2 TS.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>pid</b></td></tr>
<tr><td>The MPEG Program ID (PID) of the component in the MPEG2-TS in which it is carried, or <code>undefined</code> if the component is not carried in an MPEG-2 TS.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>type</b></td></tr>
<tr><td>Type of the component stream. Valid values for this field are given by the constants listed in section <a href="#media-playback-extensions-constants" class="sectionRef"></a>.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>encoding</b></td></tr>
<tr><td>The encoding of the stream. The value of video format or audio format defined in <a href="volume2.html#media-section" class="extRef">section 3</a> of [[.OIPF_MEDIA2]] SHALL be used. For subtitle components, the following values are used (all according to <a href="volume2.html#subtitle-section" class="extRef">section 6</a> of [[.OIPF_MEDIA2]]):
<table class="dae-api-left-values-table">
<tr><th>Value</th><th>Description</th></tr>
<tr><td>DVB-SUBT</td><td>DVB subtitles</td></tr>
<tr><td>EBU-SUBT</td><td>EBU Teletext based subtitles</td></tr>
<tr><td>CEA-SUBT</td><td>CEA-708C Closed Captions</td></tr>
<tr><td>3GPP-TT</td><td>3GPP Timed Text</td></tr>
</table>
</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>encrypted</b></td></tr>
<tr><td>Flag indicating whether the component is encrypted or not.</td></tr>
</table>
</section>
</section>
<section id="avvideocomponent-class">
<h4>The AVVideoComponent class</h4>
<p>The <code>AVVideoComponent</code> class implements the <a href="#avcomponent-class" class="apiRef">AVComponent</a> interface.</p>
<section id="avvideocomponent-properties">
<h5>Properties</h5>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Number <b>aspectRatio</b></td></tr>
<tr><td>Indicates the aspect ratio of the video or undefined if the aspect ratio is not known. Values SHALL be equal to width divided by height, rounded to a float value with two decimals, e.g. 1.78 to indicate 16:9 and 1.33 to indicate 4:3.</td></tr>
</table>
</section>
</section>
<section id="avaudiocomponent-class">
<h4>The AVAudioComponent class</h4>
<p>The <code>AVAudioComponent</code> class implements the <a href="#avcomponent-class" class="apiRef">AVComponent</a> interface.</p>
<section id="avaudiocomponent-properties">
<h5>Properties</h5>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>language</b></td></tr>
<tr><td>An ISO 639-2 language code representing the language of the stream, as defined in [[!ISO639-2]].</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>audioDescription</b></td></tr>
<tr><td>Has value <code>true</code> if the stream contains an audio description intended for people with a visual impairment, <code>false</code> otherwise.</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>audioChannels</b></td></tr>
<tr><td>Indicates the number of channels present in this stream (e.g. 2 for stereo, 5 for 5.1, 7 for 7.1).</td></tr>
</table>
</section>
</section>
<section id="avsubtitlecomponent-class">
<h4>The AVSubtitleComponent class</h4>
<p>The <code>AVSubtitleComponent</code> class implements the <a href="#avcomponent-class" class="apiRef">AVComponent</a> interface.</p>
<section id="avsubtitlecomponent-properties">
<h5>Properties</h5>
<table class="dae-property-table">
<tr><td class="api-signature">readonly String <b>language</b></td></tr>
<tr><td>An ISO 639-2 language code representing the language of the stream, as defined in [[!ISO639-2]].</td></tr>
</table>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Boolean <b>hearingImpaired</b></td></tr>
<tr><td>Has value <code>true</code> if the stream is intended for the hearing-impaired (e.g. contains a written description of the sound effects), <code>false</code> otherwise.</td></tr>
</table>
</section></section>
<section id="avcomponentcollection-class">
<h4>The AVComponentCollection class</h4>
<pre>
typedef Collection&lt;<a href="#avcomponent-class" class="apiRef">AVComponent</a>&gt; AVComponentCollection
</pre>
An <code>AVComponentCollection</code> represents a collection of <a href="#avcomponent-class" class="apiRef">AVComponent</a> objects. See Annex <a href="#collections" class="sectionRef"></a> for the definition of the collection template.
</section>
</section>
<section id="additional-support-for-protected-content">
<h3>Additional support for protected content</h3>
<p>The existing <a href="#download-class" class="apiRef">Download</a> and <a href="#recording-class" class="apiRef">Recording</a> classes shall both be extended with two properties <a href="#isencrypted" class="apiRef">isEncrypted</a> and <a href="#drmsystemids" class="apiRef">DRMSystemIds</a> and one method <a href="#getdrmprivatedata" class="apiRef">getDRMPrivateData</a> as follows.</p>

<table class="dae-property-table" id="isencrypted">
<tr><td class="api-signature">readonly Boolean <b>isEncrypted</b></td></tr>
<tr><td>Has value true if the content is protected by a DRM. or undefined if this information is not available to the OITF. The mapping for different content formats is described in section <a href="#programme-scheduled-recording-recording-and-download" class="sectionRef"></a>.</td></tr>
</table>
<table class="dae-property-table" id="drmsystemids">
<tr><td class="api-signature">readonly <a href="#stringcollection-class" class="apiRef">StringCollection</a> <b>DRMSystemIds</b></td></tr>
<tr><td><a href="#stringcollection-class" class="apiRef">StringCollection</a> object containing the names of the DRM system ID of the DRM protecting the content. OIPF <code>DRMSystemID</code> are defined in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. The collection is empty if this information is not available to the OITF. The mapping for different content formats is described in section <a href="#programme-scheduled-recording-recording-and-download" class="sectionRef"></a>.</td></tr>
</table>

<table class="dae-method-table" id="getdrmprivatedata">
<tr><td colspan="3" class="api-signature">String <b>getDRMPrivateData</b>( String DRMSystemID )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2"><p>Gets the private opaque data in the protected content in the scope of the specified DRM system. </p>
<p>The function returns the private data of the protected content in the scope of the DRM system. The function returns <code>undefined</code> if this information is not available to the OITF or if the content is not protected by the specified DRM. The mapping for different content formats is described in section <a href="#programme-scheduled-recording-recording-and-download" class="sectionRef"></a>. The private data bytes SHALL be encoded in a string whose characters shall be restricted to the ISO Latin-1 character set. Each character in the string represents a byte of the private data, such that a byte at position "i" in the private data is equal the Latin-1 character code of the character at position "i" in the string</p>
</td></tr>
<tr><td class="dae-method-table-label" rowspan="1">Arguments</td>
<td class="dae-method-table-argument">DRMSystemID</td><td>DRM system ID as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]].</td></tr>
</table>

</section>
</section>

<section id="dlna-rui-remote-control-function-apis">
<h2>DLNA RUI Remote Control Function APIs</h2>
</section>

</section>   <!-- end of section 7 -->

<!-- section 8 -->
<section id='dae-system-integration-aspects'>
<h1>System Integration Aspects</h1>
<section id="http-protocol">
<h2>HTTP Protocol</h2>
<p>In addition to what is required by section 5.3 of [[!CEA-2014-A]] an OITF SHALL apply the following requirements.</p>
<section id="http-user-agent-header">
<h3>HTTP User-Agent header</h3>
<p>All DAE application HTTP requests SHALL include a <code>User-Agent</code> header using the syntax described in this section. Embedded objects HTTP requests MAY include a <code>User-Agent</code> header using this syntax.</p>
<p>The <code>User-Agent</code> header SHALL include:</p>
<p style="margin-left: 1em"><code class="wrap">OIPF-&lt;oipfProfile&gt;/&lt;releaseVersion&gt;.&lt;majorVersion&gt;.&lt;minorVersion&gt; (&lt;capabilities&gt;; [&lt;vendorName&gt;]; [&lt;modelName&gt;]; [&lt;softwareVersion&gt;]; [&lt;hardwareVersion&gt;]; [&lt;familyName&gt;]; &lt;reserved&gt;) [&lt;appName&gt;[/&lt;appVersion&gt;]]</code></p>
<p>Where</p><ul>
<li>the <code>&lt;capabilities&gt;</code> field consists of a description of the OITFs capabilities. Valid values include:<ul>
<li>a base profile string concatenated with one or more optional Profile name fragment strings, such as the base UI profile strings and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo;.
<li>the <code>&lt;oipfProfile&gt;</code> field identifies the profile implemented by the OITF as defined in the specification of the <code>oipfProfile</code> property of the <code>LocalSystem</code> class  (in section <a href="#localsystem-class" class="sectionRef"></a> &ldquo;<a href="#localsystem-class" class="sectionTitleRef"></a>&rdquo;).
<li>the <code>&lt;releaseVersion&gt;</code>, <code>&lt;majorVersion&gt;</code> and <code>&lt;minorVersion&gt;</code> fields identify the version of the specification implemented by the OITF as defined in section <a href="#localsystem-class" class="sectionRef"></a> &ldquo;<a href="#localsystem-class" class="sectionTitleRef"></a>&rdquo; with properties of the same name.</ul>
<li>the <code>&lt;vendorName&gt;</code>, <code>&lt;modelName&gt;</code>, <code>&lt;familyName&gt;</code>, <code>&lt;softwareVersion&gt;</code> and <code>&lt;hardwareVersion&gt;</code> fields are the same as the one defined in section <a href="#application-oipfremotemanagement" class="sectionRef"></a> &ldquo;<a href="#application-oipfremotemanagement" class="sectionTitleRef"></a>&rdquo; and are optional.
<li>the <code>&lt;reserved&gt;</code> field is reserved for future extensions
<li>the <code>&lt;appName&gt;</code> and <code>&lt;appVersion&gt;</code> fields are defined in the <code>window.navigator</code> object and are optional.
</ul>
<p>This <code>User-Agent</code> header MAY be extended with other implementation-specific information.</p>
<p>Valid examples of such syntax are:</p><pre>
User-Agent: OIPF-OIP/2.3.0 (OITF_HD_UIPROF+PVR+DL; Sonic; TV44; 1.32.455; 2.002; com.acme.2012;) Bee/3.5
User-Agent: OIPF-BMP/2.3.0 (OITF_HD_UIPROF+PVR+DL;;;;;;)
</pre>
</section>
<section id="http-oitf-rcf-user-agent-header">
<h3>HTTP X-OITF-RCF-User-Agent header</h3>
<p>When the DAE application or embedded object (&ldquo;<code>application/oipfRemoteControlFunction</code>&rdquo;) makes a HTTP request for the Control UI to the IPTV Applications server, the value of the <code>X-OITF-RCF-User-Agent</code> header SHALL be filled with the value of the <code>User-Agent</code> header provided by the DAE application (and which came from the DLNA RUIC on the Remote Control Device).</p>
</section>
</section>
<section id="mapping-from-apis-to-protocols">
<h2>Mapping from APIs to Protocols</h2>
<p>This section describes mapping of DAE APIs to the specific protocol entities as defined in the protocol specification [[!OIPF_PROT2]].</p>
<p>Section <a href="#content-download-over-http" class="sectionRef"></a> describes mappings that apply to CoD download over HTTP.</p>
<p>Section <a href="#cod-unicast-streaming-with-sip-session-management" class="sectionRef"></a> describes mappings that apply to CoD unicast streaming with SIP session management.</p>
<p>Section <a href="#scheduled-content-multicast-streaming-with-sip-session-management" class="sectionRef"></a> describes mappings that apply to Multicast Streaming of Scheduled Content with SIP session management.</p>
<p>Section <a href="#communication-services-with-sip-session-management" class="sectionRef"></a> describes mappings that apply to Communication Services with SIP session management.</p>
<p>Section <a href="#cod-unicast-streaming-over-rtp-and-http" class="sectionRef"></a> describes mappings that apply to CoD unicast streaming over RTP and HTTP.</p>
<p>Section <a href="#scheduled-content-multicast-streaming" class="sectionRef"></a> describes mappings that apply to Scheduled Content Multicast Streaming.</p>
<p>This section provides details of mapping of the DAE APIs to the descriptions provided in the Protocol specification for APIs between the OITF and the Network over reference points UNIT-17.</p>
<section id="content-download-over-http">
<h3>Content Download Over HTTP</h3>
<p>This section provides details of mapping of the DAE APIs to the descriptions provided in the Protocol specification for APIs between the OITF and the Network over reference points UNIT-17 for download over HTTP.</p>
<table class="simple">
<thead><tr><th>Method</th><th>Procedures</th></tr></thead>
<tr>
<td><code class="wrap"><b>registerDownload</b>( String contentAccessDownloadDescriptor, Date downloadStart, Integer priority )</code></td>
<td>API described in section <a href="#downloadtrigger-methods" class="sectionRef"></a> to download content described in the contentAccessDownloadDescriptor. Data structure of the contentAccessDownloadDescriptor as described in Annex <a href="#content-access-download-descriptor-format" class="sectionRef"></a> &ldquo;<a href="#content-access-download-descriptor-format" class="sectionTitleRef"></a>&rdquo;<br />
If the OITF includes the Content Download functional entity ,the information in the contentAccessDescriptor is passed to the Content Download functional entity to download content over UNIT-17 using HTTP as described in <a href="volume4.html#s5-3-4-1" class="extRef">section 5.3.4.1</a> of [[.OIPF_PROT2]] and section <a href="#download-protocols" class="sectionRef"></a> &ldquo;<a href="#download-protocols" class="sectionTitleRef"></a>&rdquo;.</td>
</tr>
<tr>
<td><code class="wrap"><b>registerDownload</b>( String URL, String contentType, Date downloadStart, Integer priority )</code></td>
<td>API described in section <a href="#downloadtrigger-methods" class="sectionRef"></a> to download the content identified by the given URL.<br />
If the OITF includes the Content Download functional entity, the URL is passed to the Content Download functional entity to download content over UNIT-17 using HTTP as described in <a href="volume4.html#s5-3-4-1" class="extRef">section 5.3.4.1</a> of [[.OIPF_PROT2]]<br />
As specified in section <a href="#downloadtrigger-methods" class="sectionRef"></a>, the contentType attribute can be used to evaluate if the content type is part of the list of accepted content types of the OITF. <br />
If contentType has value &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo;, the method SHALL return a download identifier, after which the OITF SHALL immediately fetch the Content Access Download Descriptor, after which the same SHALL happen as if <a href="#downloadtrigger-registerdownload" class="apiRef">registerDownload()</a> had been called.
</td>
</tr>
<tr>
<td><code class="wrap"><b>registerDownloadFromCRID</b>( String CRID, String IMI, Date downloadStart, Integer priority )</code></td>
<td>API described in section <a href="#extensions-to-application-oipfdownloadtrigger" class="sectionRef"></a> to download content described in a BCG record.<br />
If the OITF includes the Content Download functional entity, &lt;CRID,IMI&gt; BCG tuple is resolved to an URL as described in <a href="volume3.html#crid-location-resolution" class="extRef">section 4.3</a> of [[.OIPF_META2]] and passed to the Content Download functional entity to download content over UNIT-17 using HTTP as described in <a href="volume4.html#s5-3-4-1" class="extRef">section 5.3.4.1</a> of [[.OIPF_PROT2]].</td>
</tr>
</table>
</section>
<section id="cod-unicast-streaming-with-sip-session-management">
<h3>CoD Unicast Streaming with SIP Session Management</h3>
<p>This section provides details of mapping of the DAE APIs to the descriptions provided in the Protocol specification [[.OIPF_PROT2]] for APIs between the OITF and the Network over reference points HNI-IGI, UNIS-11 and UNIT-17U for CoD Unicast Streaming with SIP session management.</p>
<table class="simple">
<thead><tr><th>Methods</th><th>Procedures</th></tr></thead>
<tr>
<td><code><b>play</b>( Number speed )</code></td>
<td>Selection of a content item results in session initiation and access to content stream.<br />
Parameters needed to build the offer SDP may be pre defined locally in the OITF or the OITF SHALL request the IG to retrieve missing SDP parameters as described in [[.OIPF_PROT2]] <a href="volume4.html#s5-3-2-2" class="extRef">section 5.3.2.2</a>.<br />
If the OITF does not have all transport parameters (RTP or UDP transport for MPEG2TS encapsulation or direct RTP, FEC layers addresses and ports), code information or bandwidth information to populate the SDP the OITF SHALL prompt  the IG to send OPTIONS request in order to retrieve the missing parameters.<br />
The OITF SHALL provide the following information for the OPTIONS request. Not all required headers are listed. Refer to the Protocol specification [[.OIPF_PROT2]] for a complete list.
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the content identifier as described by the data property. e.g.<br /><code>OPTION sip:PSI-Twister@IPTV_Service_Control.orange.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF CurrentUser property. e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>Copied from the data property. e.g.<br /><code>OPTION sip:PSI-Twister@IPTV_Service_Control.orange.com</code></td></tr>
</table>
The response to the OPTIONS message request contains the information to populate the SDP offer. <br />
The OITF prepares an SDP offer and requests the IG to initiate a session, in addition to the SDP the following parameters are forwarded from the OITF to the IG. Not all required headers are listed. Refer to the Protocol specification [[.OIPF_PROT2]] for a complete list.
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the content identifier as described by the data property. e.g.<br /><code>INVITE sip:PSI-Twister@IPTV_Service_Control.orange.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF CurrentUser property. e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>Copied from the data property. e.g.<br /><code>sip:PSI-Twister@IPTV_Service_Control.orange.com</code></td></tr>
</table>
After a successful session setup the OITF SHALL use the media player to access the RTSP URI with the session ID negotiated and received as part of the SDP offer, described in [[.OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>.<br />
The OITF SHALL send an RTSP PLAY over UNIS-11 using attribute values received in the SDP from the session initiation procedure. The RTSP PLAY is as described in the [[.OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>.<br />
The RTSP fields in the RTSP PLAY message SHALL be filled as follows:<ul>
<li>The RTSP URL SHALL be set from the SDP h-uri attribute in the case of an absolute URI. The &ldquo;data&rdquo; property SHALL be updated with the SDP h-uri attribute. If the value of h-uri is a relative URI that is in the form of a media path, then the RTSP absolute URL is constructed by the OITF  using the SDP IPAddress (from c-line) and port (from m-line) as the base followed by h-uri value for the media path.<br />
(e.g. <code>rtsp://10.5.1.72:22554/TV3/823527</code>)
<li>The RTSP Scale header SHALL be set to the value specified in argument speed in method play. The argument SHOULD equal one of the values in the playSpeeds property. The Scale values [[!RTSP]] <a href="http://tools.ietf.org/html/rfc2326#section-12.34" class="extRef">section 12.34</a> are as follows:<ul>
<li>1 indicates normal play.
<li>If not 1, the value corresponds to the rate with respect to normal viewing rate.
<li>A negative value indicates reverse direction.
</ul></ul>
If the speed argument of method play does not equal a supported play speed indicated by the playSpeeds property, the player SHALL play the content at the closest available playback speed. The play() method SHOULD only return false if the best effort to play back the file at any speed has failed.<br />
The actual playback speed SHALL be available through the speed property of the A/V Control object.<br />
After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a PlaySpeedChanged event indicating the actual playback speed.
</td>
</tr>
<tr>
<td><code><b>stop</b>()</code></td>
<td>The method enables the OITF to terminate and ongoing CoD session. The OITF SHALL request the IG to terminate the session as described in [[.OIPF_PROT2]] <a href="volume4.html#s5-3-2-2" class="extRef">section 5.3.2.2</a>.<br>
The OITF SHALL include the following information from the request. Not all required headers are listed. Refer to the Protocol specification [[.OIPF_PROT2]] for a complete list.
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the content identifier as described by the data property. e.g.<br /><code>BYE sip:PSI-Twister@IPTV_Service_Control.orange.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF CurrentUser property. e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>Copied from the data property. e.g.<br /><code>sip:PSI-Twister@IPTV_Service_Control.orange.com</code></td></tr>
</table>
The OITF SHALL remove all context information relevant to the terminated COD session upon a successful response from the IG.
</td>
</tr>
<tr>
<td><code class="wrap"><b>seek</b>( Integer pos )</code></td>
<td>If the seek() method is called while the player is in the &ldquo;playing&rdquo; state, it sets current play position to &ldquo;pos&rdquo;, by using the &ldquo;Range&rdquo; parameter in the RTSP PLAY as described in [[.OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>.<br />After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a PlayPositionChanged event indicating a new playback position of &ldquo;pos&rdquo;.<br />If the <code>seek()</code> method is called while the player is in the &ldquo;paused&rdquo; state, the value of <code>playPosition</code> is changed to reflect the new play position. This is the new play position that SHALL be used for the &ldquo;Range&rdquo; parameter of the RTSP PLAY message when playback is resumed.
</td>
</tr>
<tr>
<td><code class="wrap"><b>play</b>(0)</code></td>
<td>This method causes the OITF to send an RTSP PAUSE message (refer to [[.OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>). The RTSP PAUSE message SHALL include:<ul>
<li>The RTSP URL SHALL be set to the value retrieved from the <code>fmtp:iptv_rtsp h-uri</code> attribute of the SDP answer.
<li>Session header SHALL be set as specified in the SDP answer <code>fmtp:iptv_rtsp h-session</code> attribute</ul>
After a successful response to the RTSP PAUSE message has been received, the OITF SHALL generate a PlaySpeedChanged event indicating a playback speed of 0.
</td>
</tr>
<tr>
<td><code class="wrap"><b>next</b>()</code></td>
<td>Not Supported. <br />NOTE: Track information is not supported in the protocol specification and therefore out of scope.
</td>
</tr>
<tr>
<td><code class="wrap"><b>previous</b>()</code></td>
<td>Not Supported. <br />NOTE: Track information is not supported in the protocol specification and therefore out of scope.
</td>
</tr>
<tr>
<td><code class="wrap">read/write String <b>data</b></code></td>
<td>This property holds the URL that identifies the content, as defined in section <a href="#unicast-streaming" class="sectionRef"></a>. See [[!OIPF_PROT2]] <a href="volume4.html#s6-1-2-2-1-1" class="extRef">section 6.1.2.2.1.1</a> for details on CoD URI.<br />
It is used by the OITF compose the following headers for requests towards the IG<br />
<code>X-OITF-Request-Line </code><br /><code>X-OITF-To</code><br />
If the &ldquo;<code>data</code>&rdquo; property of the A/V Control object refers to a Content-Access Streaming Descriptor (i.e. the object has type &ldquo;<code>application/vnd.oipf.ContentAccessStreaming+xml</code>&rdquo; as  defined in section <a href="#av-control-extensions-for-playback-through-casd" class="sectionRef"></a>), the OITF must perform the following steps prior to performing the procedures defined in [[.OIPF_PROT2]] as described for method <code>play()</code>: <ul>
<li>An HTTP GET request SHALL be made with the Request-URI set to the URL of the Content-Access Descriptor as denoted by the &ldquo;data&rdquo; property of the A/V Control object.
<li>After the server has returned a Content Access Streaming Descriptor (i.e. a document with type &ldquo;<code>application/vnd.oipf.ContentAccessStreaming+xml</code>&rdquo;), the OITF SHALL interpret the contents of the Content-Access Descriptor and choose a URL defined by one of the <code>&lt;ContentURL&gt;</code> elements. The criteria for choosing a URL can be the DRM system supported by the OITF. The URL SHALL then be used for setting up a Streaming CoD session, after which playback can be started (when the <code>play()</code> method is invoked). The &ldquo;<code>data</code>&rdquo; property of the A/V Control object SHALL be changed to represent the chosen URL. 
<li>Based on the information retrieved from the Content-Access Streaming Descriptor, the OITF SHALL passing the <code>&lt;DRMControlInformation&gt;</code> to the appropriate DRM agent, and SHOULD initialize the AV playback, i.e. by loading the correct codecs as identified by the Content-access Streaming Descriptor.</ul></td>
</tr>
<tr>
<td><code class="wrap">readonly Number <b>playPosition</b></code></td>
<td>The property holds the current play position in milliseconds of the media referenced by the data property. The property value SHALL be based on the value retrieved using the RTSP GET_PARAMETERS method and parameter &ldquo;position&rdquo; (refer to [[.OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>) adjusted for played duration and used scale. <br />If information is not available the value SHALL be undefined. Note this may happen at the beginning of playing a video and GET_PARAMETER has not returned a value.
</td>
</tr>
<tr>
<td><code class="wrap">readonly Number <b>playSpeeds</b>[ ]</code></td>
<td>The property holds the available speeds, or referred in RTSP as Scale, to be used to change the playback speed. The property value SHALL be based on the value retrieved using RTSP GET_PARAMETERS method and parameter &ldquo;scales&rdquo; (refer to [[.OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>).<br />
If information is not available the value SHALL be undefined. Note this may happen at the beginning of playing a video and GET_PARAMETER has not returned a value.</td>
</tr>
<tr>
<td><code class="wrap">readonly Number <b>playTime</b></code></td>
<td>The property holds the total duration in milliseconds of the media referenced by the data property. The property value SHALL be based on the value retrieved using RTSP GET_PARAMETER method and parameter &ldquo;duration&rdquo; (refer to [[.OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>).<br />If information is not available the value SHALL be undefined. Note this may happen at the beginning of playing a video and GET_PARAMETER has not returned a value.</td>
</tr>
<tr>
<td><code class="wrap">readonly Number <b>playState</b></code></td>
<td>No procedures defined since it is not related to protocol specification.</td>
</tr>
<tr>
<td><code class="wrap">readonly Number <b>error</b></code></td>
<td>No procedures defined since it is not related to protocol specification.</td>
</tr>
<tr>
<td><code class="wrap">readonly Number <b>speed</b></code></td>
<td>Float value indicating the actual playback speed for the content referenced by the data property. The normal default playback speed is represented by value 1.</td>
</tr>
</table>
<p> </p>
<table class="simple">
<thead><tr><th>Intrinsic Event</th><th>Procedure</th></tr></thead>
<tr><td><code>onPlaySpeedChanged</code></td><td>When RTSP ANNOUNCE with either beginning-of-stream or end-of-stream codes arrives the OITF SHALL generate <code>onPlaySpeedChanged</code> event with a speed value of 0.</td></tr>
<tr><td><code>onPlayPositionChanged</code></td><td>When the response to the RTSP PLAY with Range header request (Range is included when performing seek() with a position) the OITF SHALL generate <code>onPlayPositionChanged</code> event with the accepted position.</td></tr>
</table>
</section>

<section id="scheduled-content-multicast-streaming-with-sip-session-management">
<h3>Scheduled Content Multicast Streaming with SIP Session Management</h3>
<p>This section provides details of mapping of the DAE APIs to the descriptions provided in the Protocol specification [[.OIPF_PROT2]] for APIs between the OITF and the Network over reference points HNI-IGI, UNIS-11, UNIS-13 and UNIT-17 for Scheduled Content multicast streaming with SIP session management.</p>
<section id="s8-2-3-1">
<h4>Conveyance of channel list</h4>
Service discovery description procedure as described in [[!OIPF_PROT2]] <a href="volume4.html#s6-1-3-1" class="extRef">section 6.1.3.1</a> enables the OITF to obtain the URL to access the broadcast channel information. The OITF SHALL utilise UNIS-7 using this URL to obtain the Broadcast Discovery Record.
</section>
<section id="s8-2-3-2">
<h4>Switching channels</h4>
<table class="simple">
<thead><tr><th>Methods</th><th>Procedures</th></tr></thead>
<tr>
<td><code class="wrap"><b>setChannel</b>(Channel channel, Boolean trickplay, String contentAccessDescriptorURL)</code></td>
<td>
<p>The setChannel() method of the video/broadcast object SHALL be used to initiate a broadcast session or switch channels. The procedures that are performed over the HNI-IGI reference point depend on the current state of broadcast session, either it is active or not. Note that an inactive broadcast session means no service is being viewed.</p>
<p>If the channel is an IMS based IPTV service (i.e., if it is of type ID_IPTV_SDS and if the corresponding service has a &ldquo;sip-igmp-rtp-udp&rdquo; or &ldquo;sip-igmp-udp&rdquo; file format specified in its SD&amp;S BDR record), the following steps are taken:</p>
<p><b>Session Initiation</b></p>
<p>The OITF SHALL generate a session initiation request over the HNI-IGI including and SDP offer as described in [[!OIPF_PROT2]] <a href="volume4.html#s5-3-1" class="extRef">section 5.3.1</a>. The bandwidth is set according to the explanation under heading &ldquo;Selection of Bandwidth&rdquo; below.</p>
<p>If a &ldquo;contentAccessDescriptorURL&rdquo; has been specified for the setChannel() method, the OITF must perform the following steps prior to performing the procedures defined in [[!OIPF_PROT2]] for performing setChannel() as described below: </p><ul>
<li>An HTTP GET request SHALL be made with the Request-URI set to the URL of the Content-Access Descriptor as denoted by the &ldquo;contentAccessDescriptor&rdquo; attribute.
<li>Based on the information retrieved from the Content-Access Descriptor, the OITF SHALL passing the &lt;DRMControlInformation&gt; to the appropriate DRM agent.
</ul>
<p>The OITF SHALL provide the following information as part of the scheduled session initiation request as described in [[!OIPF_PROT2]] <a href="volume4.html#s6-2-2-1" class="extRef">section 6.2.2.1</a>. Not all required headers are listed. Refer to the Protocol specification [[!OIPF_PROT2]] for a complete list.</p>
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the well known PSI (Public Service Identifier) of the scheduled content. e.g.<br /><code>INVITE sip:IPTV_SC_Service@iptv.ericsson.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF CurrentUser property. e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>PSI of the scheduled content. e.g.<br /><code>sip:IPTV_SC_Service@iptv.ericsson.com</code></td></tr>
</table>
<p>The Offer SDP included in the OITF be SHALL have attributes as described in [[!OIPF_PROT2]] <a href="volume4.html#annex-d-2" class="extRef">Annex D.2</a>.</p>
<p>On positive response to the INVITE request the OITF SHALL send an IGMP Join request on the UNIS-13 as described in [[!OIPF_PROT2]] <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.</p>
<p><b>Session Modification</b></p>
<p>If the bandwidth conditions change as described under heading &ldquo;Selection of Bandwidth&rdquo; further down then the OITF SHALL generates a session modification request over the HNI-IGI including the new SDP offer.</p>
<p>The OITF SHALL provide the following information as part of the scheduled session modification request as described in [[!OIPF_PROT2]] <a href="volume4.html#s6-2-2-1" class="extRef">section 6.2.2.1</a>. Not all required headers are listed. Refer to the Protocol specification [[!OIPF_PROT2]] for a complete list.</p>
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the well known PSI (Public Service Identifier) of the scheduled content. e.g.<br /><code>INVITE sip:IptvBroadcast@iptv.ericsson.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF CurrentUser property. e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>PSI of the scheduled content. e.g.<br /><code>sip:IptvBroadcast@iptv.ericsson.com</code></td></tr>
</table>
<p>The Offer SDP included by the OITF SHALL have attributes as relevant to the new channel as described in [[!OIPF_PROT2]] <a href="volume4.html#annex-d-2" class="extRef">Annex D.2</a>.</p>
<p>On receiving a successful response to the INVITE request the OITF SHALL send and IGMP Leave and IGMP Join request on the UNIS-13 as described in [[!OIPF_PROT2]] <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.</p>
<p><b>No Session Modification</b></p>
<p>If the bandwidth conditions as described under heading &ldquo;Selection of Bandwidth&rdquo; further down have not changed then the OITF SHALL send a membership report to leave the previously viewed channel, if applicable, and with the same membership report join to the multicast group associated with the selected channel. The multicast group information is retrieved from the Broadcast Discovery Record.</p>
<p><b>Selection of Bandwidth</b></p>
<p>The bandwidth to be used for the broadcast session depends on the information provided in the Broadcast Discovery Record (refer to <a href="volume3.html#bandwidth-renegotiation" class="extRef">section 3.2.2.1</a> of [[!OIPF_META2]] The Broadcast Discovery Record uses the term &ldquo;service&rdquo; to indicate a channel.</p>
<p>If the TimeToRenegotiate (TTR) element is not provided within the IPService of the Broadcast Discovery Record then the bandwidth SHALL be based on the maximum bandwidth for all the services in the Broadcast Discovery Record. In this case only one session initiation is performed at initial activation of broadcast service, and no session modification is required.</p>
<p>If the TTR element is provided then the MaxBitrate from the new service and current service are compared. If broadcast service is not active and there is no active current service, session initiation is performed with the new service MaxBitrate. For already active broadcast service there are three conditions.</p><ul>
<li>If the MaxBitrate of the new service is greater than that of the current service and the reserved bandwidth is exceeded, network bandwidth reservation using the MaxBitrate of the new service SHALL occur immediately with session modification to ensure sufficient bandwidth is made available for the new service.
<li>If the MaxBitrate of the new service is equal to that of the current service, network bandwidth reservation procedures SHALL NOT be performed as sufficient bandwidth is already available for the new service.
<li>If the MaxBitrate of the new service is less than that of the current service and there is no pending TTR timer, a timer using the TTR element of the new service is started which will renegotiate the bandwidth with session modification.</ul>
<p>Note that at every channel change if there is a pending timeout for session modification due to a previous service change then the timer is restarted. When the timer expires the bandwidth for the currently viewed service is used in a session modification.</p>
<p>The session initiation, session modification and no session modification are further described above.</p>
</td>
</tr>
</table>
</section>
<section>
<h4>End broadcast service</h4>
<table class="simple">
<thead><tr><th>Methods</th><th>Procedures</th></tr></thead>
<tr>
<td><code class="wrap"><b>release</b>()</code></td>
<td>
<p>The release method of the video/broadcast object causes the OITF to perform an IGMP Leave on the active broadcast session as described in [[!OIPF_PROT2]] <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.</p>
<p>If the channel has an idType of ID_IPTV_SDS, the OITF SHALL then execute a session termination procedure by sending a BYE request over the HNI-IGI interface as described in section [[!OIPF_PROT2]] <a href="volume4.html#s5-3-1-1" class="extRef">section 5.3.1.1</a>. The request SHALL include the following information. Not all required headers are listed. Refer to the Protocol specification [[!OIPF_PROT2]] for a complete list.</p>
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the well known PSI (Public Service Identifier) of the scheduled content. e.g.<br /><code>INVITE sip:IPTV_SC_Service@iptv.ericsson.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF <b><code>CurrentUser</code></b> property. e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>PSI of the scheduled content. e.g.<br /><code>sip:IPTV_SC_Service@iptv.ericsson.com</code></td></tr>
</table>
</td></tr>
</table>
</section>
<section id="network-timeshift-of-broadcast-services">
<h4>Network timeshift of broadcast service</h4>
<table class="simple">
<thead><tr><th>Methods</th><th>Procedures</th></tr></thead>
<tr>
<td><code class="wrap"><b>pause</b>()</code></td>
<td><p>The method has different behaviour if the pause() method has previously been invoked. While the first pause() request sets up the session over HNI-IGI the subsequent pause() requests simply issue an RTSP PAUSE request.</p>
<p><b>First pause() request</b></p>
<p>The OITF SHALL generates a session modification request over the HNI-IGI including the modified SDP offer. The SDP offer included by the OITF SHALL have attributes as relevant to the unicast stream to be setup.</p>
<p>The OITF SHALL provide the following information as part of the scheduled session modification request as described in [[!OIPF_PROT2]] <a href="volume4.html#s6-2-2-1" class="extRef">section 6.2.2.1</a>. Not all required headers are listed. Refer to the Protocol specification [[!OIPF_PROT2]] for a complete list.</p>
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the well-known PSI (Public Service Identifier) of the scheduled content, e.g.<br /><code>INVITE sip:IptvBroadcast@iptv.ericsson.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF CurrentUser property, e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>PSI of the scheduled content. e.g.<br /><code>sip:IptvBroadcast@iptv.ericsson.com</code></td></tr>
</table>
<p>On receiving a successful response to the INVITE request and if the channel has an idType of ID_IPTV_URI, the OITF SHALL send and IGMP Leave and request on the UNIS-13 as described in [[!OIPF_PROT2]] <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.</p>
<p><b>Subsequent pause() requests </b></p>
<p>This request causes the OITF to send an RTSP PAUSE message (refer to [[!OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>). The RTSP PAUSE message SHALL include:</p><ul> 
<li>The RTSP URL SHALL be set to the value retrieved from the fmtp:iptv_rtsp h-uri attribute of the SDP answer. 
<li>Session header SHALL be set as specified in the SDP answer fmtp:iptv_rtsp h-session attribute</ul>
<p>After a successful response to the RTSP PAUSE message has been received, the OITF SHALL generate a PlaySpeedChanged event indicating a playback speed of 0.</p>
</td></tr>
<tr>
<td><code class="wrap"><b>resume</b>()</code></td>
<td><p>The OITF SHALL send an RTSP PLAY over UNIS-11 using attribute values received in the SDP from the session modification procedure. The RTSP PLAY is as described in [[!OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>.<p>
<p>The RTSP fields in the RTSP PLAY message SHALL be filled as follows:</p><ul>
<li>The RTSP URL SHALL be set from the SDP h-uri attribute in the case of an absolute URI. The data property SHALL be updated with the SDP h-uri attribute. If the value of h-uri is a relative URI that is in the form of a media path, then the RTSP absolute URL is constructed by the OITF  using the SDP IPAddress (from c-line) and port (from m-line) as the base followed by h-uri value for the media path. (e.g. <code>rtsp://10.5.1.72:22554/TV3/823527</code>)
<li>The RTSP URL SHALL be set from the SDP h-uri attribute in the case of an absolute URI. The data property SHALL be updated with the SDP h-uri attribute. If the value of h-uri is a relative URI that is in the form of a media path, then the RTSP absolute URL is constructed by the OITF  using the SDP IPAddress (from c-line) and port (from m-line) as the base followed by h-uri value for the media path.(e.g. <code>rtsp://10.5.1.72:22554/TV3/823527</code>)
</ul>
<p>After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a PlaySpeedChanged event indicating the actual playback speed.</p>
</td></tr>
<tr>
<td><code class="wrap"><b>setSpeed</b>(Number speed)</code></td>
<td><p>Sets current speed by using the &ldquo;Scale&rdquo; header in the RTSP PLAY as described in [[!OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>.</p>
<p>After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a PlaySpeedChanged event indicating a new playback speed.</p>
</td></tr>
<tr>
<td><code class="wrap"><b>seek</b>( Integer offset, Integer reference )</code></td>
<td><p>Sets current play position based on the specified offset from the given reference point, by using the &ldquo;Range&rdquo; parameter in the RTSP PLAY as described in [[!OIPF_PROT2]] <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>.</p>
<p>After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a PlayPositionChanged event indicating the new playback position.</p></td></tr>
<tr>
<td><code class="wrap"><b>stopTimeShift</b>()</code></td>
<td>
<p>The OITF SHALL generate a session modification request over the HNI-IGI including the modified SDP offer. The SDP offer included by the OITF SHALL have attributes as relevant to the channel as described in [[!OIPF_PROT2]] <a href="volume4.html#annex-d-2" class="extRef">Annex D.2</a>.</p>
<p>The OITF SHALL provide the following information as part of the scheduled session modification request as described in [[!OIPF_PROT2]] <a href="volume4.html#s6-2-2-1" class="extRef">section 6.2.2.1</a>. Not all required headers are listed. Refer to the Protocol specification [[!OIPF_PROT2]] for a complete list.</p>
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the well-known PSI (Public Service Identifier) of the scheduled content,  e.g.<br /><code>INVITE sip:IptvBroadcast@iptv.ericsson.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF CurrentUser property, e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>PSI of the scheduled content. e.g.<br /><code>sip:IptvBroadcast@iptv.ericsson.com</code></td></tr>
</table>
<p>On receiving a successful response to the INVITE request and if the channel has an idType of ID_IPTV_URI, the OITF SHALL send and IGMP Join and request on the UNIS-13 as described in [[!OIPF_PROT2]] <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.</p>
</td></tr>
<tr>
<td><code class="wrap"><b>setChannel</b>(Channel channel, Boolean trickplay, String contentAccessDescriptorURL)</code></td>
<td>
<p>The following procedure is only applicable if Network Timeshift of broadcast service is in progress.
The OITF SHALL generates a session modification request over the HNI-IGI including the modified SDP offer. The SDP offer included by the OITF SHALL have attributes as relevant to the new channel as described in [[!OIPF_PROT2]] <a href="volume4.html#annex-d-2" class="extRef">Annex D.2</a>.</p>
<p>The OITF SHALL provide the following information as part of the scheduled session modification request as described in [[!OIPF_PROT2]] <a href="volume4.html#s6-2-2-1" class="extRef">section 6.2.2.1</a>. Not all required headers are listed. Refer to the Protocol specification [[!OIPF_PROT2]] for a complete list. </p>
<table class="simple">
<tr><td><code>X-OITF-Request-Line</code></td><td>Identify the HNI-IGI method with the well-known PSI (Public Service Identifier) of the scheduled content,  e.g.<br /><code>INVITE sip:IptvBroadcast@iptv.ericsson.com SIP/2.0</code></td></tr>
<tr><td><code>X-OITF-From</code></td><td>Local defined OITF CurrentUser property, e.g.<br /><code>&lt;sip:family@ims.live.ericsson.com&gt;; tag=1211455936632545012</code></td></tr>
<tr><td><code>X-OITF-To</code></td><td>PSI of the scheduled content. e.g.<br /><code>sip:IptvBroadcast@iptv.ericsson.com</code></td></tr>
</table>
<p>On receiving a successful response to the INVITE request and if the channel has an idType of ID_IPTV_URI, the OITF SHALL send and IGMP Join and request on the UNIS-13 as described in [[!OIPF_PROT2]] <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.</p>
</td></tr>
<tr>
<td><code class="wrap">String <b>data</b></code></td>
<td>This property holds the RTSP URI from the SDP h-uri attribute. Prior to a successful SIP INVITE the value is undefined.
</td></tr>
</table>
<p>Note that all the remaining properties listed under section <a href="#cod-unicast-streaming-with-sip-session-management" class="sectionRef"></a>, <a href="#cod-unicast-streaming-with-sip-session-management" class="sectionTitleRef"></a>, SHALL be supported as described.</p>
</section>
</section>

<section id="communication-services-with-sip-session-management">
<h3>Communication Services with SIP Session Management</h3>
<table class="simple">
<thead><tr><th>Methods</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap"><b>registerUser</b>(String userId, String pin)</code></td>
<td>Performs registration with the specified user ID as described in [[!OIPF_PROT2]] <a href="volume4.html#s5-4-6-1" class="extRef">section 5.4.6.1</a>.</td></tr>
<tr><td><code class="wrap"><b>deRegisterUser</b>(String userId)</code></td>
<td>Performs de-registration with the specified user ID as described in [[!OIPF_PROT2]] <a href="volume4.html#s5-4-6-1" class="extRef">section 5.4.6.1</a>.</td></tr>
<tr><td><code class="wrap"><b>subscribeNotification</b>(FeatureTagCollection featureTagCollection, Boolean performUserRegistration)</code></td>
<td>OITF maintains applications that have subscribed to notifications. If applicable it will send a re-registration to the IG. When new messages arrive at the IG it shall notify the OITF (as defined in [[!OIPF_PROT2]] <a href="volume4.html#s5-5-1-2" class="extRef">section 5.5.1.2</a>).</td></tr>
<tr><td><code class="wrap"><b>unsubscribeNotification</b>()</code></td>
<td>This is a local call within OITF to notify that the DAE application SHALL NOT receive unsolicited notification. The OITF shall use native code to handle new dialogues. Any feature tag values that were added by the DAE application are removed for the indicated userId since no native code is setup to process the new dialogues for the feature tag values.</td></tr>
</table>
</section>
<section id="cod-unicast-streaming-over-rtp-and-http">
<h3>CoD Unicast Streaming over RTP and HTTP</h3>
<section>
<h4>General</h4>
<p>This section provides details of mapping of the DAE APIs to the descriptions provided in the Protocol specification [[!OIPF_PROT2]] for APIs between the OITF and the Network over reference points UNIS-11 and UNIT-17 for CoD unicast streaming over RTP and HTTP.</p>
<table class="simple">
<thead><tr><th>Methods</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap"><b>play</b>(Number speed)</code></td>
<td>
<p>The &ldquo;<code>speed</code>&rdquo; parameter is a floating point value indicating the requested playback speed. A value of 1 represents normal playback speed, and other values are relative to this.</p>
<p>A &ldquo;<code>speed</code>&rdquo; value of zero SHALL NOT initiate any procedures.</p>
<p style="text-align: center;"><b>RTSP-RTP</b></p>
<p>The RTSP URL signalled by the &ldquo;data&rdquo; attribute SHALL be used to initiate the process defined in [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-1-1" class="extRef">section 7.1.1.1.1</a>. The &ldquo;data&rdquo; attribute SHALL furthermore be updated with the new URI after redirection requests (moved). The RTSP PLAY request SHALL include a &ldquo;<code>Scale</code>&rdquo; header set to the value of the &ldquo;speed&rdquo; parameter passed to the API. The server will play the stream at the specified speed, if supported.</p>
<p>If property <code>oitfNoRTSPSessionControl</code> is set to <code>true</code> then the RTSP messages DESCRIBE and SETUP are not used. If the <code>play()</code> method is called with a non-zero speed the property <code>oitfRTSPSessionId</code> is copied to the RTSP SessionId header for the RTSP PLAY request. If the <code>oitfRTSPSessionId</code> is undefined the play() method SHALL fail.</p>
<p>After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a <code>PlaySpeedChanged</code> event indicating the actual playback speed.</p>
<p style="text-align: center;"><b>HTTP</b></p>
<p>The HTTP URL signalling by the &ldquo;data&rdquo; attribute SHALL be used to initiate the process defined in [[!OIPF_PROT2]]  <a href="volume4.html#s5-3-2-2" class="extRef">section 5.3.2.2</a>. The &ldquo;data&rdquo; attribute SHALL furthermore be updated with the new URI after redirection requests (moved). The &ldquo;<code>speed</code>&rdquo; parameter SHALL be passed to the OITF media player, which SHOULD attempt to play back the content at the requested speed.</p>
<p>If the media player successfully begins to play back the content, the OITF SHALL generate a <code>PlaySpeedChanged</code> event indicating the actual playback speed.</p>

</td></tr>
<tr><td><code class="wrap"><b>stop</b>()</code></td>
<td>
<p style="text-align: center;"><b>RTSP-RTP</b></p>
<p>The OITF SHALL initiate the process defined in [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-1-2" class="extRef">section 7.1.1.1.2</a> except if the property <code>oitfNoRTSPSessionControl</code> is set to true.</p>
<p style="text-align: center;"><b>HTTP</b></p>
<p>The OITF SHALL stop playback. The OITF MAY close the connection to the server and MAY clear any buffered content.</p>
</td></tr>
<tr><td><code class="wrap"><b>seek</b>(Integer pos)</code></td>
<td>
<p style="text-align: center;"><b>RTSP-RTP</b></p>
<p>If the <code>seek()</code> method is called while the player is in the &ldquo;playing state&rdquo;, it sets current play position to &ldquo;pos&rdquo;, by using the &ldquo;<code>Range</code>&rdquo; parameter in the RTSP PLAY as described in [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-1" class="extRef">section 7.1.1.1</a>.</p>
<p>After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a <code>PlayPositionChanged</code> event indicating a new playback position of &ldquo;pos&rdquo;.</p>
<p>If the <code>seek()</code> method is called while the player is in the &ldquo;paused&rdquo; state, the value of  <code>playPosition</code> is changed to reflect the new play position. This is the new play position that SHALL be used for the &ldquo;Range&rdquo; parameter of the RTSP PLAY message when playback is resumed.
</p>
<p style="text-align: center;"><b>HTTP</b></p>
<p>If the <code>seek()</code> method is called while the player is in the &ldquo;playing state&rdquo;, the OITF SHALL attempt to playback from the specified position &ldquo;<code>pos</code>&rdquo;. It MAY use the RANGE header as described in [[!OIPF_PROT2]]  <a href="volume4.html#s5-3-2-2" class="extRef">section 5.3.2.2</a> as necessary.</p>
<p>If the media player successfully begins to play back the content from the specified position, the OITF SHALL generate a <code>PlayPositionChanged</code> event indicating a new playback position of &ldquo;<code>pos</code>&rdquo;.</p>
<p>If the <code>seek()</code> method is called while the player is in the &ldquo;paused&rdquo; state, the value of <code>playPosition</code> is changed to reflect the new play position. This is the new play position from which playback SHALL be resumed.&rdquo;.</p>
</td></tr>
<tr><td><code class="wrap"><b>play</b>(0)</code></td>
<td>
<p style="text-align: center;"><b>RTSP-RTP</b></p>
<p>This method causes the OITF to send an RTSP PAUSE message (refer to [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>). The RTSP PAUSE message SHALL include:</p>
<p>After a successful response to the RTSP PAUSE message has been received, the OITF SHALL generate a PlaySpeedChanged event indicating a play speed of 0.</p>
<p style="text-align: center;"><b>HTTP</b></p>
<p>The OITF SHALL pause playback.</p>
<p>If the media player successfully pauses playback, the OITF SHALL generate a play speed event indicating a PlaySpeedChanged of 0.</p>
</td></tr>
<tr><td><code class="wrap"><b>next</b>()</code></td>
<td>Not Supported. Note: Track information is not supported in the protocol specification and therefore out of scope.
</td></tr>
<tr><td><code class="wrap"><b>previous</b>()</code></td>
<td>Not Supported. Note: Track information is not supported in the protocol specification and therefore out of scope.
</td></tr>
</table>
<p> </p>
<table class="simple">
<thead><tr><th>Property</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap">read/write String <b>data</b></code></td>
<td>
<p style="text-align: center;"><b>RTSP-RTP</b></p>
<p>This property holds the RTSP URI for the content item.</p>
<p style="text-align: center;"><b>HTTP</b></p>
<p>The property holds the HTTP URI for the content item.</p>
<p>If the &ldquo;data&rdquo; property of the A/V Control object refers to a Content-Access Streaming Descriptor (i.e. the object has type &ldquo;application/vnd.oipf.ContentAccessStreaming+xml&rdquo; as defined in section <a href="#av-control-extensions-for-playback-through-casd" class="sectionRef"></a>), the OITF must perform the following steps prior to performing the procedures defined in [[!OIPF_PROT2]] as described for method play(): </p><ul>
<li>An HTTP GET request SHALL be made with the Request-URI set to the URL of the Content-Access Streaming Descriptor as denoted by the &ldquo;<code>data</code>&rdquo; property of the A/V Control object.
<li>After the server has returned a Content Access Streaming Descriptor (i.e. a document with type &ldquo;<code>application/vnd.oipf.ContentAccessStreaming+xml</code>&rdquo;), the OITF SHALL interpret the contents of the Content-Access Streaming Descriptor and choose a URL defined by one of the &lt;ContentURL&gt; elements. The criteria for choosing a URL can be the DRM system supported by the OITF. The URL SHALL then be used for setting up a Streaming CoD session, after which playback can be started (when the <code>play()</code> method is invoked). The &ldquo;<code>data</code>&rdquo; property of the AV object SHALL be changed to represent the chosen URL. 
<li>Based on the information retrieved from the Content-Access Streaming Descriptor, the OITF SHALL passing the &lt;DRMControlInformation&gt; to the appropriate DRM agent, and SHOULD initialize the AV playback, i.e. by loading the correct codecs as identified by the Content-access Streaming Descriptor.
</ul>
</td></tr>
<tr><td><code class="wrap">readonly Number <b>playPosition</b></code></td>
<td><p>The property holds the current play position in milliseconds of the media referenced by the <code>data</code> property. </p>
<p>For RTSP-RTP, The property value SHALL be based on the value retrieved using the RTSP GET PARAMETERS method and parameter &ldquo;<code>position</code>&rdquo; (refer to [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>) adjusted for played duration and used scale. </p>
<p>If information is not available the value SHALL be <code>undefined</code>. Note this may happen at the beginning of playing a video and GET_PARAMETER has not returned a value.</p>
</td></tr>
<tr><td><code class="wrap">readonly Number <b>playSpeeds</b>[ ]</code></td>
<td><p>For RTSP-RTP, the property holds the available speeds, or referred in RTSP as Scale, to be used to change the playback speed. The property value SHALL be based on the value retrieved using RTSP GET PARAMETERS method and parameter &ldquo;<code>scales</code>&rdquo; (refer to [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>).</p>
<p>For HTTP, the possible playback speeds are determined by the OITF internal capabilities and buffering model, and the speed at which content is delivered. The OITF MAY make this information available via this property.</p>
<p>If information is not available the value SHALL be <code>undefined</code>. Note this may happen at the beginning of playing a video and GET_PARAMETER has not returned a value.</p>
</td></tr>
<tr><td><code class="wrap">readonly Number <b>playTime</b></code></td>
<td>
<p>The property holds the total duration in milliseconds of the media referenced by the data property. </p>
<p>For RTSP-RTP, the property value SHALL be based on the value retrieved using RTSP GET_PARAMETER method and parameter &ldquo;<code>duration</code>&rdquo; (refer to [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-2" class="extRef">section 7.1.1.2</a>).</p>
<p>For HTTP, if the data property references a content-access streaming descriptor that includes the optional &ldquo;Duration&rdquo; attribute then the property value SHALL be derived from the value encoded in that attribute.</p>
<p>Otherwise, if the data property references an MPEG DASH MPD and the <code>@mediaPresentationDuration</code> attribute is present then the property value SHALL be derived from the value encoded in that attribute.</p>
<p>Otherwise, if the  data property references a file in the MP4 file format (as defined in  <a href="volume2.html#system-mp4-file-format" class="extRef">section 4.2</a> of [[.OIPF_MEDIA2]]) then</p><ul> 
<li>If that file is fragmented, the property value SHALL be derived from the value indicated in the <code>fragment_duration</code> of the 'mehd' box if that box is present
<li>If that file is not fragmented, the property value SHALL be derived from the value indicated in the duration of the 'mvhd' box. Otherwise the property value MAY be determined using the &ldquo;<code>Content-Length</code>&rdquo; HTTP header, although it is noted that this method does not work for variable bit rate content.</ul>
<p>If information is not available the value SHALL be <code>undefined</code>. Note this may happen at the beginning of playing a video and GET_PARAMETER has not returned a value.</p>
</td></tr>
<tr><td><code class="wrap">readonly Number <b>playState</b></code></td>
<td>No procedures defined since it is not related to protocol specification.
</td></tr>
<tr><td><code class="wrap">readonly Number <b>error</b></code></td>
<td>No procedures defined since it is not related to protocol specification.
</td></tr>
<tr><td><code class="wrap">readonly Number <b>speed</b></code></td>
<td>Float value indicating the actual playback speed of the player for the content referenced by the data property. The normal default playback speed is represented by value 1.
</td></tr>
</table>
<p> </p>
<table class="simple">
<thead><tr><th>Intrinsic event</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap">onPlaySpeedChanged</code></td>
<td>For RTSP-RTP, when RTSP ANNOUNCE with either beginning-of-stream or end-of-stream codes arrives the OITF SHALL generate onPlaySpeedChanged event with a speed value of 0.
</td></tr>
<tr><td><code class="wrap">onPlayPositionChanged</code></td>
<td>For RTSP-RTP, when the response to the RTSP PLAY with Range header request (Range is included when performing seek() with a position) the OITF SHALL generate onPlayPositionChanged event with the accepted position.
</td></tr>
</table>
</section>
<section>
<h4>CoD Media Queuing</h4>
<p>This section extends the mapping defined above to address behaviour when media queuing is in effect.</p>
<table class="simple">
<thead><tr><th>Method</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap"><b>queue</b>(String uri)</code></td>
<td><p>Queued media items available via HTTP or stored on the terminal MAY be pre-buffered by the OITF in order to reduce transition delays. When pre-buffering media items, the specified buffering policy SHALL NOT be affected.</p>
<p>For queued media items available via RTSP, session setup MAY be carried out prior to the end of the currently playing media item.</p>
</td></tr>
<tr><td><code class="wrap"><b>play</b>(Number speed)</code></td>
<td><p>When the start of a media item is reached due to a negative play speed, the playback SHOULD resume at normal play speed without playing any previous media items.</p>
<p>When the end of a media item is reached, playback of any queued media items SHALL be initiated automatically at the specified play speed. The OITF SHALL map this on to the underlying protocol (HTTP or RTSP) as the following sequence of DAE method calls:</p><pre class="javascript">
data = &lt;URI of the queued media item&gt;;
play(&lt;current play speed&gt;);
</pre>
</td></tr>
<tr><td><code class="wrap"><b>seek</b>(Integer pos)</code></td>
<td>If the value of <code>pos</code> is outside the current media item, the play position SHALL NOT be changed.
</td></tr>
<tr><td><code class="wrap">read/write String <b>data</b></code></td>
<td>Modification of this property SHALL cause any queued media items to be discarded.
</td></tr>
</table>
</section>
</section>
<section id="scheduled-content-multicast-streaming">
<h3>Scheduled content Multicast Streaming</h3>
<p>This section provides details of mapping of the DAE APIs to the descriptions provided in the Protocol specification [[!OIPF_PROT2]] for APIs between the OITF and the Network over reference points UNIS-11, UNIS-13 and UNIT-17 for Scheduled Content multicast streaming.</p>
<section>
<h4>Conveyance of Channel List</h4>
<p>Service discovery description procedure as described in [[!OIPF_PROT2]]  <a href="volume4.html#s6-1-3-1" class="extRef">section 6.1.3.1</a> enables the OITF to obtain the URL to access the broadcast channel information. The OITF SHALL utilise UNIS-7 using this URL to obtain the Broadcast Discovery Record.</p>
</section>
<section>
<h4>Switching Channels</h4>
<table class="simple">
<thead><tr><th>Method</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap"><b>setChannel</b>( Channel channel, Boolean trickplay, String contentAccessDescriptorURL )</code></td>
<td>The <code>setChannel</code> method of the <code>video/broadcast</code> object SHALL be used to initiate a broadcast session or switch channels. If the channel has an idType of <code>ID_IPTV_URI</code>, the OITF SHALL send and IGMP Leave and an IGMP Join request on the UNIS-13 as described in [[!OIPF_PROT2]]  <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.
</td></tr>
</table>
</section>
<section>
<h4>End Broadcast Service</h4>
<table class="simple">
<thead><tr><th>Method</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap"><b>release</b>()</code></td>
<td>The <code>release</code> method of the <code>video/broadcast</code> object causes the OITF to perform an IGMP Leave on the active broadcast session as described in [[!OIPF_PROT2]]  <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.
</td></tr>
</table>
</section>
<section>
<h4>Network Timeshift of broadcast services</h4>
<table class="simple">
<thead><tr><th>Method</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap"><b>pause</b>()</code></td>
<td>The <code>pause</code> method of the <code>video/broadcast</code> object causes the OITF to perform an IGMP Leave on the active broadcast session as described in [[!OIPF_PROT2]]  <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>. 
</td></tr>
<tr><td><code class="wrap"><b>resume</b>()</code></td>
<td><p>The RTSP URL signalled by the data attribute SHALL be used to initiate the process defined in [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-1-1" class="extRef">section 7.1.1.1.1</a>. The &ldquo;data&rdquo; attribute SHALL furthermore be updated with the new URI after redirection requests (moved). </p>
<p>The value of the &ldquo;scale&rdquo; header in the RTSP PLAY message SHALL be the value set by the most recent call to <code>setSpeed()</code>, or 1.0 if the most recent call to <code>setSpeed()</code> set the playback speed to 0 or <code>setSpeed()</code> has not been called.</p>
<p>If property <code>oitfNoRTSPSessionControl</code> is set to true then the RTSP messages DESCRIBE and SETUP are not used. If the <code>play()</code> method is called with a non-zero speed the property <code>oitfRTSPSessionId</code> is copied to the RTSP <code>SessionId</code> header for the RTSP PLAY request. If the <code>oitfRTSPSessionId</code> is <code>undefined</code> the <code>play()</code> method SHALL fail.
<p>After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a <code>PlaySpeedChanged</code> event indicating the actual playback speed.</p>
</td></tr>
<tr><td><code class="wrap"><b>setSpeed</b>( Number speed )</code></td>
<td><p>Sets current speed by using the &ldquo;Scale&rdquo; header in the RTSP PLAY as described in [[!OIPF_PROT2]]  <a href="volume4.html#s7-1-1-1" class="extRef">section 7.1.1.1</a>.</p>
<p>After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a <code>PlaySpeedChanged</code> event indicating a new playback speed.</p>
<p>If playback is previously paused (either by a call to <code>pause()</code> or by setting the playback speed to 0) then the new speed SHALL NOT be applied until the <code>resume()</code> method is called, as described above.</p> 
</td></tr>
<tr><td><code class="wrap"><b>seek</b>( Integer offset, Integer reference )</code></td>
<td><p>Sets current play position based on the specified offset from the given reference point, by using the &ldquo;Range&rdquo; parameter in the RTSP PLAY as described in [[!OIPF_PROT2]] <a href="volume4.html#s7-1-1-1" class="extRef">section 7.1.1.1</a>.</p>
<p>After a successful response to the RTSP PLAY message has been received, the OITF SHALL generate a <code>PlayPositionChanged</code> event indicating the new playback position.</p>
</td></tr>
<tr><td><code class="wrap"><b>stopTimeShift</b>()</code></td>
<td><p>The <code>setChannel()</code> method of the <code>video/broadcast</code> object SHALL be used to initiate a broadcast session. If the channel has an idType of <code>ID_IPTV_URI</code>, the OITF SHALL send and IGMP Join request on the UNIS-13 as described in [[!OIPF_PROT2]] <a href="volume4.html#s8-1-1-1" class="extRef">section 8.1.1.1</a>.</p></td></tr>
</table>
<p> </p>
<table class="simple">
<thead><tr><th>Property</th><th>Procedures</th></tr></thead>
<tr><td><code class="wrap">read/write String <b>data</b></code></td>
<td>This property holds the RTSP URI for the content item. 
</td></tr>
</table>
<p>Note that all the remaining properties listed under section <a href="#cod-unicast-streaming-over-rtp-and-http" class="sectionRef"></a> SHALL be supported as described.</p>
</section>
</section>
</section>

<section id="uri-schemes">
<h2>URI Schemes and their usage</h2>
<p>The following table lists possible URL schemas and their usages within DAE documents (XHTML, JavaScript, images, and references to A/V content). If a certain URL scheme is supported, the corresponding protocols to an URL scheme SHALL be supported as defined by the reference(s)</p>
<table class="simple" id="uri-schemes-table">
<caption>Table ####: URI schemes and usages</caption>
<thead>
<tr><th>URI Scheme</th><th>Usage</th><th>Reference</th><th>Comments</th></tr>
</thead>
<tr><td>dvb-mcast</td><td>Scheduled content delivery</td><td>DVB-MCAST URI scheme as defined by Annex A1 of [[!TS102539]]</td><td>A URL to refer to a scheduled content channel supported by the OITF and delivered via multicast.</td></tr>
<tr><td rowspan="2">dvb</td><td>Application launching</td><td>Locator for applications in SD&amp;S as defined by section 6.3.3 of [[!TS102851]]</td><td>The orgid and appid encoded in the DVB URI are compared with the applications signalled in SD&amp;S to identify one with the same orgid and appid.</td></tr>
<tr><td>Non-realtime downloaded content</td><td>Section 6 of [[!TS102851]]</td><td>Non-realtime downloaded content</td></tr>
<tr><td>igmp</td><td>Scheduled content</td><td><mark class="refError">"<a href="volume4.html#system-infrastructure" class="extRef">Annex F</a> of [[!OIPF_PROT2]]</mark></td><td>The transport IP Multicast Address to access the service as defined in [[!DVB-IPTV]].</td></tr>
<tr><td rowspan="3">http and https</td><td>Transport of DAE documents</td><td><a href="volume4.html#s5-3-3-1" class="extRef">Section 5.3.3.1</a> of [[!OIPF_PROT2]]<br />Section 5.3 of [[!CEA-2014-A]]<br /><a href="volume7.html#identification-authentication" class="extRef">Section 5</a> of [[.OIPF_CSP2]]</td><td>A URL  to refer documents supported by DAE.</td></tr>
<tr><td rowspan="2">Unicast streaming or download over HTTP</td><td>HAS specification [[.OIPF_HAS2]]</td><td>A URL to refer to the MPD.</td></tr>
<tr><td><mark class="refError"><a href="volume4.html#system-infrastructure" class="extRef">Annex F</a> of [[!OIPF_PROT2]]</mark></td><td rowspan="6">A Content URL specified in the data attribute of A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a>.<br />A Content URL specified in a Content Access Descriptor described in Annex <a href="#content-access-descriptor-formats" class="sectionRef"></a>.</td></tr>
<tr><td rowspan="2">crid</td><td>COD streaming</td><td rowspan="2"><a href="volume3.html#crid-location-resolution" class="extRef">Section 4.3</a> of [[!OIPF_META2]]</td></tr>
<tr><td>Programme identification via BCG</td></tr>
<tr><td rowspan="2">sip</td><td>Unicast streaming over RTP (&ldquo;sip-rtsp-rtp-udp&rdquo;)</td><td rowspan="3"><mark class="refError"><a href="volume4.html#system-infrastructure" class="extRef">Annex F</a> of [[!OIPF_PROT2]]</a></td></tr>
<tr><td>Unicast streaming over UDP (&ldquo;sip-rtsp-udp&rdquo;)</td></tr>
<tr><td>rtsp</td><td>Unicast streaming control</td></tr>
<tr><td>URI scheme for recordings</td><td>Recordings</td><td>Section <a href="#recording-properties" class="sectionRef"></a> of this specification.</td><td>
The format of the URI is outside the scope of this specification except that:<ul>
<li>The scheme SHALL NOT be one that is included in this specification
<li>The URI SHALL NOT include a fragment</ul>
</td></tr>
<tr><td>URI scheme for downloaded content</td><td>Downloaded content</td><td>Section <a href="#download-properties" class="sectionRef"></a> of this specification.</td><td>
The format of the URI is outside the scope of this specification except that:<ul>
<li>The scheme SHALL NOT be one that is included in this specification
<li>The URI SHALL NOT include a fragment</ul>
</td></tr>
</table>
<section id="media-fragments-support">
<h3>Media Fragments support</h3>
<p>Section 8.1 of [[.OIPF_WSTVP2]] requires support for temporal clipping based on Normal Play Time as defined in <a href="http://www.w3.org/TR/media-frags/#naming-time" class="extRef">section 4.2.1</a> of the Media Fragments URI specification [[!Media-Fragments-URI]]. URLs including these temporal clipping fragments SHALL be supported as follows;</p><ul>
<li>HTTP URIs including a temporal clipping fragment SHALL be supported. Mapping from time to byte position as defined in <a href="http://www.w3.org/TR/2011/WD-media-frags-recipes-20111201#processing-protocol-UA-mapped" class="extRef">section 2.1</a> (&ldquo;UA mapped byte ranges&rdquo;) of  [[!MEDIA_FRAGMENTS_HTTP]]  SHOULD be supported. Mapping of normal play time to byte ranges in the server defined in <a href="http://www.w3.org/TR/2011/WD-media-frags-recipes-20111201/#processing-protocol-Server-mapped" class="extRef">section 2.2</a> (&ldquo;server mapped byte ranges&rdquo;) of [[!MEDIA_FRAGMENTS_HTTP]] MAY be supported.
<li>If the OITF supports RTSP then RTSP URIs including a temporal clipping fragment SHALL be supported. The normal play time specified in the URI SHALL be used by the OITF to determine the starting time and ending time of the media. The normal play time SHOULD be mapped to the RTSP protocol as define in <a href="http://www.w3.org/TR/2011/WD-media-frags-recipes-20111201/#rtsp-media-fragment-processing" class="extRef">Annex A</a> (&ldquo;Processing media fragment URIs in RTSP&rdquo;) of [[!MEDIA_FRAGMENTS_HTTP]].
<li>If the OITF has local PVR capability then the OITF SHALL support use of temporal clipping fragments with the URI returned by the 'uri' property of the Recording class. This specification is intentionally silent about how mapping from normal play time to byte positions within the recorded content is performed.
<li>If the OITF has support for downloading content then the OITF SHALL support use of temporal clipping fragments with the URI returned by the 'uri' property of the Download class. This specification is intentionally silent about how mapping from normal play time to byte positions within the downloaded content is performed.
</ul>
<p>The begin time SHALL behave as start-of-media and the end time SHALL behave as end-of-media. If the value of temporal fragment interval is changed then there will be no change in the play state unless the interval is changed so that the current play position is outside the interval.</p>
</section>
</section>

<section id="mapping-apis-to-content-formats">
<h2>Mapping from APIs to Content Formats</h2>
<section>
<h3>Character Conversion</h3>
<p>Except for the <a href="#programme-getsidescriptors" class="apiRef">getSIDescriptors()</a> method (see section <a href="#programme-dvb-si-extensions" class="sectionRef"></a>), the OITF SHALL translate all characters extracted from DVB SI tables and descriptors into their UTF-16 equivalent when exposing the character in a JavaScript character or string object. In addition, the following rules SHALL apply:</p><ul>
<li>The character table of text fields in DVB SI SHALL be determined as specified in EN 300 468 Annex A. The default character table MAY be determined by the local broadcast system.
<li>The bytes denoting the character table and the control codes for character emphasis on and off SHALL be filtered out by the OITF.
<li>The control codes for "CR/LF" SHALL be expanded to the two separate UTF-16 characters U+000D and U+000A.
</ul>
</section>
<section id="mapping-apis-to-content-formats-avcomponent">
<h3>AVComponent</h3>
<p>AVComponent objects represent the components in a stream. For an MPEG-2 transport stream not delivered via adaptive streaming, the set of components SHALL be the audio, video and subtitle components listed in the PMT of the service. For content in the MP4 file format not delivered via adaptive streaming, the set of components SHALL be the audio, video and subtitle tracks listed in the &ldquo;moov&rdquo; box. For content delivered via adaptive streaming, A/V Component objects SHALL correspond to adaptation sets in the MPD.</p>
<p>The following table shows the mapping from the properties of the AVComponent class to the data carried inside the MPEG-2 TS and MP4 file format.</p>
<table class="simple">
<thead>
<tr style="vertical-align: top;"><th>Property<br /><br />Name and Type</th>
<th>MPEG-2 TS<br /><br />With DVB-SI component_descriptor in SDT and/or EIT</th>
<th>MPEG-2 TS<br /><br />Without DVB-SI SDT and EIT</th>
<th>MP4 FF</th>
<th>MPEG DASH</th>
</tr></thead>
<tr><td>Name: componentTag<br />Type: Integer</td><td colspan="2">The contents of the component_tag field in the stream_identifier_descriptor in PMT</td><td>Not defined</td><td>The value of the id attribute in the AdaptationSet (if provided)</td></tr>
<tr><td>Name: pid<br />Type: Integer</td><td colspan="2">The PID of the stream in the PMT</td><td>trackID</td><td>Not defined</td></tr>
<tr><td>Name: type<br />Type: One of the following constants COMPONENT_TYPE_VIDEO / COMPONENT_TYPE_AUDIO / COMPONENT_TYPE_SUBTITLE</td>
<td colspan="2">May be derived as follows:<ul>
<li>A value of 0x02 or 0x1B in the stream_type field in the PMT &rarr; VIDEO.
<li>A value of 0x03 or 0x11 in the stream_type field in the PMT &rarr; AUDIO.
<li>A value of 0x06 in the stream_type field in the PMT and the presence of a DTS_audio_stream_descriptor in the ES loop in the PMT &rarr; AUDIO.
<li>A value of 0x06 in the stream_type field in the PMT and the presence of an AC3_descriptor or an Enhanced_AC3_descriptor in the ES loop in the PMT &rarr; AUDIO.
<li>A value of 0x06 in the stream_type field in the PMT and the presence of a subtitling_descriptor in the ES loop in the PMT &rarr; SUBTITLES.
<li>A value of 0x06 in the stream_type field in the PMT and the presence of a teletext_descriptor in the ES loop in the PMT and an entry in that descriptor with Teletext_type set to 0x02 or 0x05 &rarr; SUBTITLES.</ul></td>
<td>Track has a VisualSampleEntry (handler_type =&rdquo;vide&rdquo;) &rarr; COMPONENT_TYPE_VIDEO<br /><br />
Track has an AudioSampleEntry (handler_type = &ldquo;soun&rdquo;) &rarr; COMPONENT_TYPE_AUDIO</td>
<td>Defined by the value of the '@contentType' attribute</td></tr>

<tr><td rowspan="6">Name: encoding<br />
Type: A string identifying the video or audio format as defined in <a href="volume2.html#media-section" class="extRef">section 3</a> of [[.OIPF_MEDIA2]] or the subtitle format as defined in section <a href="#avcomponent-properties" class="sectionRef"></a></td>
<td colspan="2">Property type is COMPONENT_TYPE_VIDEO</td><td> </td><td rowspan="6">Defined by the '@codecs' attribute</td></tr>
<tr><td colspan="2">&rarr; &ldquo;video/mpeg&rdquo; or &ldquo;video/mp2t&rdquo;. </td><td>Track has a sample description type &ldquo;avc1&rdquo; &rarr; &ldquo;video/mp4&rdquo;.</td></tr>
<tr><td colspan="3">Property type is COMPONENT_TYPE_AUDIO</td></tr>
<tr><td colspan="2">
<p>A value of 0x03 in the stream_type field in the PMT &rarr; &ldquo;audio/mpeg&rdquo;.</p>
<p>A value of 0x11 in the stream_type field in the PMT and the profile_and_level field in that descriptor indicates MPEG-4 AAC or MPEG-4 HE AAC &rarr; &ldquo;audio/mp4&rdquo;.</p>
<p>A value of 0x11 in the stream_type field in the PMT and the profile_and_level field in that descriptor indicates MPEG-4 HE AAC v2 &rarr; &ldquo;audio/aacp&rdquo;.</p>
<p>A value of 0x06 in the stream_type field in the PMT and the presence of a DTS_audio_stream_descriptor in the ES loop in the PMT &rarr; &ldquo;audio/vnd.dts&rdquo;.</p>
<p>A value of 0x06 in the stream_type field in the PMT and the presence of an AC3_descriptor in the ES loop in the PMT &rarr; &ldquo;audio/ac3&rdquo;.</p>
</td>
<td>Track has a sample description type &ldquo;mp4a&rdquo; &rarr; &ldquo;audio/mp4&rdquo;</td></tr>
<tr><td colspan="3">Property type is COMPONENT_TYPE_SUBTITLE</td></tr>
<tr><td colspan="2">
<p>A value of 0x01 in subtitling_type field of the subtitling_descriptor in the ES loop of the PMT &rarr; &ldquo;EBU-SUBT&rdquo;.</p>
<p>A value of 0x10 or 0x11 or 0x12 or 0x14 in the subtitling_type field of the subtitling_descriptor in the ES loop of the PMT &rarr; &ldquo;DVB-SUBT&rdquo;.</p>
<p>A value of 0x20 or 0x21 or 0x22 or 0x24 in the subtitling_type field of the subtitling_descriptor in the ES loop of the PMT &rarr; &ldquo;DVB_SUBT&rdquo; (the hearingImpaired property in the derived AVSubtitleComponent would be set to true).</p>
<p>The PMT contains a caption_service_descriptor with a digital_cc flag having the value of 1 for at least one of the represented caption services &rarr; &ldquo;CEA-SUBT&rdquo;.</p>
</td>
<td>Track has a handler-type &ldquo;text&rdquo; &rarr; &ldquo;3GPP-TT&rdquo;.</td>
</tr>
<tr>
<td>Name: encrypted<br />Type: Boolean</td>
<td colspan="2">May be derived from any of the following:<ul>
<li>Presence of a CA_descriptor in the PMT in the program information loop.</ul>
Presence of a CA_descriptor in the PMT in the elementary stream information loop describing the stream.
</td>
<td>Not defined</td>
<td></td>
</tr>

<tr>
<td>Name: aspectRatio<br />Type: Number containing width divided by height as a decimal<br /><br />Only defined for video components.</td>
<td>Derived from the stream_content and component_type fields in the component_descriptor.</td>
<td>Undefined</td>
<td>Not defined</td>
<td>Defined by the value of the '@par' attribute</td>
</tr>
<tr><td rowspan="4">Name: language<br />Type: String containing an ISO 639-2 language code as defined in [[!ISO639-2]]<br /><br />Only defined for audio and subtitle components.</td>
<td colspan="3">Property type is COMPONENT_TYPE_AUDIO</td><td rowspan="4">Defined by the value of the '@lang' attribute in the MPD, whether set explicitly or inherited. The contents of the language field in the 'mdhd&rdquo; of the track SHALL be ignored.</td></tr>
<tr><td colspan="2">For audio components, the contents of the ISO_639_language_code field in the ISO_639_language_descriptor In the ES loop of the PMT unless overridden by the ISO_639_language_code field in the supplementary_audio_descriptor.</td><td>The contents of the language field in the media header &ldquo;mdhd&rdquo; of the track.</td></tr>
<tr><td colspan="3">Property type is COMPONENT_TYPE_SUBTITLE</td></tr>
<tr><td colspan="2">For subtitles, the contents of the ISO_639_language_code field in the subtitling_descriptor or teletext_descriptor, as appropriate.</td><td>The contents of the language field in the media header &ldquo;mdhd&rdquo; of the track.</td></tr>
<tr><td>Name: audioDescription<br />Type: Boolean - True if is component is an audio description<br /><br />Only defined for audio components.</td>
<td colspan="2">True if any of the following is true:<ul>
<li>There is an audio component with an ISO_639_language_descriptor in the PMT with the audio_type field set to 0x03
<li>There is a supplementary_audio_descriptor with the editorial_classification field set to 0x01
<li>There is an ac-3_descriptor or an enhanced_ac-3_descriptor with a component_type field with the service_type flags set to Visually Impaired.</ul>
Otherwise false.</td>
<td>Not defined</td><td></td></tr>

<tr><td>Name: audioChannels<br />Type: Number indicating 5 for 5.1, 7 for 7.1, 2 for stereo<br /><br />Only defined for audio components.</td><td></td><td></td><td>Not defined</td><td>Derived from the contents of the Audio Channel Configuration element</td></tr>
<tr><td>Name: hearingImpaired<br />Type: Boolean - Has value true if the stream is intended for the hearing-impaired (e.g. contains a written description of the sound effects), false otherwise.<br /><br />Only defined for subtitle components</td>
<td colspan="2">True if one of the following is true:<ul>
<li>There is a subtitling_descriptor with the subtitling_type field set to 0x20, 0x21, 0x22, 0x23 or 0x24.
<li>There is a teletext_descriptor with a teletext_type field with a value of 0x05.</ul></td>
<td>Not defined</td>
<td>Not defined</td>
</tr>
</table>
<p>NOTE: This specification intentionally does not define a mapping from the properties of the AVComponent class to the HAS MPD.</p>
</section>
<section id="mapping-apis-to-content-formats-channel">
<h3>Channel</h3>
<p>Channel objects represent data streams carrying content that the OITF can tune to. In some cases the channel object may have been explicitly created by an application but usually they will have been created when the OITF discovers the channel when performing a scan or reading an SD&amp;S file. The following tables show the mapping from the properties of the Channel class to the source of the data for that property.</p>
<p>All references in the tables to the SDT are for the SDT Actual table (i.e. the SDT carried in the MPEG2-TS with a PID value of 0x0011 and a table_id value of 0x42, as defined in EN 300 468 [[!EN300468]]), and references to the BroadcastDiscovery and PackageDiscovery are to the elements of those names in SD&amp;S.</p>
<p>For channels of type <code>ID_DVB_*</code>:</p>
<table class="simple">
<thead><tr><th>Property name</th><th>Source</th><th>Comment</th></tr></thead>
<tr><td><code>channelType</code></td><td>Assigned by the terminal.</td><td>Assigned by the terminal to <code>TYPE_TV</code> or <code>TYPE_RADIO</code> based on the service type signalled in SDT/service descriptor/service type or undefined otherwise.</td></tr>
<tr><td><code>idType</code></td><td>Assigned by the terminal or by the application.</td><td>Assigned by the terminal based on the type of channel, if the channel was discovered by a channel scan, or by the application using the value passed in the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>ccid</code></td><td>Assigned by the terminal. </td><td>Unique identifier for the channel</td></tr>
<tr><td><code>tunerID</code></td><td>Assigned by the terminal. </td><td>Unique identifier for the tuner</td></tr>
<tr><td><code>onid</code></td><td>Assigned by the terminal or by the application. </td><td>Assigned by the terminal from SDT.onid or by the application using the value passed in to the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>nid</code></td><td>Assigned by the terminal.</td><td>
Assigned by the terminal as follows:<ul>
<li>If during the terminal configuration process, a network_id value was selected (either explicitly or implicitly) and the NIT subtable with that network_id value was used by the terminal to discover the correct delivery system descriptor of this channel, then the value of this property shall be that network_id value.
<li>Otherwise, if there is exactly one NIT 'actual' subtable in the Transport Stream that is carrying the channel then the value of this property shall be the network_id in that subtable. Terminals are not required to update the value if it changes dynamically in the broadcast Transport Stream.
<li>Otherwise the value shall be <code>undefined</code>.</ul>
</td></tr>
<tr><td><code>tsid</code></td><td>Assigned by the terminal or by the application.</td><td>Assigned by the terminal from SDT.tsid or PAT.tsid  or by the application using the value passed in to the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>sid</code></td><td>Assigned by the terminal or by the application. </td><td>Assigned by the terminal from SDT.sid  or by the application using the value passed in to the <code>createChannelObject()</code> method. </td></tr>
<tr><td><code>sourceID</code></td><td>Assigned by the terminal. </td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>freq</code></td><td>Assigned by the terminal. </td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>cni</code></td><td>Assigned by the terminal. </td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>name</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>majorChannel</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>minorChannel</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>dsd</code></td><td>Assigned by the terminal or by the application.</td><td>Assigned by the application using the delivery system descriptor passed in to the <code>createChannelObject()</code> method, or implementation dependent in all other cases.</td></tr>
<tr><td><code>favourite</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>favIDs</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>locked</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>manualBlock</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>ipBroadcastID</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>channelMaxBitRate</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>channelTTR</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>recordable</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>longName</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>description</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>authorised</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>genre</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>hidden</code></td><td>Assigned by the terminal or by the application.</td><td>If the DVB broadcast system supports a logical channel number mechanism that can identify channels that are not expected to be offered to the user in a channel list then the value of this property should be derived from that signalling. Otherwise the value of this property is implementation dependent. <br />
NOTE This specification does not itself include a logical channel number mechanism for channels of type ID_ DVB_*.
</td></tr>
<tr><td><code>logoURL</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>isHD</code></td><td>Assigned by the terminal.</td><td>Assigned by the terminal to <code>true</code> or <code>false</code> based on the service type signalled in SDT/service descriptor/service type or <code>undefined</code> otherwise.</td></tr>
<tr><td><code>is3D</code></td><td>Assigned by the terminal.</td><td>Assigned by the terminal to <code>true</code> or <code>false</code> based on the service type signalled in SDT/service descriptor/service type or <code>undefined</code> otherwise.</td></tr>
</table>
<p>For channels of type <code>ID_IPTV_SDS</code>:</p>
<table class="simple">
<thead><tr><th>Property name</th><th>Source</th><th>Comment</th></tr></thead>
<tr><td><code>channelType</code></td><td>Assigned by the terminal.</td><td>Assigned by the OITF based on the value signalled in SDT/service descriptor/service type in the stream if BroadcastDiscovery/ServiceList/SingleService/SI@PrimarySISource is &ldquo;Stream&rdquo;, otherwise assigned based on the value of BroadcastDiscovery/ServiceList/SingleService/SI@ServiceType (if present).<br /><br />Otherwise, or if not known, set to <code>undefined</code>.</td></tr>
<tr><td><code>idType</code></td><td>Assigned by the terminal or by the application.</td><td>Assigned by the OITF to ID_IPTV_SDS if the channel was discovered using SD&amp;S metadata, or assigned by the application using the value passed in the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>ccid</code></td><td>Assigned by the terminal.</td><td>Unique identifier for the channel</td></tr>
<tr><td><code>tunerID</code></td><td>Assigned by the terminal.</td><td>Unique identifier for the tuner if relevant or set to <code>undefined</code></td></tr>
<tr><td><code>onid</code></td><td>Assigned by the terminal.</td><td>Assigned by the OITF to the value signalled in BroadcastDiscovery/ServiceList/SingleService/DVBTriplet@OrigNetId</td></tr>
<tr><td><code>nid</code></td><td>Assigned by the terminal.</td><td>Implementation dependent.</td></tr>
<tr><td><code>tsid</code></td><td>Assigned by the terminal.</td><td>Assigned by the OITF to the value signalled in BroadcastDiscovery/ServiceList/SingleService/DVBTriplet@TSId</td></tr>
<tr><td><code>sid</code></td><td>Assigned by the terminal.</td><td>Assigned by the OITF to the value signalled in BroadcastDiscovery/ServiceList/SingleService/DVBTriplet@ServiceId</td></tr>
<tr><td><code>sourceID</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>freq</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>cni</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>name</code></td><td>Assigned by the terminal.</td><td>Assigned by the OITF from SDT/service descriptor/service name in the stream if BroadcastDiscovery/ServiceList/SingleService/SI@PrimarySISource is &ldquo;Stream&rdquo;, otherwise set to BroadcastDiscovery/ServiceList/SingleService/SI/Name (if present), otherwise set to BroadcastDiscovery/ServiceList/SingleService/TextualIdentifier@ServiceName </td></tr>
<tr><td><code>majorChannel</code></td><td>Assigned by the terminal.</td><td>Assigned by the OITF from  PackageDiscovery/Package/Service/LogicalChannelNumber (if present), otherwise takes the value <code>undefined</code></td></tr>
<tr><td><code>minorChannel</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>dsd</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code></td></tr>
<tr><td><code>favourite</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>favIDs</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>locked</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>manualBlock</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>ipBroadcastID</code></td><td>Assigned by the terminal or by the application.</td><td>Assigned by the OITF to the DVB textual service identifier of the IP broadcast service, specified in the format &ldquo;ServiceName.DomainName&rdquo; with the ServiceName and DomainName taken from the attributes of BroadcastDiscovery/ServiceList/SingleService/TextualIdentifier, or assigned by the application using the value passed in to the createChannelObject() method</td></tr>
<tr><td><code>channelMaxBitRate</code></td><td>Assigned by the terminal.</td><td>Assigned by the OITF to the value provided in BroadcastDiscovery/ServiceList/SingleService/MaxBitrate (if present), otherwise <code>undefined</code></td></tr>
<tr><td><code>channelTTR</code></td><td>Assigned by the terminal.</td><td>Assigned by the OITF to the value provided in BroadcastDiscovery/ServiceList/SingleService/TimeToRenegotiate (if present), otherwise <code>undefined</code></td></tr>
<tr><td><code>recordable</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>longName</code></td><td>Assigned by the terminal.</td><td>Set by the OITF to the Name element that is a child of the BCG <code>ServiceInformation</code> element describing the channel, where the <code>length</code> attribute of the <code>Name</code> element has the value 'long'</td></tr>
<tr><td><code>description</code></td><td>Assigned by the terminal.</td><td>Set by the OITF to BroadcastDiscovery/ServiceList/SingleService/SI/Description (if present), otherwise set to the <code>ServiceDescription</code> element that is a child of the BCG <code>ServiceInformation</code> element describing this channel.</td></tr>
<tr><td><code>authorised</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>genre</code></td><td>Assigned by the terminal.</td><td>Set by the OITF to BroadcastDiscovery/ServiceList/SingleService/SI/ContentGenre (if present), otherwise set to the values of any <code>ServiceGenre</code> elements that are children of the BCG <code>ServiceInformation</code> element describing the channel.</td></tr>
<tr><td><code>hidden</code></td><td>Assigned by the terminal or by the application.</td><td>Implementation dependent</td></tr>
<tr><td><code>logoURL</code></td><td>Assigned by the terminal.</td><td>Set by the OITF to the value of the first Logo element that is a child of the BCG <code>ServiceInformation</code> element describing the channel, when this element specifies the URL of an image.</td></tr>
<tr><td><code>isHD</code></td><td>Assigned by the terminal.</td><td>Assigned by the terminal to true or false based on the service type signalled in SDT/service descriptor/service type if BroadcastDiscovery/ServiceList/SingleService/SI@PrimarySISource is &ldquo;Stream&rdquo;, otherwise assigned based on the value of BroadcastDiscovery/ServiceList/SingleService/SI@ServiceType (if present).<br /><br>Otherwise, or if not known, set to <code>undefined</code>.
</td></tr>
<tr><td><code>is3D</code></td><td>Assigned by the terminal.</td><td>Assigned by the terminal to true or false based on the service type signalled in SDT/service descriptor/service type if BroadcastDiscovery/ServiceList/SingleService/SI@PrimarySISource is &ldquo;Stream&rdquo;, otherwise assigned based on the value of BroadcastDiscovery/ServiceList/SingleService/SI@ServiceType (if present).<br /><br />Otherwise, or if not known, set to undefined.
</td></tr>
</table>
<p>For channels of type <code>ID_IPTV_URI</code>:</p>
<table class="simple">
<thead><tr><th>Property name</th><th>Source</th><th>Comment</th></tr></thead>
<tr><td><code>channelType</code></td><td>Assigned by the terminal. </td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>idType</code></td><td>Assigned by the application. </td><td>Assigned by the application using the value passed in the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>ccid</code></td><td>Assigned by the terminal. </td><td>Unique identifier for the channel</td></tr>
<tr><td><code>tunerID</code></td><td>Assigned by the terminal. </td><td>Unique identifier for the tuner if relevant or set to <code>undefined</code></td></tr>
<tr><td><code>onid</code></td><td>Assigned by the terminal or by the application. </td><td>Assigned by the application using the value passed in to the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>nid</code></td><td>Assigned by the terminal. </td><td>Implementation dependent</td></tr>
<tr><td><code>tsid</code></td><td>Assigned by the terminal or by the application. </td><td>Assigned by the application using the value passed in to the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>sid</code></td><td>Assigned by the terminal or by the application.</td><td>Assigned by the application using the value passed in to the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>sourceID</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>freq</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>cni</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>name</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>majorChannel</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>minorChannel</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>dsd</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>favourite</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>favIDs</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>locked</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>manualBlock</code></td><td>Assigned by the terminal.</td><td></td></tr>
<tr><td><code>ipBroadcastID</code></td><td>Assigned by the terminal.</td><td>Assigned by the application using the value passed in to the <code>createChannelObject()</code> method.</td></tr>
<tr><td><code>channelMaxBitRate</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>channelTTR</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>recordable</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>longName</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>description</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>authorised</code></td><td>Assigned by the terminal.</td><td>Implementation dependent</td></tr>
<tr><td><code>genre</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>hidden</code></td><td>Assigned by the terminal or by the application.</td><td>Implementation dependent</td></tr>
<tr><td><code>logoURL</code></td><td>Assigned by the terminal.</td><td>Takes the value <code>undefined</code>.</td></tr>
<tr><td><code>isHD</code></td><td>Assigned by the terminal.</td><td>If the channel is being received by the OITF, assigned by the terminal to true or false based on:<ul>
<li>For MPEG2-TS content with service_descriptor in SDT, the property takes the value as defined for a channel of type ID_DVB_*.
<li>For content delivered using MPEG-DASH, the property takes the value true if the MPD AdaptationSet element height attribute is set to a value greater than or equal to 720, false otherwise.</ul>
Otherwise, it takes the value <code>undefined</code>.
</td></tr>
<tr><td><code>is3D</code></td><td>Assigned by the terminal.</td><td>If the channel is being received by the OITF, assigned by the terminal to true or false based on:<ul>
<li>For MPEG2-TS content with service_descriptor in SDT, the property takes the value as defined for the channel of type ID_DVB_*.
<li>For content delivered using MPEG-DASH, the property takes the value true if 3D video is indicated in the MPD AdaptationSet element FramePacking attribute, false otherwise.</ul>
Otherwise, it takes the value <code>undefined</code>.
</td></tr>
</table>
</section>
<section id="programme-scheduled-recording-recording-and-download">
<h3>Programme, ScheduledRecording, Recording and Download</h3>
<p>The following table defines the mapping between the properties of the <code>Programme</code>, <code>ScheduledRecording</code>, <code>Recording</code> and <code>Download</code> classes.</p>
<table class="simple">
<thead>
<tr><th>Property name</th><th>Source</th><th>Programme Class Property</th><th>ScheduledRecording Class Property </th><th>Recording Class Property </th><th>Download Class Property </th></tr>
</thead>
<tr><td><code>state</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>Assigned and updated by the terminal as recording is carried out. </td><td>Assigned by the terminal, section <a href="#download-properties" class="sectionRef"></a> of the present document.</td></tr>
<tr><td><code>id</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>Unique internal identifier for recordings.</td><td>Unique internal identifier for downloaded content.</td></tr>
<tr><td><code>startPadding</code></td>
<td>Assigned by the terminal or the application.</td><td>N/A</td><td>Default value assigned by the terminal; may be overridden by the application.</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>endPadding</code></td>
<td>Assigned by the terminal or the application.</td><td>N/A</td><td>Default value assigned by the terminal; may be overridden by the application.</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>repeatDays</code></td>
<td>Set by the application.</td><td>N/A</td><td>The days on which the recording will be repeated as assigned by the application </td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>name</code></td>
<td>Assigned by the terminal.</td><td>Assigned by the terminal from EIT/short_event_descriptor/event name</td><td>Derived from Programme object when recording is scheduled.<br /><br />For manual recordings, assigned by the terminal (see note).</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>Assigned by the terminal from CADD.Title.</td></tr>
<tr><td><code>description</code></td>
<td>Assigned by the terminal.</td><td>Assigned by the terminal from EIT/short_event_descriptor/description</td><td>Derived from Programme object when recording is scheduled</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>Assigned by the terminal from CADD.Synopsis if present.</td></tr>
<tr><td><code>longDescription</code></td>
<td>Assigned by the terminal.</td><td>Assigned by the terminal from EIT/extended_event_descriptor/text</td><td>Derived from Programme object when recording is scheduled</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>startTime</code></td>
<td>Assigned by the terminal or the application.</td><td>Assigned by the terminal from EIT/event/start_time.</td><td>Derived from Programme object when recording is scheduled.<br /><br />Assigned by the application for  recordings scheduled using the recordAt() method.<br /><br />For manual recordings initiated via a native UI, assigned by the terminal (see note).</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>Assigned by the terminal based on  the startTime argument of RegisterDownload().</td></tr>
<tr><td><code>recordingStartTime</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>The actual start time of the recording.</td><td>N/A</td></tr>
<tr><td><code>timeElapsed</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal.</td></tr>
<tr><td><code>timeRemaining</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal.</td></tr>
<tr><td><code>duration</code></td>
<td>Assigned by the terminal or the application.</td><td>Assigned by the terminal from EIT/event/duration.</td><td>Derived by the terminal from the duration property of the Programme object when the recording is scheduled.<br /><br />Assigned by the application for  recordings scheduled using the recordAt() method.<br /><br />For manual recordings initiated via a native UI, assigned by the terminal (see note).</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>recordingDuration</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>The actual duration of the recording. </td><td>N/A</td></tr>
<tr><td><code>channel</code></td>
<td>Assigned by the terminal.</td><td>Reference to broadcast channel where content is available.  Set to broadcast content location.</td><td>Derived by the terminal  from the ccid property of the Programme object when the recording is scheduled.<br /><br />Derived by the terminal from the value passed by the application for  recordings scheduled using the recordAt() method.<br /><br />For manual recordings initiated via a native UI, assigned by the terminal (see note).</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>channelID</code></td>
<td>Assigned by the terminal.</td><td>Populated from ccid of the channel carrying this programme.</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
<tr><td><code>programmeID</code></td>
<td>Assigned by the terminal.</td><td>If a programme CRID is not provided in the EIT for the programme then this shall be assigned by the terminal from EIT/event_id and it shall be encoded as a DVB URL referencing a DVB-SI event as enabled by  <a href="volume3.html#event-information-tables" class="extRef">section 4.1.3</a> of [[.OIPF_META2]].<br />Otherwise this is outside the scope of the present document.</td><td>Derived from Programme object when recording is scheduled</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>programmeIDType</code></td>
<td>Assigned by the terminal.</td><td>Assigned by the terminal.</td><td>Derived from Programme object when recording is scheduled</td><td>Derived by the terminal from the corresponding property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>parentalRatings</code></td>
<td>Assigned by the terminal.</td><td>Populated from EIT/parental_rating_descriptor/rating, where present. </td><td>Derived  from Programme object when recording is scheduled.<br /><br />For manual recordings initiated via a native UI, assigned by the terminal (see note).</td><td>Derived by the terminal from the parentalRating property on the ScheduledRecording object.</td><td>Assigned by the terminal from CADD.parentalRating if present.</td></tr>
<tr><td><code>contentID</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal from CADD.contentID if present.</td></tr>
<tr><td><code>totalSize</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal from CADD.contentURL@size, then updated to actual size on disk  at end of download.</td></tr>
<tr><td><code>contentURL</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal from CADD.contentURL. </td></tr>
<tr><td><code>drmControl</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal from CADD.DRMControlInformation  if present.</td></tr>
<tr><td><code>transferType</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal from CADD.contentURL.transferType.</td></tr>
<tr><td><code>originSite</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal from CADD.originSite </td></tr>
<tr><td><code>originSiteName</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal from 
CADD.originSiteName if present.</td></tr>
<tr><td><code>iconURL</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>N/A</td><td>Assigned by the terminal from CADD.iconURL if present.</td></tr>
<tr><td><code>longName</code></td>
<td>Assigned by the application.</td><td>For Programme objects created using the <a href="#oipfrecordingscheduler-createprogrammeobject" class="apiRef">createProgrammeObject()</a> method, this may be set by the application.<br /><br />No standardised mapping in DVB-SI</td><td>Derived from Programme object when recording is scheduled.</td><td>Derived by the terminal from the longName property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>episode</code></td>
<td>Assigned by the application.</td><td>For Programme objects created using the <a href="#oipfrecordingscheduler-createprogrammeobject" class="apiRef">createProgrammeObject()</a> method, this may be set by the application.<br /><br />No standardised mapping in DVB-SI</td><td>Derived from Programme object when recording is scheduled.</td><td>Derived by the terminal from the episode property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>totalEpisodes</code></td>
<td>Assigned by the application.</td><td>For Programme objects created using the <a href="#oipfrecordingscheduler-createprogrammeobject" class="apiRef">createProgrammeObject()</a> method, this may be set by the application.<br /><br />No standardised mapping in DVB-SI</td><td>Derived from Programme object when recording is scheduled.</td><td>Derived by the terminal from the totalEpisodes property on the ScheduledRecording object.</td><td>N/A</td></tr>
<tr><td><code>blocked</code></td>
<td>Assigned by the terminal.</td><td>Set based on parental control settings for broadcast</td><td>N/A</td><td>Set based on parental control settings</td><td>N/A</td></tr>
<tr><td><code>showType</code></td>
<td></td><td>No standardised mapping in DVB-SI.</td><td>N/A</td><td>No standardised mapping in DVB-SI.</td><td>N/A</td></tr>
<tr><td><code>subtitles</code></td>
<td>Assigned by the terminal.</td><td>Set in the presence of  EIT/subtitle component descriptor for broadcast content for content within schedule.</td><td>N/A</td><td>Set in the presence of EIT/subtitle component descriptor for broadcast content within scope of schedule when the recording starts.</td><td>N/A</td></tr>
<tr><td><code>isHD</code></td>
<td>Assigned by the terminal.</td><td>Set in the presence of an EIT/component descriptor with stream_content value 0x01 or 0x05 and a component_type value indicating &ldquo;high definition video&rdquo; as defined in table 26 of [[!EN300468]], for broadcast content within scope of schedule.</td><td>N/A</td><td>Set in the presence of an EIT/component descriptor with stream_content value 0x01 or 0x05 and a component_type indicating &ldquo;high definition video&rdquo; as defined in table 26 of [[!EN300468]], for broadcast content within scope of schedule when the recording starts.</td><td>N/A</td></tr>
<tr><td><code>audioType</code></td>
<td>Assigned by the terminal.</td><td>Derived from EIT/component descriptors with stream_content value 0x02, 0x04 or 0x06 for broadcast content within scope of schedule.</td><td>N/A</td><td>Derived from EIT/component descriptors with stream_content value 0x02, 0x04 or 0x06 for broadcast content within scope of schedule when the recording starts.</td><td>N/A</td></tr>
<tr><td><code>isMultilingual</code></td>
<td>Assigned by the terminal.</td><td>Set when the set of language codes for EIT/component descriptors with stream_content value 0x02, 0x04 or 0x06 contains more than one language code for broadcast content within scope of schedule.</td><td>N/A</td><td>Set when the set of language codes for EIT/component descriptors with stream_content value 0x02, 0x04 or 0x06 contains more than one language code for broadcast content within scope of schedule when the recording starts.</td><td>N/A</td></tr>
<tr><td><code>genre</code></td>
<td>Assigned by the terminal.</td><td>Populated from EIT/content_descriptor/content_nibble_level_1 for broadcast content.</td><td>N/A</td><td>For broadcast content, populated from EIT/content_descriptor/content_nibble_level_1 when the recording starts.</td><td>N/A</td></tr>
<tr><td><code>hasRecording</code></td>
<td>Assigned by the terminal.</td><td>Set if the content item is already recorded on Terminal based storage.</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>
<tr><td><code>audioLanguages</code></td>
<td>Assigned by the terminal.</td><td>Derived from language code(s) present in EIT/component descriptors with stream_content value 0x02, 0x04 or 0x06  for broadcast content within scope of schedule.</td><td>N/A</td><td>Derived from language code(s) present in EIT/component descriptors with stream_content value 0x02, 0x04 or 0x06 for broadcast content within scope of schedule when the programme is recorded.</td><td>N/A</td></tr>
<tr><td><code>subtitleLanguages</code></td>
<td>Assigned by the terminal.</td><td>Derived from language code(s) present in EIT/component descriptors with stream_content value 0x03 for broadcast content within scope of schedule.</td><td>N/A</td><td>Derived from language code(s) present in EIT/component descriptors with stream_content value 0x03 for broadcast content within scope of schedule when the programme is recorded.</td><td>N/A</td></tr>
<tr><td><code>locked</code></td>
<td>Assigned by the terminal.</td><td>Set based on parental control information</td><td>N/A</td><td>Set based on parental control information</td><td>N/A</td></tr>
<tr><td><code>isManual</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>Set based on how the recording was scheduled &mdash; see the descriptions of the <a href="#oipfrecordingscheduler-record" class="apiRef">record()</a> and <a href="#oipfrecordingscheduler-recordat" class="apiRef">recordAt()</a> methods in section <a href="#application-oipfrecordingscheduler-methods" class="sectionRef"></a>.</td><td>N/A</td></tr>
<tr><td><code>doNotDelete</code></td>
<td>Assigned by the terminal or the application.</td><td>N/A</td><td>N/A</td><td>May be set by the terminal from a native UI, or by an application.</td><td>N/A</td></tr>
<tr><td><code>saveDays</code></td>
<td>Assigned by the terminal or the application.</td><td>N/A</td><td>N/A</td><td>May be set by the terminal from a native UI, or by an application.</td><td>N/A</td></tr>
<tr><td><code>saveEpisodes</code></td>
<td>Assigned by the terminal or the application.</td><td>N/A</td><td>N/A</td><td>May be set by the terminal from a native UI, or by an application.</td><td>N/A</td></tr>
<tr><td><code>is3D</code></td>
<td>Assigned by the terminal.</td><td>For MPEG-2 TS content with DVB-SI component_descriptor in SDT and/or EIT: True if the component_descriptor in EIT, or if not available, in SDT indicates a 3D video format, including values 0x80, 0x81, 0x82 or 0x83.</td><td></td><td>For MPEG-2 TS content with DVB-SI component_descriptor in SDT and/or EIT: True if the component_descriptor in EIT, or if not available, in SDT indicates a 3D video format, including values 0x80, 0x81, 0x82 or 0x83.</td><td></td></tr>
<tr><td><code>isEncrypted</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>Assigned and updated by the terminal as recording is carried out.</td><td>Derived from DRM specific data in content</td></tr>
<tr><td><code>DRMSystemIds</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>Assigned and updated by the terminal as recording is carried out.</td><td>Derived from DRM specific data in content</td></tr>
<tr><td><code>getDRMPrivateData</code></td>
<td>Assigned by the terminal.</td><td>N/A</td><td>N/A</td><td>Assigned and updated by the terminal as recording is carried out.</td><td>Derived from DRM specific data in content</td></tr>
</table>
<p>Where there are multiple language versions of a text field derived from DVB-SI tables, the terminal should select one in accordance with pre-defined user preferences.</p>
<p>The following table shows the mapping from the properties of Download and Recording class to the data carried inside the MPEG-2 TS and MP4 file format.</p>
<table class="simple">
<thead><tr style="vertical-align: top;">
<th>Property Name</th><th>MPEG-2 TS<br /><br />With DVB-SI component_descriptor in SDT and/or EIT</th><th>MPEG-2 TS<br /><br />Without DVB-SI SDT and EIT</th><th>MP4 FF<br /><br />CENC</th></tr>
</thead>
<tr><td><code>isEncrypted</code></td><td colspan="2">True if a CA_descriptor is present in the PMT:<ul>
<li>in the program information loop.
<li>or in a elementary stream information loop describing a stream.</ul>
Note: Some channels may have a static PMT but the content may not be encrypted. As the transport scrambling control bits in TS packet header are not checked, the property gives only an indication.</td><td>True, if the scheme type set to 'cenc' and scheme version set to 0x00010000 and default_isEncrypted set to 0x1 in the Track Encryption Box (see note 1)</td></tr>
<tr><td><code>DRMSystemIds</code></td><td colspan="2">CA_system_ID in CA_descriptors in the PMT</td><td>UUID in SystemID in the Protection System Specific Header box (see note 2 and note 3)</td></tr>
<tr><td><code>getDRMPrivateData</code></td><td colspan="2">Private data bytes in CA_descriptors in the PMT</td><td>Data in the Protection System Specific Header box</td></tr>
</table>
<p>NOTE 1: This specification does not handle the case where track common encryption information is overridden at sample level.</p>
<p>NOTE 2: the DRMSystemId retrieved from an 'cenc' protected file is by default an UID and returned as an UUID URN as defined in [[!RFC4122]]. For example "<code>urn:uuid:706D6953-656C-5244-4D48-656164657221</code>".</p>
<p>NOTE 3: When the UUID is referring to a DRM managed by the OITF, the <code>DRMSystemId</code> and <code>getDRMPrivateData()</code> mapping may be overridden. For example Marlin uses the UUID &ldquo;<code>urn:uid:69F908AF-238 4816-46EA-910C-CD5DCCCB0A3A</code>&rdquo; in 'cenc' protected files. This UUID should be mapped to the OIPF DRMSystemID for Marlin, i.e. &ldquo;<code>urn:dvb:casystemid:19188</code>&rdquo;</p>
</section>
<section>
<h3>Exposing Audio Description streams as AVComponent objects</h3>
<p>Section <a href="#extensions-for-playback-of-selected-media-components" class="sectionRef"></a> defines the AVComponent class and the <code>AVAudioComponent</code> class, which defines various properties to describe the audio stream, and section <a href="#mapping-apis-to-content-formats-avcomponent" class="sectionRef"></a> provides information on how these properties are populated. This includes an <code>audioDescription</code> boolean property which is set to true for audio streams that contain an audio commentary for the people with a visual impairment. Audio description (AD) streams which contain such commentary may be delivered to the terminal as either broadcast mix or receiver mix (see TS 101 154 [[!TS101154]] Annex E for more information on how this is done for MPEG2-TS streams).</p>
<p>Audio streams without audio description and audio streams with broadcast mix audio description SHALL be exposed to the application using one <code>AVAudioComponent</code> object per audio stream. Broadcast mix audio description streams SHALL have the <code>audioDescription</code> property set to true.</p>
<p>Receiver mix audio description streams have to be mixed in the terminal with a main audio stream. There may be multiple main audio streams and multiple receiver mix audio descriptions streams. The supported combinations of main audio stream and receiver mix audio description stream SHALL be determined by the OITF . Each combination SHALL be exposed to the application as a separate <code>AVAudioComponent</code> object. The properties of this object SHALL be set as follows:</p><ul>
<li><code>audioDescription</code> SHALL be set to <code>true</code>.
<li><code>language</code> SHALL be set to the language of the audio description stream.
<li><code>audioChannels</code> SHALL be set to the number of audio channels in the combined stream.
<li><code>encrypted</code> SHALL be set to <code>true</code> if either constituent stream is encrypted.
<li><code>componentTag</code> and <code>pid</code> SHALL be set according to the main audio stream.
<li><code>type</code> SHALL be set to <code>COMPONENT_TYPE_AUDIO</code>.
<li>If the encoding of the constituent streams is the same, then <code>encoding</code> SHALL be set accordingly otherwise it SHALL be <code>undefined</code>.
</ul>
<p>Receiver mix audio description streams SHALL NOT be exposed to applications as separate <code>AVAudioComponent</code> objects.</p>
</section>
<section>
<h3>HTML5 Media Element Mapping</h3>
<p>The following table defines the mapping that SHALL be used between the HTML5 AudioTrack and the MPEG-2 transport stream and ISO BMFF system layers.</p>
<table class="simple">
<thead>
<tr><th rowspan="2">Attribute</th><th rowspan="2">Summary</th><th colspan="3">SystemLayer</th></tr>
<tr><th>MPEG-2 TS</th><th>ISO BMFF</th><th>MPEG DASH</th></tr>
</thead>
<tr><td><code>readonly attribute DOMString id;</code></td><td>Identifier of the track</td><td>The contents of the component_tag field in the stream_identifier_descriptor in PMT.</td><td>track_id</td><td>The value of the id attribute in the AdaptationSet (if provided)</td></tr>
<tr><td><code>readonly attribute DOMString kind;</code></td><td>Category of the track</td><td>&ldquo;&rdquo; unless the audioDescription property of an AVComponent instance for this track would be set to true in which case &ldquo;description&rdquo;.</td><td>&ldquo;&rdquo;</td><td>As defined in the HTML5 specification as referenced by [[.OIPF_WSTVP2]]</td></tr>
<tr><td><code>readonly attribute DOMString label;</code></td><td>Label of the track</td><td>&ldquo;&rdquo;</td><td>&ldquo;&rdquo;</td><td>&ldquo;&rdquo;</td></tr>
<tr><td><code>readonly attribute DOMString language;</code></td><td>Language of the track </td><td colspan="3">The primary language subtag in the BCP47 string SHALL be set as defined in section <a href="#mapping-apis-to-content-formats-avcomponent" class="sectionRef"></a> above for the language property of AVComponent.</td></tr>
<tr><td><code>attribute boolean enabled;</code></td><td>Is the track enabled</td><td colspan="3">No mapping is appropriate</td></tr>
</table>
</section>
</section>
<section id="dlna-rui-rcf-implementation">
<h2>DLNA RUI Remote Control Function implementation</h2>
<p>This section aims to give guidelines to the DAE application developer suggesting how the DAE application should be implemented to use a DLNA Remote UI Function, covering the following areas:</p><ul>
<li>Relationship between DAE application and control UI
<li>XML UI Listing Provisioning
<li>Retrieving the Control UI
<li>Receiving a message (control command) from the Remote Control Device and Responding to a message from the Remote Control Device
<li>Notification to the Remote Control Device
<li>Multiple application handling</ul>
<p>The sections below provide more details including example code in each case.</p>
<section>
<h3>Relationship between DAE application and control UI</h3>
<p>It is assumed that the service provider authors both the DAE application and the control UI to run on the Remote Control Device that communicates with the DAE application. It means that the DAE application and the control UI are managed by one service provider, and the DAE application could handle the HTTP request message which comes from the control UI currently being rendered in the DLNA RUIC.</p>
</section>
<section>
<h3>XML UI Listing Provisioning</h3>
<p>There are two kinds of XML UI Listing (details are described in section 5.1.1.5 of [[!CEA-2014-A]]):</p> <ul>
<li>The OITF's built in XML UI Listing, that originates from the OITF (DLNA RUIS) and which is usually pre-defined by the device vendor, 
<li>The Server Side XML UI Listing, that is provided by the DAE application and which is defined by the service provider.
</ul>
<p>Below is a description of where each type of XML UI Listing comes from.</p>
<figure>
<img src="images/DLNA-RUI-RCF-1.png" alt="DLNA-RUI-RCF-1.png"/>
</figure>
<ul>
<li>OITF's built in XML UI Listing (blue arrow in above diagram):<ul>
<li>This XML UI Listing contains a set of URI pre-defined by the OITF corresponding to a number of Control UIs that are available in the OITF device itself.
<li>The OITF SHALL use this XML UI Listing until a DAE application calls the <code>useServerSideXMLUIListing()</code> method.</ul>
<li>Server Side XML UI Listing (red arrows in above diagram):<ul>
<li>This XML UI Listing contains both the URIs which identify the control UIs located on the appropriate IPTV Applications server through the pre-defined URI &ldquo;<code>/rcf/request_cui</code>&rdquo;.
<p>Examples: <code>/rcf/request_cui?url=www.cui-server.com/avcontrol.html&amp;param1=value1...</code></p>
<p>The XML UI Listing is retrieved (or created dynamically) by a DAE application, which then merges the new XML UI Listing with a current XML UI Listing in the DLNA RUIS using the <code>useServerSideXMLUIListing()</code> method. The merged XML UI Listing will be located in the DLNA RUIS.</p>
<p>The OITF SHALL associate all entries in the XML UI Listing added by a DAE application with that application, such that any HTTP requests from a Remote Control Device for the control UI specified by the XML UI Listing entry SHALL be passed to the corresponding application.</p>
<p>All URIs provided in the XML UI Listing SHALL start with the pre-defined URI &ldquo;<code>/rcf/request_cui</code>&rdquo;, which can then be followed by some application-specific parameters. These parameters can be used by the DAE application to identify the Control UI being requested by the Remote Control Device.</p>
<p>The format of the parameters in the URI is out of scope of the DAE specification.</p>
<li>When the DAE application is terminated, the OITF SHALL remove any XML UI Listings previously added by the application. </ul>
</ul>
<p>The following example shows the format of the Server Side XML UI Listing. The &lt;uri&gt; element in the Server Side XML UI Listing SHALL start with the value  &ldquo;<code>/rcf/request_cui</code>&rdquo;.</p>
<pre class="xml-document">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;uilist xmlns="urn:schemas-upnp-org:remoteui:uilist-1-0" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="urn:schemas-upnp-org:remoteui:uilist-1-0 CompatibleUIs.xsd"&gt;
  &lt;ui&gt;
    &lt;uiID&gt;4560-9876-1265-8758&lt;/uiID&gt;
    &lt;name&gt;CoD Control UI Type 1&lt;/name&gt;
    &lt;description&gt;Controlling the CoD contents&lt;/description&gt;
    &lt;protocol shortName="CE-HTML-1.0"&gt;
      &lt;uri&gt;/rcf/request_cui?url=http://21.31.24.55:5910/codcui1&lt;/uri&gt;
      &lt;protocolInfo&gt;
        &lt;relatedData xmlns="urn:schemas-ce-org:ce-html-server-caps-1-0" 
            xsi:schemaLocation="urn:schemas-ce-org:ce-html-server-caps-1-0 ServerProfiles.xsd"&gt;
          &lt;profilelist&gt;
            &lt;ui_profile name="MD_UIPROF"/&gt;
          &lt;/profilelist&gt;
        &lt;/relatedData&gt;
      &lt;/protocolInfo&gt;
    &lt;/protocol&gt;
  &lt;/ui&gt;
  &lt;ui&gt;
    &lt;uiID&gt;2123-3679-3568-2121&lt;/uiID&gt;
    &lt;name&gt;CoD Control UI Type 2&lt;/name&gt;
    &lt;protocol shortName="CE-HTML-1.0"&gt;
      &lt;uri&gt;/rcf/request_cui?url=http://21.31.24.55:5910/codcui2&lt;/uri&gt;
      &lt;protocolInfo&gt;
        &lt;relatedData xmlns="urn:schemas-ce-org:ce-html-server-caps-1-0"&gt; 
          &lt;profilelist&gt;
            &lt;ui_profile name="MD_UIPROF"/&gt;
          &lt;/profilelist&gt;
        &lt;/relatedData&gt;
      &lt;/protocolInfo&gt;
    &lt;/protocol&gt;
  &lt;/ui&gt;
&lt;/uilist&gt;
</pre>
<p>Below is example source code showing how an application can merge a Server Side XML UI Listing that it has retrieved with the OITF's built-in XML UI Listing.</p>
<pre  class="javascript">
var rcMgr;
var xmlhttp;

function init() {
    ...
    rcMgr = document.getElementById("rcfmanager");
    retrieveXMLUIListingFromServer("/iptv_app/xml_location/request_xml?xml=31",
                                   mergeXMLUIListing);
    ...
}

function retrieveXMLUIListingFromServer(url, callbackFunc) {
    xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4) {
            if(xmlhttp.status == 200){
                callbackFunc(xmlhttp.responseText);
            }
        }
    }
    xmlhttp.open("GET", url, true);
    xmlhttp.send(null);
}

function mergeXMLUIListing(xmluilisting) {
    rcMgr.useServerSideXMLUIListing(xmluilisting, false);
}
&lt;body onload="init();"&gt;
&lt;object id="rcfmanager" type="application/oipfRemoteControlFunction"/&gt;
...
</pre>
</section>
<section>
<h3>Retrieving the Control UI</h3>
<p>The process of retrieving a Control UI based on an OITF's built in XML UI Listing is described below:</p><ul>
<li>The Remote Control Device sends the request to the DLNA RUIS for the XML UI Listing.
<li>The Remote Control Device presents a UI based on the information in the XML UI Listing. The user selects an entry from the list.
<li>The Remote Control Device sends the HTTP request containing the URI (which has been specified by the OITF itself) to the DLNA RUIS. The OITF returns the Control UI (from its internal memory).
<li>The Remote Control Device presents the Control UI. This Control UI may be an application itself or may be a list of other available applications. In the latter case, the user selects a link from the Control UI.
<li>The Remote Control Device sends the HTTP request containing the URI from the selected link to the DLNA RUIS. The OITF retrieves the DAE application from the IPTV Applications server and executes it.
<li>The DAE application recognises that it needs to get the control UI.
<li>The DAE application retrieves the Control UI from the IPTV Applications server.
<li>The DAE application passes the Control UI received from the IPTV Applications server to the Remote Control Device.
</ul>
<p>The process of retrieving a Control UI based on a Server Side XML UI Listing is as below:</p><ul>
<li>The Remote Control Device sends the request to the DLNA RUIS for the XML UI Listing.
<li>The Remote Control Device presents a UI based on the information in the XML UI Listing. The user selects an entry from the list.
<li>The Remote Control Device sends the HTTP request containing the URI (which must start with &ldquo;<code>/rcf/request_cui</code>&rdquo;) to the OITF DLNA RUIS. The OITF matches the URI with the correct DAE application and passes the request to that DAE application as a ReceiveRemoteMessage event.
<li>The DAE application translates the request which came from the Remote Control Device into a URI.
<li>The DAE application retrieves the Control UI from the IPTV Applications server using this URI.
<li>The DAE application passes the Control UI received from the IPTV Applications server to the Remote Control Device using <code>sendRemoteMessage()</code>.
</ul>
<p>More details can be found in Annex <a href="#dlna-rcf-sequences" class="sectionRef"></a>.</p>
<p>When the control UI (CE-HTML document) is being rendered in the Remote Control Device, it can retrieve resources (For example, image, css or JavaScript files) directly from the IPTV Applications server over a secure connection. For deployments where the IPTV Applications server is outside the consumer network, the consumer network's WAN gateway SHALL allow the DLNA RUIC to access the IPTV Applications server to retrieve resources directly. The Remote Control Device that connects to the IPTV Applications server SHALL implement the Secure Sockets Layer (SSL) Protocol, the Transport Layer Security (TLS) and the &ldquo;https:&rdquo; URI scheme, in order to support secure Internet transactions (as defined in section <a href="#ssl-ttls-requirements" class="sectionRef"></a>).</p>
<p>Below is example source code to show sending the control UI to the Remote Control Device.</p>
<pre class="javascript">
var rcMgr;
var xmlhttp;
var deviceHandle;
var reqHandles = new Array();

function init() {
    ...
    rcMgr = document.getElementById("rcfmanager");
    rcMgr.addEventListener("ReceiveRemoteMessage", receiveRemoteMessageFromRD, false);
    
    // check whether the DAE app is launched by the Remote Control Device or not
    if (rcMgr.currentRemoteDeviceHandle != undefined) {
    	deviceHandle = rcMgr.currentRemoteDeviceHandle;
    	retrieveCUIFromServer("/iptv_applications/cui_location/request_cui?cui=123",
    		sendCUIToRemoteDevice);
    }
    ...
}

function retrieveCUIFromServer(url, callbackFunc){
    xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4) {
            if(xmlhttp.status == 200){
                callbackFunc(xmlhttp.responseText);
            }
        }
    }
    xmlhttp.open("GET", url, true);
    xmlhttp.setRequestHeader("X-OITF-RCF-User-Agent",
                             rcMgr.getRemoteDeviceUserAgent(deviceHandle));
    xmlhttp.send(null);
}

function sendCUIToRemoteDevice(cuiCEHTML) {
    rcMgr.sendRemoteMessage(remoteDeviceHandle, reqHandles.shift(), cuiCEHTML);
}

function receiveRemoteMessageFromRD(type, remoteDeviceHandle, reqHandle, requestLine, headers, body) {
    if (type == 0) {
    	deviceHandle = remoteDeviceHandle;
    	reqHandles.push(reqHandle);
        
        // retrieve the CUI CE-HTML document from the IPTV Applications server
        retrieveCUIFromServer("/iptv_applications/cui_location/request_cui?cui=123", 
                              sendCUIToRemoteDevice);
    }
}
&lt;body onload="init();"&gt;
&lt;object id="rcfmanager" type="application/oipfRemoteControlFunction"/&gt;
...
</pre>
</section>
<section>
<h3>Receiving and responding a message between the control UI in the Remote Control Device and OITF</h3>
<figure><img src="images/DLNA-RUI-RCF-2.png" alt="DLNA-RUI-RCF-2.png"/></figure>
<p>This example shows the usage of receiving and responding to a message between the control UI presented on the Remote Control Device and the OITF. When the control UI sends a message to the DAE application via an HTTP request, the DAE application receives the message via a ReceiveRemoteMessage event. The DAE application SHALL return the response to the control UI in the Remote Control Device by using the sendRemoteMessage() or sendInternalServerError() methods. </p>
<p>The OITF is not able to notify the Remote Control Device whether the DAE application has been terminated or deactivated, or whether the application/oipfRemoteControlFunction object has been removed from the application's DOM tree. For this reason, the Remote Control Device may be presenting an outdated copy of the control UI and could send a request from this outdated control UI. In this case, the OITF SHALL return a 500 response error code to the Remote Control Device.</p>
<p>The OITF SHALL limit the number of HTTP requests (from the control UI in the Remote Control Device) which have not been responded to by the DAE application. If there are any requests over this limit, the OITF SHALL automatically reject them and send an HTTP response (HTTP 500 - Internal Server Error) to the Remote Control Device. The OITF SHALL buffer at least 10 outstanding HTTP requests.</p>
<p>NOTE: Annex <a href="#messages-between-rcd-and-dae" class="sectionRef"></a> provides a procedure related to this example.</p> 
<p>Below is example source code showing the handling of messages between the DAE application and the control UI that controls the DAE application.</p>
<p><b>DAE application</b></p><pre class="javascript">
var rcMgr;
var reqHandles = new Array();

function init() {
    ...
    rcMgr = document.getElementById("rcfmanager");
    rcMgr.addEventListener("ReceiveRemoteMessage", getMessageFromRD, false);
    ...
}

function getMessageFromRD(type, remoteDeviceHandle, reqHandle, requestLine, headers, body) {
    if (type == 1) {
        // Handling the received message with parameters (requestLine, headers, body)
        parseAndExecute(body);
            
        // Sending the proper return message to the Remote Control Device
        Var contentType = "Content-Type: text/plain\n"
        rcMgr.sendRemoteMessage(remoteDeviceHandle, reqHandle, contentType, "ok");
    }
}

function parseAndExecute(body) {
    //For example, the request from the RD contains the message related to
    //"play of audio" with JSON form (Ex: {'command':415})
    var retVal = eval("("+body+")");
    if (retVal.command == VK_PLAY) {
        document.getElementById("aid1").play(1);
    }
}

&lt;body onload="init();"&gt;
&lt;object id="rcfmanager" type="application/oipfRemoteControlFunction"/&gt;
&lt;object type="audio/mp4" id="aid1" data="http://www.avsource.com/audio/bgm.aac"&gt;
&lt;param name="loop" value="infinite"/&gt;
&lt;/object&gt;
...
</pre>
<p><b>Control UI</b></p><pre class="javascript">
var xmlhttp;

function sendPlay() {
    var msg = {'command':415};
    sendMessage("/rcf/request_msg", msg, receiveMsg);
}

function sendMessage(url, msg, callbackFunc){
    xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4) {
            if(xmlhttp.status == 200){
                callbackFunc(xmlhttp.responseText);
            }
        }
    }
    xmlhttp.open("POST", url, true);
    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xmlhttp.send(msg);
}

function receiveMsg(msg) {
    alert("Received message from the DAE application: " + msg);
}
&lt;body&gt;
...
&lt;input type="button" value="Play" onclick="javascript:sendPlay();"&gt;
...
</pre>
</section>
<section>
<h3>Notification to the Remote Control Device</h3>
<p>The <code>application/oipfRemoteControlFunction</code> object supports generating 3<sup>rd</sup> party multicast notifications and dispatching them to Remote Control Devices. The DAE application can make and send a notification to the Remote Control Devices by using the <code>sendMulticastNotif()</code> method. </p>
<p>If the DAE application wants to send a notification CE-HTML document to all of the Remote Devices, the DAE application SHALL set the remoteDeviceHandle parameter in the <code>sendMulticastNotif</code> method to -1.</p>
<p>Otherwise, if the DAE application wants to allow only targeted Remote Device (currently being connected to the DAE application) to retrieve the notification CE-HTML document, the DAE application set the proper <code>remoteDeviceHandle</code> parameter in the <code>sendMulticastNotif</code> method when it calls. Then, the OITF SHALL generate the notification URI with <code>devicehandle</code> and <code>daeid</code> parameters.</p>
<p>If the DAE application wants to send a notification CE-HTML document without storing it in the OITF, the DAE application executes the sendMulticastNotif method with null value in the <code>notifCEHTML</code> parameter. The OITF SHALL make the notification URI which contains a dynamic parameter with true value, otherwise false is set in the dynamic parameter.</p>
<p>Below is a generated notification URI based on parameter information in the <code>sendMulticastNotif</code> method.</p>
<pre>?SendToTargetedRD&amp;devicehandle=&lt;target device handle value&gt;&amp;daeid=&lt;DAE App ID&gt;&amp;dynamic=&lt;true or false&gt;</pre>
<p>This URL is sent to the Remote Devices through the <code>&lt;ruiEventURL&gt;</code> element of the multicast notification event and the Remote Devices send requests to the OITF with this URL upon receiving it. When the OITF receives the requests from the Remote Devices, it SHALL return the notification CE-HTML document in case the handle of the Remote Device which sends the request is the same with the parameter value &ldquo;&lt;target device handle value&gt;&rdquo; in the HTTP request URL, otherwise the OITF SHALL return the HTTP 403 response.</p>
<p>Below is example source code to show that the only targeted Remote Device retrieves the notification CE-HTML document.</p>
<pre class="javascript">var rcMgr;
var xmlhttp;
var deviceHandle;
var reqHandles = new Array();

function init() {
    ...
    rcMgr = document.getElementById("rcfmanager");
    rcMgr.addEventListener("ResultMuticastNotif", resultMuticastNotifFromRD, false);
    ...
}

function sendTargetedNotif() {
    // A remoteDeviceHandle SHALL be set to -1 if the OITF wants to send the
    // notification CE-HTML UI to all of the Remote Devices
    // A remoteDeviceHandle SHALL be set to a specific value of the device handle if 
    // the OITF wants to send the notification CE-HTML UI to the targeted 
    // Remote Control Devices
    var remoteDeviceHandle = rcMgr.currentRemoteDeviceHandle;
    var eventLevel = 0;
    var notifCEHTML = "&lt;html&gt;...&lt;/html&gt;";
    var friendlyName = "Important notification";
    var profilelist = "&lt;ui_profile name='MD_UIPROF'/&gt;";
    
    rcMgr.sendMulticastNotif(remoteDeviceHandle , eventLevel, notifCEHTML, 
                             friendlyName, profilelist);
}

function resultMuticastNotifFromRD(remoteDeviceHandle, reqHandle, dynamic) {
    if (dynamic != true) {
        alert("Notification is sent to the Remote Control Device well");
    } else {
        //Retrieve a notifcation CE-HTML UI from server
        ...
    }
}

&lt;body onload="init();"&gt;
&lt;object id="rcfmanager" type="application/oipfRemoteControlFunction"/&gt;
...
</pre>
</section>
<section>
<h3>Handling Multiple DAE applications and Multiple Remote Control Devices</h3>
<p>The OITF SHALL dispatch requests from a Remote Control Device to the DAE application that it is currently controlling.  Only one Remote Control Device SHALL communicate with a DAE application at any time although this could change over time as described below.</p><ul> 
<li>Multiple Remote Devices SHALL not be mapped to a same DAE application at the same time. If a second Remote Control Device attempts to send an HTTP request to a DAE application which is already mapped to a different Remote Control Device, this request SHALL fail (the OITF sends an HTTP 500 response to the Remote Control Device). 
<li>One Remote Device SHALL not be mapped to multiple DAE applications at the same time. If a Remote Device is currently connected to a DAE application and then attempts to make a request to another DAE application, this request SHALL fail (the OITF sends an HTTP 500 response to the Remote Device).</ul>
<p>The OITF SHALL support three mechanisms to drop the connection between a Remote Control Device and a DAE application as follows:</p><ul>
<li>The Remote Control Device currently bound to the DAE application sends a pre-defined URL &ldquo;<code>/rcf/drop_connection</code>&rdquo;.
<li>The DAE application drops the connection with the Remote Control Device by using the <code>dropConnection()</code> method.
<li>The OITF provide a timer mechanism to drop the connection with the Remote Control Device after a period of inactivity (i.e. no HTTP requests received and no HTTP responses sent). The value of the inactivity timer expiry is terminal specific. One timer will be assigned per Remote Control Device.</ul>
<p>If the OITF is unable to dispatch requests to that application (e.g. because the application has terminated or because the <code>application/oipfRemoteControlFunction</code> object has been destroyed), the request SHALL fail (the OITF sends an HTTP 500 response to the Remote Control Device). If the OITF is notified that the Remote Control Device is no longer connected to the network, then the OITF SHALL allow other Remote Control Devices to connect to the application and assume control.</p>
<p>]Below is example showing a mapping relationship between Remote Control Devices and DAE applications.</p><ul>
<li>Remote Control Device 1 is mapped to DAE application A. The Remote Control Device sends a request to drop the connection with A, using the pre-defined URL &ldquo;<code>/rcf/drop_connection</code>&rdquo; and then makes a request to DAE application B. DAE application B responds to the Remote Control Device. The OITF updates its internal state to show that Remote Control Device 1 is now mapped to DAE application B.
<figure><img src="images/DLNA-RUI-RCF-3.png" alt="DLNA-RUI-RCF-3.png"/></figure>
<li>Remote Control Device 2 is mapped to DAE application C. A second Remote Control Device 3 then makes a request to DAE application C. The OITF sends an HTTP 500 response to the Remote Control Device 3.
<figure><img src="images/DLNA-RUI-RCF-4.png" alt="DLNA-RUI-RCF-4.png"/></figure>
</ul>
</section>
</section>
</section>


<!-- section 9 -->
<section id='dae-capabilities'>
<h1>Capabilities</h1>
<section id="minimum-dae-capabilities">
<h2>Minimum DAE capability requirements</h2>
<p>This section defines minimum capabilities which OITF implementations are required to provide to the Declarative Application Environment and the applications running in that environment.</p>
<p>The following section defines minimum capabilities which SHALL apply to all OITFs.</p>
<p>OITFs MAY support multiple simultaneous applications loaded and running in the browser.</p>
<p>When the CEA-2014 notification framework (see section <a href="#CEA2014-notifications" class="sectionRef"></a>) is supported, OITFs SHALL support at least 2 DAE applications being visible at one time, one application showing a notification in the notification window (as defined in section 5.6.3 of [[!CEA-2014-A]]) and one in the main browser area. OITFs MAY support more than one DAE application being visible at one time in the main browser area. On OITFs where only one DAE application is visible at one time in the main browser area, it is OITF implementation specific how the visible application is changed. </p>
<p>OITFs with an HD output SHALL support 1280x720 graphics on that output when HD video is being decoded or when no video is being decoded. OITFs MAY support 1920x1080 graphics.</p>
<p>The present document does not define any requirements concerning support for SD graphics.</p>
<p>OITFs SHALL support unrestricted scaling of IP delivered video.</p>
<p>The present document does not define any requirements for scaling of video not delivered via IP, e.g. in hybrid OITFs. </p>
<p>The present document does not define requirements for supporting decoder format conversion.</p>
<p>The present document does not define requirements for pixel depth in the graphics system except that OITFs SHALL support at least one bit of per-pixel alpha.</p>
<p>The present document does not require the capability to mix audio from memory and audio from a currently decoded stream.</p>
<p>OITFs SHALL support decoding one stream containing video and audio. They MAY support decoding more than one stream. </p>
<p>The OITF SHALL support widgets that are least of 100k bytes. Widgets of larger size are allowed but the specification remains silent as to the maximum allowed size. When installing a widget with method <a href="#oipfApplicationManager-installwidget" class="apiRef">installWidget()</a> an error message WIDGET_ERROR_SIZE_EXCEEDED is returned if the size is exceeded. OITFs SHALL support the &ldquo;Tiresias Screenfont&rdquo; font or equivalent with the &ldquo;Generic Application Western European Character Set&rdquo; as defined in Annex C of [[!TS102809]]. They MAY support other fonts in addition.</p>
<p>OITFs SHALL provide some means for text input. The present document does not specify any particular solution.</p>
<p>The present document recommends support for pointer based input. The present document does not define requirements for minimum memory sizes for DAE applications or OITF behaviour when available memory is low. This specification is deliberately silent about the conditions under which the <code>LowMemory</code> event defined in section <a href="#application-oipfApplicationManager-events" class="sectionRef"></a> is generated.</p>
<p>OITFs SHALL follow [[!RFC6265]] when implementing cookies support. </p>
<p>Since <a href="http://tools.ietf.org/html/rfc6265#section-6.1" class="extRef">section 6.1</a> of [[!RFC6265]] does not fix strict limits, this specification fix the following minimum capabilities that terminals SHALL support:</p><ul>
<li>At least 4096 bytes per cookie (as measured by the sum of the length of the cookie's name, value, and attributes).
<li>At least 20 cookies per domain
<li>At least 100 cookies total
<li>At least 5120 bytes for the &ldquo;Set-Cookie&rdquo; header
</ul>
<p>NOTE: as implied by [[!RFC6265]], if a cookie or a "Set-Cookie" header is bigger than the maximum size supported by the terminal, it will be discarded, not truncated.</p>
<p>The present document does not require control of audio volume to be exposed to the DAE.</p>
<p>The OITF SHALL include a mechanism for the end user to generate the following key events:</p><ul>
<li><code>VK_0</code> &mdash; <code>VK_9</code>
<li><code>VK_UP</code>, <code>VK_DOWN</code>, <code>VK_LEFT</code>, <code>VK_RIGHT</code>, <code>VK_ENTER</code>, <code>VK_BACK</code>
<li><code>VK_RED</code>, <code>VK_GREEN</code>, <code>VK_YELLOW</code>, <code>VK_BLUE</code>
</ul>
<p>An OITF SHALL support the entry of at least a complete set of characters in the range of characters [A-Z], or [a-z] (or both), plus the characters [0-9], plus the characters: space ( ), period (.), comma (,) question-mark (?), exclamation-mark (!), at (@), colon (:), semi-colon(;), left-bracket ((), right-bracket()), slash(/), minus-sign (-), plus sign (+) and underscore (_), for the <a href="http://www.w3.org/TR/html5/forms.html#the-textarea-element" class="extRef"><code>textarea</code></a> element and the <a href="http://www.w3.org/TR/html5/forms.html#the-input-element" class="extRef"><code>input</code></a> element (taking account of the restrictions defined for the different types of that element).</p>
<p>An OITF may also supported a pointer-based interaction paradigm. Terminals that support a free moving cursor SHALL indicate this using the via the &ldquo;+POINTER&rdquo; UI Profile Name Fragment as specified in section <a href="#default-ui-profiles" class="sectionRef"></a> and hence SHALL include &lt;pointer&gt;true&lt;/pointer&gt; in their XML capabilities.</p>
<p>To provide a good user experience with the widest range of user input devices, DAE applications SHOULD make the same feature, function or link accessible via physical keys on the remote also accessible through an element in their user interface which can be navigated to i) by up, down, left and right (e.g. on a remote control with a very restricted number of buttons) and ii) by a pointer device controlling a free moving cursor on the screen. </p>
<p>If the OITF includes a mechanism to generate the following key events then they SHALL be available to DAE applications and SHALL be indicated as part of the capability mechanism defined in section <a href="#dae-capabilities" class="sectionRef"></a> of this specification:</p><ul>
<li><code>VK_PLAY</code>, <code>VK_PAUSE</code>, <code>VK_STOP</code>, <code>VK_NEXT</code>, <code>VK_PREV</code>
<li><code>VK_PLAY_PAUSE</code>
<li><code>VK_FAST_FWD</code>
<li><code>VK_REWIND</code>
</ul>
<p>NOTE: Some remote controls have separate &ldquo;play&rdquo; and &ldquo;pause&rdquo; keys; others have a single &ldquo;play/pause&rdquo; toggle key. For that reason, in general, it is recommended that applications are written to handle both the <code>VK_PLAY</code>/<code>VK_PAUSE</code> key codes and the <code>VK_PLAY_PAUSE</code> key code. </p>
<p>The OITF MAY include mechanisms to generate the following key events and if it does, making them available to DAE applications is OPTIONAL:</p><ul>
<li><code>VK_HOME</code>
<li><code>VK_MENU</code>
<li><code>VK_GUIDE</code>
<li><code>VK_TELETEXT</code>
<li><code>VK_SUBTITLE</code>
<li><code>VK_CHANNEL_UP</code>
<li><code>VK_CHANNEL_DOWN</code>
<li><code>VK_VOLUME_UP</code>
<li><code>VK_VOLUME_DOWN</code>
<li><code>VK_MUTE</code>
</ul>
<p>Where OITFs make other remote control key events available to DAE applications, this SHALL be done as specified by the capability mechanism defined in section <a href="#dae-capabilities" class="sectionRef"></a> of this specification. Whenever applicable, this SHOULD be done using the complementary UI profiles defined in section <a href="#default-ui-profiles" class="sectionRef"></a>. </p>
<section id="ssl-ttls-requirements">
<h3>SSL/TTLS Requirements</h3>
<section id="ssl-tls-support">
<h4>SSL/TLS Support</h4>
<p>HTTP over TLS as defined in RFC 2818 [[!RFC2818]] and RFC 5246 [[!RFC5246]] SHALL be supported for transporting application files over broadband. </p>
<p>TLS 1.2 ([[!RFC5246]]) SHOULD be supported for HTTP over TLS, if not then TLS 1.1 ([[!RFC4346]]) SHOULD be supported instead and if neither of those is supported then TLS 1.0  ([[!RFC2246]]) SHALL be supported instead.</p>
<p><i>NOTE: TLS 1.2 provides a much higher security level than TLS 1.0 and 1.1 so manufacturer are recommended to support it. Note also that TLS 1.0 and 1.1 are obsoleted by the TLS 1.2 specification. It is expected that future versions of the present document will require support for TLS 1.2 and omit the possibility of only supporting TLS 1.0 or 1.1.</i></p>
<p>In order to fix a known vulnerability in SSL and TLS renegotiation, an OITF SHALL support the Renegotiation Indication Extension as specified in [[!RFC5746]] for all TLS versions.</p>
<p>An OITF SHALL deem a TLS connection to have failed if any of the following conditions apply:</p><ul>
<li>Certificate chain fails validation as per RFC 5280 [[!RFC5280]] <a href="http://tools.ietf.org/html/rfc5280#section-6" class="extRef">section 6</a>.
<li>The host name or IP address contained in the server certificate does not match the host name or IP address requested. When verifying the host name against the server-supplied certificate, the '*' wildcard and the subjectAltName extension of type dNSName shall be supported as defined in RFC 2818 [[!RFC2818]].
</ul>
<p>An OITF SHALL not provide the user with an option to bypass these conditions.</p>
</section>
<section>
<h4>Cipher Suites</h4>
<p>An OITF SHALL support the following cypher suites for all TLS versions:</p><ul>
<li><code>TLS_RSA_WITH_3DES_EDE_CBC_SHA</code>
<li><code>TLS_RSA_WITH_AES_128_CBC_SHA</code>
<li><code>TLS_RSA_WITH_AES_256_CBC_SHA</code>
<li><code>TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA</code>
</ul>
<p>An OITF SHALL NOT support 'anonymous' cipher suites for TLS connections.</p>

</section>
<section>
<h4>Root Certificates</h4>
<p>A list of root certificates is maintained at <a href="http://www.oipf.tv/root-certificates">http://www.oipf.tv/root-certificates</a>. The policy by which this list has been derived is outlined in Annex <a href="#server-root-certificates" class="sectionRef"></a>.</p>
<p>An OITF SHALL trust all root certificates identified as mandatory and MAY support those certificates identified as optional on that list, subject to the conditions in this section.</p>
<p>An OITF SHOULD not trust any other root certificates.</p>
<p>Note: Including root certificates that are not on the list increases the risk of a man in the middle attack if those root certificates have not been audited to a similar or greater level than those on the list. </p>
<p>An OITF SHALL cease to trust any root certificates with RSA keys of less than 2048 bits after 31st December 2013.</p>
<p>An OITF SHALL support a means by which the device manufacturer can remove or distrust root certificates after manufacture. This MAY be handled either via a firmware upgrade mechanism or preferably via a specific root certificate update mechanism that could allow more timely updates.</p>
<p>A manufacturer MAY choose to remove or distrust a mandatory root certificate in the OITF in response to a security threat.</p>
<p>An OITF SHOULD support a means of securely adding new root certificates after manufacture in order to maintain interoperability with servers over time.</p>
</section>
</section>
</section>
<section id="default-ui-profiles">
<h2>Default UI profiles</h2>
<p>The OITF SHALL support at least one of the UI-related base profiles defined in Table <a href="#base-ui-profile-names" class="tableRef"></a>.</p>
<table class="simple" id="base-ui-profile-names">
<caption>Table ####: Base UI Profile Names</caption>
<thead><tr><th>Base UI Profile Name</th><th>Default values</th></tr></thead>
<tr><td>"<code>OITF_SDEU_UIPROF</code>"</td><td>
<p>&lt;width&gt;720&lt;/width&gt;</p>
<p>&lt;height&gt;576&lt;/height&gt;</p>
<p>&lt;colors&gt;high&lt;/colors&gt;</p>
<p>&lt;hscroll&gt;false&lt;/hscroll&gt;</p>
<p>&lt;vscroll&gt;true&lt;/vscroll&gt;</p>
<p>&lt;font type="sans-serif" defaultsize="16"&gt;Tiresias&lt;/font&gt; with support for the Unicode character range &ldquo;Generic Application Western European Character set&rdquo; as defined in Annex C of [[!TS102809]].</p>
<p>&lt;key&gt;VK_BACK&lt;/key&gt;</p>
<p>&lt;colorkeys&gt;true&lt;/colorkeys&gt;</p>
<p>&lt;navigationkeys&gt;true&lt;/navigationkeys&gt;</p>
<p>&lt;numerickeys&gt;true&lt;/numerickeys&gt;</p>
<p>&lt;pointer&gt;false&lt;/pointer&gt;</p>
<p>&lt;security protocolNames="ssl tls"&gt;true&lt;/security&gt;</p>
<p>&lt;overlay&gt;per-pixel&lt;/overlay&gt;&lt;!-- whereby at least one level of partial transparency between graphics and video must be supported as per the minimum requirements of section <a href="#minimum-dae-capabilities" class="sectionRef"></a> --&gt;</p>
<p>&lt;overlaylocal&gt;per-pixel&lt;/overlaylocal&gt;&lt;!-- whereby at least one level of partial transparency between graphics and video must be supported as per the minimum requirements of section <a href="#minimum-dae-capabilities" class="sectionRef"></a> --&gt;</p>
<p>&lt;overlaylocaltuner&gt;per-pixel&lt;/overlaylocaltuner&gt;&lt;!-- whereby at least one level of partial transparency between graphics and video must be supported as per the minimum requirements of section <a href="#minimum-dae-capabilities" class="sectionRef"></a> --&gt;</p>
<p>&lt;overlayIPbroadcast&gt;per-pixel&lt;/overlayIPbroadcast&gt;&lt;!-- whereby at least one level of partial transparency between graphics and video must be supported as per the minimum requirements of section <a href="#minimum-dae-capabilities" class="sectionRef"></a> --&gt;</p>
<p>&lt;notificationscripts&gt;false&lt;/notificationscripts&gt;</p>
<p>&lt;save-restore&gt;false&lt;/save-restore&gt;</p>

</td></tr>
<tr><td>"<code>OITF_SD60_UIPROF</code>"</td><td>
<p>Same as OITF_SDEU_UIPROF, with the following modifications:</p>
<p>&lt;width&gt;720&lt;/width&gt;</p>
<p>&lt;height&gt;480&lt;/height&gt;</p>
</td></tr>
<tr><td>"<code>OITF_SDUS_UIPROF</code>"</td><td>
<p>Same as OITF_SDEU_UIPROF, with the following modifications:</p>
<p>&lt;width&gt;640&lt;/width&gt;</p>
<p>&lt;height&gt;480&lt;/height&gt;</p>
</td></tr>
<tr><td>"<code>OITF_HD_UIPROF</code>"</td><td>
<p>Same as OITF_SDEU_UIPROF, with the following modifications:</p>
<p>&lt;width&gt;1280&lt;/width&gt;</p>
<p>&lt;height&gt;720&lt;/height&gt;</p>
<p>&lt;colors&gt;high&lt;/colors&gt;</p>
<p>&lt;font type="sans-serif" defaultsize="24"&gt;Tiresias Screenfont&lt;/font&gt; with support for the Unicode character range &ldquo;Generic Application Western European Character Set&rdquo; as defined in Annex C of [[!TS102809]].</p>
</td></tr>
<tr><td>"<code>OITF_FULL_HD_UIPROF</code>"</td><td>
<p>Same as OITF_HD_UIPROF, with the following modifications:</p>
<p>&lt;width&gt;1920&lt;/width&gt;</p>
<p>&lt;height&gt;1080&lt;/height&gt;</p>
</td></tr>
</table>
<p>In order to capture the heterogeneity of the features supported by OITF devices, this specification also defines a set of complementary UI Profile name fragments, each constituting a particular logical subset of capabilities, for which a OITF can indicate support by appending the UI Profile name fragment to the name of the supported base UI profile as defined in Table <a href="#Complementary-UI-Profile-Name-Fragments" class="tableRef"></a>. Both the OITF and server SHALL support the concatenation of a series of UI profile name fragments in any order.</p>
<table class="simple" id="Complementary-UI-Profile-Name-Fragments">
<caption>Table ####: Complementary UI Profile Name Fragments</caption>
<thead><tr><th>UI Profile Name Fragment</th><th>Default values</th></tr></thead>
<tr><td>"<code>+TRICKMODE</code>"</td><td>
<p>&lt;key&gt;VK_PLAY&lt;/key&gt;&lt;key&gt;VK_PAUSE&lt;/key&gt; and/or </p>
<p>&lt;key&gt;VK_PLAY_PAUSE&lt;/key&gt; (*)</p>
<p>&lt;key&gt;VK_STOP&lt;/key&gt;</p>
<p>&lt;key&gt;VK_REWIND&lt;/key&gt;</p>
<p>&lt;key&gt;VK_FAST_FWD&lt;/key&gt;</p>
<p>(*) The +TRICKMODE profile fragment identifier does not distinguish between remote controls having separate &ldquo;play&rdquo; and &ldquo;pause&rdquo; keys; and remote controls having a single &ldquo;play/pause&rdquo; toggle key. For that reason, in general, it is recommended that applications are written to handle both the VK_PLAY/VK_PAUSE key codes and the VK_PLAY_PAUSE key code</p>
</td></tr>
<tr><td>"<code>+AVCAD</code>"</td><td>&lt;video_profile type="application/vnd.oipf.ContentAccessStreaming+xml"/&gt; </td></tr>
<tr><td>"<code>+DL</code>"</td><td>&lt;download protocolNames="http"&gt;true&lt;/download&gt;</td></tr>
<tr><td>"<code>+IPTV_SDS</code>"</td><td>&lt;video_broadcast type="ID_IPTV_SDS" scaling="arbitrary"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+IPTV_URI</code>"</td><td>&lt;video_broadcast type="ID_IPTV_URI" scaling="arbitrary"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+ANA</code>"</td><td>&lt;video_broadcast type="ID_ANALOG" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+DVB_C</code>"</td><td>&lt;video_broadcast type="ID_DVB_C ID_DVB_SI_DIRECT" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+DVB_T</code>"</td><td>&lt;video_broadcast type="ID_DVB_T ID_DVB_SI_DIRECT" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+DVB_S</code>"</td><td>&lt;video_broadcast type="ID_DVB_S ID_DVB_SI_DIRECT" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+DVB_C2</code>"</td><td>&lt;video_broadcast type="ID_DVB_C2 ID_DVB_SI_DIRECT" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+DVB_T2</code>"</td><td>&lt;video_broadcast type="ID_DVB_T2 ID_DVB_SI_DIRECT" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+DVB_S2</code>"</td><td>&lt;video_broadcast type="ID_DVB_S2 ID_DVB_SI_DIRECT" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+ISDB_C</code>"</td><td>&lt;video_broadcast type="ID_ISDB_C" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+ISDB_T</code>"</td><td>&lt;video_broadcast type="ID_ISDB_T" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+ISDB_S</code>"</td><td>&lt;video_broadcast type="ID_ISDB_S" scaling="quarterscan"&gt;true&lt;/video_broadcast&gt;</td></tr>
<tr><td>"<code>+META_BCG</code>"</td><td>&lt;clientMetadata type="bcg"&gt;true&lt;/clientMetadata&gt;</td></tr>
<tr><td>"<code>+META_EIT</code>"</td><td>&lt;clientMetadata type="eit-pf"&gt;true&lt;/clientMetadata&gt;</td></tr>
<tr><td>"<code>+META_SI</code>"</td><td>&lt;clientMetadata type="dvb-si"&gt;true&lt;/clientMetadata&gt;</td></tr>
<tr><td>"<code>+ITV_KEYS</code>"</td><td>
<p>&lt;key&gt;VK_HOME&lt;/key&gt;</p>
<p>&lt;key&gt;VK_MENU&lt;/key&gt;</p>
<p>&lt;key&gt;VK_CANCEL&lt;/key&gt;</p>
<p>&lt;key&gt;VK_SUBTITLE&lt;/key&gt;</p>
</td></tr>
<tr><td>"<code>+CONTROLLED</code>"</td><td>
<p>&lt;key&gt;VK_CHANNEL_UP&lt;/key&gt;</p>
<p>&lt;key&gt;VK_CHANNEL_DOWN&lt;/key&gt;</p>
<p>&lt;key&gt;VK_VOLUME_UP&lt;/key&gt;</p>
<p>&lt;key&gt;VK_VOLUME_DOWN&lt;/key&gt;</p>
<p>&lt;key&gt;VK_MUTE&lt;/key&gt;</p>
<p>&lt;configurationChanges&gt;true&lt;/configurationChanges&gt;</p>
<p>&lt;extendedAVControl&gt;true&lt;/extendedAVControl&gt;</p>
<p>When relevant (i.e. when coupled with +DL, resp +PVR): <ul class="nobullet">
<li>&lt;download manageDownloads="samedomain"&gt;true&lt;/download&gt;
<li>&lt;recording manageRecordings="samedomain"&gt;true&lt;/recording&gt;</ul>
<p>&lt;remote_diagnostics&gt;true&lt;/remote_diagnostics&gt;</p>
</td></tr>
<tr><td>"<code>+PVR</code>"</td><td>
<p>&lt;key&gt;VK_RECORD&lt;/key&gt;</p>
<p>&lt;recording&gt;true&lt;/recording&gt;</p>
</td></tr>
<tr><td>"<code>+DRM</code>"</td><td>&lt;drm DRMSystemID="urn:dvb:casystemid:19188"&gt;TS_BBTS TTS_BBTS MP4_PDCF&lt;/drm&gt;</td></tr>
<tr><td>"<code>+CommunicationServices</code>"</td><td>&lt;communicationServices&gt;true&lt;/communicationServices&gt;</td></tr>
<tr><td>"<code>+SVG</code>"</td><td>&lt;mime-extensions&gt;image/svg+xml&lt;/mime-extensions&gt;</td></tr>
<tr><td>"<code>+POINTER</code>"</td><td>&lt;pointer&gt;true&lt;/pointer&gt;</td></tr>
<tr><td>"<code>+POLLNOTIF</code>"</td><td>&lt;pollingNotifications&gt;true&lt;/pollingNotifications&gt;</td></tr>
<tr><td>"<code>+WIDGETS</code>"</td><td>&lt;widgets&gt;true&lt;/widgets&gt;</td></tr>
<tr><td>"<code>+HTML5_MEDIA</code>"</td><td>&lt;html5_media&gt;true&lt;/html5_media&gt;</td></tr>
<tr><td>"<code>+RCF</code>"</td><td>&lt;remoteControlFunction&gt;true&lt;/remoteControlFunction&gt;
<p>(*) If an OITF supports the DLNA RUI RCF as defined in section <a href="#dlna-rui-remote-control-function-apis" class="sectionRef"></a>, the 3<sup>rd</sup> party multicast notification mechanism as defined in section 5.6.1 of [[!CEA-2014-A]] SHALL be supported for the OITF to send the 3<sup>rd</sup> party multicast notification to the DLNA RUICs. </p>
</td></tr>
<tr><td>"<code>+TELEPHONY</code>"</td><td>&lt;telephony_services video="false"&gt;true&lt;/telephony_services&gt;</td></tr>
<tr><td>"<code>+VIDEOTELEPHONY</code>"</td><td>&lt;telephony_services video="true"&gt;true&lt;/telephony_services&gt;</td></tr>
</table>
<p>Whenever an OITF supports an extension to the capabilities that can be defined using a combination of a base UI Profiles and a (number of) UI Profile fragment(s), it SHALL advertise this extension using the mechanism as defined in section <a href="#http-protocol" class="sectionRef"></a>.</p>
</section>
<section id="client-capability-description">
<h2>Client capability description</h2>
<p>This section defines an XML format by which an OITF describes its capabilities to a DAE application. This XML format was originally based on that found in CEA-2014 [[!CEA-2014-A]] however it has been extensively extended in this document. This is used to describe the capabilities that form the basis for the profile definitions and profile fragments as defined in section <a href="#default-ui-profiles" class="sectionRef"></a>, and is also the format that is used by the <a href="#oipfcapabilities-xmlcapabilities" class="apiRef">xmlCapabilities</a> property of the application/oipfCapabilities object.</p>
<p>The schema with the extensions and modifications to the capability description as defined in this section can be found in Annex <a href="#client-extensions-schema" class="sectionRef"></a>. The schema in Annex <a href="#client-extensions-schema" class="sectionRef"></a> SHALL be used instead of the existing capability description schema as defined in Annex C of CEA-2014 [[!CEA-2014-A]]. Support for carrying the XML capability description through the User-agent header as defined in CEA-2014 is not included in this document.</p>
<p>The elements and attributes not defined in this document SHALL be inherited from CEA-2014 [[!CEA-2014-A]].</p>
<p>Examples of valid OITF capability profiles are (using the full XML syntax as defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>):</p><ul class="nobullet">
<li>A pure HD-capable IPTV OITF, which supports live DVB-IP TV via SD&amp;S, streamed mpeg at SD and HD formats, the MPAA parental rating scheme, trickplay, and access to an embedded BCG metadata client:<pre class="xml-document">
&lt;profilelist&gt;
    &lt;ui_profile 
        name="OITF_HD_UIPROF+IPTV_SDS+AVCAD+META_BCG+TRICKMODE+ITV_KEYS+CONTROLLED+DRM"&gt;
        &lt;ext&gt;
            &lt;parentalcontrol schemes="urn:mpeg:mpeg7:cs:MPAAParentalRatingCS:2001"&gt;
			true &lt;/parentalcontrol&gt;
        &lt;/ext&gt;
    &lt;/ui_profile&gt;

    &lt;video_profile name="TS_AVC_SD_25_HEAAC" type="video/mpeg" 
         transport="http-get rtsp-rtp-udp"  
         DRMSystemID="urn:dvb:casystemid:19188"/&gt;

    &lt;video_profile name="TS_AVC_HD_25_HEAAC" type="video/mpeg" 
         transport="http-get rtsp-rtp-udp" 
         DRMSystemID="urn:dvb:casystemid:19188"/&gt;
&lt;/profilelist&gt;
</pre> 
<li>A hybrid HD-capable box, supporting live DVB broadcasts over satellite, PVR functionality, and (Marlin-protected and unprotected) VoD in progressive download: <pre class="xml-document">
&lt;profilelist&gt;
    &lt;ui_profile   
        name="OITF_HD_UIPROF+AVCAD+TRICKMODE+ITV_KEYS+CONTROLLED+DRM+DVB_S+META_SI+PVR"&gt;
    &lt;/ui_profile&gt;

    &lt;video_profile name="TS_AVC_SD_25_HEAAC" type="video/mpeg" 
        transport="http-get rtsp-rtp-udp" 
        DRMSystemID="urn:dvb:casystemid:19188"/&gt;

    &lt;video_profile name="TS_AVC_HD_25_HEAAC" type="video/mpeg" 
        transport="http-get rtsp-rtp-udp" 
        DRMSystemID="urn:dvb:casystemid:19188"/&gt;
&lt;/profilelist&gt;
</pre>
<li>A hybrid device providing access to its ATSC terrestrial tuner (supporting two different parental rating schemes), DVB-IPTV 'tuner', and PVR functionality to DAE applications, but not exposing 'trickmode' or 'controlled' key events to DAE applications running in the browser:<pre class="xml-document">
&lt;profilelist&gt;
    &lt;ui_profile name="OITF_HD_UIPROF+PVR+IPTV_SDS"&gt;
        &lt;ext&gt;
            &lt;video_broadcast type="ID_ATSC_T" scaling="arbitrary"&gt;true&lt;/video_broadcast&gt;
    
            &lt;parentalcontrol schemes="urn:mpeg:mpeg7:cs:MPAAParentalRatingCS:2001    
                                      urn:mpeg:mpeg7:cs:MPAAParentalRatingTVCS:2001"&gt; 
            true &lt;/parentalcontrol&gt;
        &lt;/ext&gt;
    &lt;/ui_profile&gt;
&lt;/profilelist&gt;
</pre>
</ul>
<section id="tuner-broadcast-capability">
<h3>Tuner/broadcast capability indication</h3>
<p>If an OITF supports control over its local tuner functionality by a server, an OITF SHALL indicate this through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the schema defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>. To this end the following new elements SHALL be supported for a capability description or capability profile (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):<ul>
<li><b>&lt;video_broadcast&gt;</b> - indicates whether or not the OITF supports the video/broadcast object to enable control of its local tuner functionality by a server (i.e. retrieving the tuner's channel line up, switching channels of the  tuner, and rendering the output of the broadcasted content inside the browser). The &lt;video_broadcast&gt; element has the following attributes:<ul>
<li>Attribute <i>type</i> specifies the type(s) of tuner(s) for which the OITF allows tuner control, by using a space-separated list of idType values as specified in section <a href="#channel-constants" class="sectionRef"></a> for the <a href="#channel-class" class="apiRef">Channel</a> object (i.e. &ldquo;<code>ID_ANALOG</code>&rdquo;, &ldquo;<code>ID_DVB_C</code>&rdquo;, etc.).
<li>Attribute <i>transport</i> specifies a space-separated list of supported (transport) protocols in case of IP Broadcasts (i.e. if the <i>type</i> attribute contains one of the <code>ID_IPTV_* idType</code> values as specified in section <a href="#channel-constants" class="sectionRef"></a>). This is done by using one or more of the (transport) protocol names as defined in <mark class="refError"><a href="volume4.html#system-infrastructure" class="extRef">Annex F</a> of [[.OIPF_PROT2]]</mark>.
<li>Attribute <i>scaling</i> specifies the method of video scaling the OITF supports for the tuner output (i.e. &ldquo;arbitrary&rdquo;, &ldquo;quartersize&rdquo;, &ldquo;0.33x0.33&rdquo; or &ldquo;none&rdquo;), with default value &ldquo;arbitrary&rdquo; if omitted. 
<li>Attribute <i>minSize</i> specifies the minimal size, as a percentage of the full extent of the OITF's display, to which the OITF supports scaling of video content received over the (logical or physical) tuner if attribute <i>scaling</i> has value &ldquo;arbitrary&rdquo;. The value &ldquo;0&rdquo; for the <i>minSize</i> attribute indicates support for arbitrary and unrestricted scaling of the video. The value of the attribute <i>minSize</i> SHALL be silently ignored if the value of the attribute <i>scaling</i> is not &ldquo;arbitrary&rdquo;.
<li>Attribute <i>nrstreams</i> provides an indication of the number of video streams that can be rendered simultaneously by the indicated tuner functionality (typically limited by the number of tuners supported by the device), with a default value of &ldquo;1&rdquo; if omitted.
<li>Attribute <i>postList</i> specifies, if included in the client's capability description, whether or not the OITF supports the HTTP POST method defined in section <a href="#conveyance-of-channel-list" class="sectionRef"></a>. If included in the server's capability description, <i>postList</i> specifies whether or not the server supports using the channel list information sent through the HTTP POST method to exercise tuner control. If an OITF does not post the channel list information, a server SHALL, irrespective of the value it specified for the <i>postList</i> attribute in its server capability description, rely on the <code>getChannelConfig</code> method defined in section <a href="#video-broadcast-methods" class="sectionRef"></a> to access the channel list information.
<li>Attribute <i>localTimeshift</i> indicates whether or not the OITF supports timeshift of scheduled content using local storage.
<li>Attribute <i>networkTimeshift</i> indicates whether or not the OITF supports network timeshift of scheduled content. Different from PVR or local timeshift capability in that no local resources are required to support network timeshift.
</ul>
<p>The &lt;video_broadcast&gt; element is defined using the following XML Schema fragment. Multiple &lt;video_broadcast&gt; elements may be specified to distinguish between tuners with different behaviour or capabilities, for example with respect to scaling:</p><pre class="xml-schema noborder">
&lt;xs:element name="video_broadcast" type="videoBroadcastType" minOccurs="0" 
            maxOccurs="unbounded"/&gt;
&lt;xs:complexType name="videoBroadcastType"&gt;
    &lt;xs:attribute name="type" type="xs:string" use="required"/&gt;
    &lt;xs:attribute name="transport" type="xs:string"/&gt;
    &lt;xs:attribute name="nrstreams" type="xs:unsignedInt" default="1"/&gt;
    &lt;xs:attribute name="scaling" type="scalingType" default="arbitrary"/&gt;
    &lt;xs:attribute name="minSize" type="xs:unsignedInt" default="0"/&gt;
    &lt;xs:attribute name="postList" type="xs:boolean" default="false"/&gt;
    &lt;xs:attribute name="networkTimeshift" type="xs:boolean" default="false"/&gt;
    &lt;xs:attribute name="localTimeshift" type="xs:boolean" default="false"/&gt;
&lt;/xs:complexType&gt;
</pre>
<li><b>&lt;overlaylocaltuner&gt;</b> - indicates whether or not the OITF supports overlays for video broadcasts received through the local tuner, i.e. allows XHTML content to be rendered on top of video content broadcasted over local tuner. If included, the value of this element SHALL be per-pixel as defined for the element &lt;overlay&gt;. Note: the values none, on-off and global defined for the &lt;overlaylocaltuner&gt; element in [Req. 5.2.1.a] of CEA-2014-A are not permitted for this element in this specification.
</ul>
</section>
<section id="broadcast-content-over-ip-capability">
<h3>Broadcast content over IP capability indication</h3>
<p>If an OITF supports functionality for rendering the output of the broadcasted content received over IP inside the browser and optionally providing an IPTV related channel line-up and favourite list to the server, an OITF SHALL indicate this through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the schema defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>. This SHALL be done using the same &lt;video_broadcast&gt; element as defined in section <a href="#tuner-broadcast-capability" class="sectionRef"></a>, whereby the type attribute contains one of the <code>ID_IPTV_* idType</code> values as specified in section <a href="#channel-constants" class="sectionRef"></a>:</p><ul>
<li><b>&lt;video_broadcast&gt;</b> - indicates whether or not the OITF supports the video/broadcast object to enable control rendering the output of the broadcasted content received over IP inside the browser and optionally providing an IPTV related channel line-up and favourite list to the server.
</ul>
<p>To indicate support for overlays over IP broadcasts the following element SHALL be used (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):</p><ul>
<li><b>&lt;overlayIPbroadcast&gt;</b> - indicates whether or not the OITF supports overlays for IP video broadcasts, i.e. allows XHTML content to be rendered on top of video content broadcasted over IP. If included, the value of this element SHALL be per-pixel as defined for the element &lt;overlay&gt;.  Note: the values none, on-off and global defined for the &lt;overlay&gt; element in [Req. 5.2.1.a] of CEA-2014-A are not permitted for this element in this specification.
</ul>
</section>
<section id="pvr-capability">
<h3>PVR capability indication</h3>
<p>Support for the control of recording functionality that is available to the OITF by a server SHALL be indicated through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the &lt;recording&gt; element defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>. This specification defines the following element that can be added to a capability description:</p><ul>
<li><b>&lt;recording&gt;</b> - indicates whether or not the OITF supports control of its local recording (i.e. PVR) functionality by a server. If included, the value of this element SHALL be (true|false). The boolean attribute <i>ipBroadcast</i> specifies whether or not the OITF also supports recording of A/V content broadcasted over IP (using the mechanisms for Scheduled Content defined in [[.OIPF_PROT2]]), the boolean attribute HAS specifies whether or not the OITF also supports recording of scheduled content delivered over IP as defined by HAS [[.OIPF_HAS2]], the boolean attribute <i>DASH</i> specifies whether or not the OITF also supports recording of scheduled content delivered over IP as defined by [[!DASH]] and [[.OIPF_HAS2]] and the Boolean attribute <i>postList</i> specifies whether or not the OITF supports the HTTP POST method defined in section <a href="#conveyance-of-channel-list-and-list-of-scheduled-recordings" class="sectionRef"></a>, respectively whether or not the server uses the posted channel list information, if conveyed by the OITF, to control the recording functionality available to the OITF. If an OITF does not post the channel list information, a server SHALL, irrespective of the value it specified for the <i>postList</i> attribute, rely on the <code>getChannelConfig()</code> method defined in section <a href="#video-broadcast-methods" class="sectionRef"></a> to access the channel list information. The Boolean attribute manageRecordings specifies whether or not the OITF supports managing recordings through the JavaScript APIs defined in section <a href="#application-oipfrecordingscheduler-control-extension" class="sectionRef"></a>.
</ul>
<p>The &lt;recording&gt; element is defined using the following XML Schema fragment (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):</p><pre class="xml-schema noborder"> 
&lt;xs:element name="recording" type="pvrType"/&gt;
&lt;xs:complexType name="pvrType"&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base="xs:boolean"&gt;
      &lt;xs:attribute name="ipBroadcast" type="xs:boolean" default="false"/&gt;
      &lt;xs:attribute name="HAS" type="xs:boolean" default="false"/&gt;
      &lt;xs:attribute name="DASH" type="xs:boolean" default="false"/&gt;
      &lt;xs:attribute name="manageRecordings" 
                type="manageRecordingsType" default="none"/&gt;
      &lt;xs:attribute name="postList" type="xs:boolean" default="false"/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
&lt;xs:simpleType name="manageRecordingsType"&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:enumeration value="none"/&gt;
    &lt;xs:enumeration value="initiator"/&gt;
    &lt;xs:enumeration value="samedomain"/&gt;
    &lt;xs:enumeration value="all"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
</pre>
<p>If the <code>manageRecordings</code> attribute is present, this attribute SHALL take one of the following values:</p><ul>
<li>&ldquo;<b>none</b>&rdquo;: indicates that the client does not support managing recordings.
<li>&ldquo;<b>initiator</b>&rdquo;: indicates that recordings initiated by the current application may be managed.
<li>&ldquo;<b>samedomain</b>&rdquo;: indicates that recordings initiated by applications from the same fully-qualified domain may be managed.
<li>&ldquo;<b>all</b>&rdquo;: indicates that recordings initiated both by the current application and other applications may be managed.
</ul><p>If not present, a value of &ldquo;<b>none</b>&rdquo; SHALL be assumed.</p>
</section>
<section id="download-cod-capability">
<h3>Download CoD capability indication</h3>
<p>If a client supports downloading content to a client (with or without DRM protection), the client SHALL indicate this through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the schema defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>. The <code>&lt;download&gt;</code> element SHALL adhere to the definition of bullet o) of [Req. 5.2.1.a] of CEA-2014-A. </p>
<p>A client MAY include an informative list of MIME types it supports for playback after download through the &lt;mime-extensions&gt; element. Note that since content download may be separated from content playback, a server SHOULD NOT rely on this information to be present.</p>
<p>If a client supports managing downloads through the JavaScript content download API specified in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> then the client SHALL indicate this using the attribute <i>manageDownloads</i>.  This attribute has the following definition (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):</p><pre class="xml-schema noborder">
&lt;xs:attribute name="manageDownloads" type="manageDownloadsType" default="none"/&gt;
</pre>
<p>If present, this attribute SHALL take one of the following values:</p><ul>
<li>&ldquo;<b>none</b>&rdquo;: indicates that the client does not support managing downloads.
<li>&ldquo;<b>initiator</b>&rdquo;: indicates that downloads initiated by the current application may be managed.
<li>&ldquo;<b>samedomain</b>&rdquo;: indicates that downloads initiated by applications from the same fully-qualified domain may be managed.
<li>&ldquo;<b>all</b>&rdquo;: indicates that downloads initiated both by the current application and other applications may be managed.
</ul><p>If not present, a value of &ldquo;<b>none</b>&rdquo; SHALL be assumed.</p>
<p>Example:</p><pre>
&lt;download protocolNames="http ftp" manageDownloads="all"&gt; true &lt;/download&gt;
</pre>
</section>
<section id="parental-ratings-capabilty">
<h3>Parental ratings</h3>
<p>If an OITF supports a parental control system, the OITF SHALL indicate this by using the value &ldquo;true&rdquo; for element &lt;parentalcontrol&gt; in the OITF capability profile/description, and define a space separated list of names of parental rating schemes using the &ldquo;schemes&rdquo; attribute.</p>
<p>The schema of the &lt;parentalcontrol&gt; element is defined as follows (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):</p><pre class="xml-schema noborder">
&lt;xs:element name="parentalcontrol" type="parentalControlType"/&gt;
&lt;xs:complexType name="parentalControlType"&gt;
     &lt;xs:simpleContent&gt;
	&lt;xs:extension base="xs:boolean"&gt;
	     &lt;xs:attribute name="schemes" type="xs:string"/&gt;		
	&lt;/xs:extension&gt;
     &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
</pre>
<p>For which the following semantics SHALL apply:</p><ul>
<li><b>&lt;parentalcontrol&gt;</b> - indicates whether or not the OITF supports a client controlled parental control system. If included in the OITF capability description, the value of this element SHALL be: (true|false). The &lt;parentalcontrol&gt; element has the following attributes:<ul>
<li>attribute &ldquo;<b>schemes</b>&rdquo;: SHALL be a non-empty space separated list of names of parental rating schemes registered with the platform (either by the manufacturer, or by applications where the rating scheme is associated with a recording), if the value of the &lt;parentalcontrol&gt; element is true. Valid rating schemes names include the ParentalRating classification scheme names as defined by property &ldquo;scheme&rdquo; of the <a href="#parentalrating-class" class="apiRef">ParentalRating</a> object as defined in section <a href="#parentalrating-class" class="sectionRef"></a>.
</ul></ul>
<p>Example:</p><pre class="xml-schema noborder">
&lt;parentalcontrol schemes="dvb-si urn:mpeg:mpeg7:cs:MPAAParentalRatingCS:2001"&gt;
	true
&lt;/parentalcontrol&gt;
</pre>
</section>
<section id="extended-av-api-support">
<h3>Extended A/V API support</h3>
<p>The OITF SHALL indicate support for the extended A/V control APIs defined in section <a href="#channelconfig-class" class="sectionRef"></a> through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the &lt;extendedAVControl&gt; element defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>:</p><pre class="xml-schema noborder">
&lt;xs:element name="extendedAVControl" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>)</p>
<p>NOTE: Section <a href="#channelconfig-class" class="sectionRef"></a> defines which methods and properties in that section are covered by this capability and which are not.</p>
</section>
<section id="OITF-metadata-api-support">
<h3>OITF Metadata API support</h3>
<p>The OITF SHALL indicate support for client-side metadata processing and the APIs defined in section <a href="#metadata-apis" class="sectionRef"></a> through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the &lt;clientMetadata&gt; element defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>:</p><pre class="xml-schema noborder">
&lt;xs:element name="clientMetadata" type="metadataType"/&gt;
&lt;xs:complexType name="metadataType"&gt;
	&lt;xs:simpleContent&gt;
	    &lt;xs:extension base="xs:boolean"&gt;
	       &lt;xs:attribute name="type" type="xs:string"/&gt;
	    &lt;/xs:extension&gt;
	&lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
</pre>
<p>This element has the following semantics:</p><ul>
<li><b>&lt;clientMetadata&gt;</b> - indicates whether or not the OITF supports a client-side metadata processing. If included in the RUI Client capability description, the value of this element SHALL be: (true|false). 
</ul>
<p>The &lt;clientMetadata&gt; element has the following attributes:</p><ul>
<li>attribute &ldquo;<b>type</b>&rdquo; SHALL include a non-empty space separated list of names of supported metadata systems/protocols, if the value of the &lt;clientMetadata&gt; element is true. 
<p>Below is an extensible list of metadata system/protocol names which MAY be used for this attribute.  These values are not case sensitive:</p><ul>
<li>&ldquo;<b>bcg</b>&rdquo;: indicates support for the TV-Anytime Broadband Content Guide metadata format according to <a href="volume3.html#bcg-extensions" class="extRef">section 3.3</a> of [[.OIPF_META2]].
<li>&ldquo;<b>sd-s</b>&rdquo;: indicates support for the DVB Service Discovery and Selection format according to  <a href="volume3.html#sdns-extensions" class="extRef">section 3.2</a> of [[.OIPF_META2]].
<li>&ldquo;<b>dvb-si</b>&rdquo;: indicates support for DVB-SI EIT schedule information as defined by [[!EN300468]].
<li>&ldquo;<b>eit-pf</b>&rdquo;: indicates support for EIT present/following information as defined for DVB-SI in  <a href="volume3.html#event-information-tables" class="extRef">section 4.1.3</a> of [[.OIPF_META2]].
</ul></ul>
</section>
<section id="OITF-configuration-api-support">
<h3>OITF Configuration API support</h3>
<p>The OITF SHALL indicate support for modification of OITF configuration and settings by applications (via the APIs defined in section <a href="#configuration-and-setting-apis" class="sectionRef"></a>) through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the &lt;configurationChanges&gt; element defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>:</p><pre class="xml-schema noborder">
&lt;xs:element name="configurationChanges" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>).</p>
</section>
<section id="communication-services-api-support">
<h3>Communication Services API support</h3>
<p>The OITF SHALL indicate support for the Communication Services API (via the APIs defined in section <a href="#communication-services-apis" class="sectionRef"></a>) through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the <code>&lt;communicationServices&gt;</code> element defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>:</p><pre class="xml-schema noborder">
&lt;xs:element name="communicationServices" type="xs:boolean"/&gt;

&lt;xs:element name="presenceMessaging" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of these elements SHALL be: (<code>true</code>|<code>false</code>).</p>
<p>Support for full-duplex Voice and Video Telephony APIs is indicated using:</p><pre class="xml-schema noborder">
&lt;xs:element name="telephony_services" type="telephonyServicesType"/&gt;
&lt;xs:complexType name="telephonyServicesType"&gt;
   &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xs:boolean"&gt;
         &lt;xs:attribute name="video" type="xs:boolean" default="false"/&gt;
      &lt;/xs:extension&gt;
   &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
</pre>
<p>If present, the video attribute SHALL take one of the following values (true|false). </p>
<p>If not present, a value of &ldquo;false&rdquo; SHALL be assumed. </p>
<p>Example: </p><pre>
&lt;telephony_services video="true"&gt; true &lt;/telephony_services&gt;
</pre>
</section>
<section id="drm-capability-indication">
<h3>DRM Capability indication</h3>
<p>The OITF SHALL indicate support for handling DRM-protected content through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the &lt;drm&gt; element defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>:</p><pre class="xml-schema noborder">
&lt;xs:element name="drm" type="drmType" minOccurs="0" maxOccurs="unbounded"/&gt;
&lt;xs:complexType name="drmType"&gt;
	&lt;xs:simpleContent&gt;
	    &lt;xs:extension base="xs:string"&gt;
	       &lt;xs:attribute name="DRMSystemID" type="xs:string" use="required"/&gt;
	       &lt;xs:attribute name="protectionGateways" type="xs:string" default=""/&gt;
	    &lt;/xs:extension&gt;
	&lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt; 
</pre>
<p>And with the following semantics:</p><ul>
<li><b>&lt;drm&gt;</b> - indicates whether or not the client supports a DRM content protection system for downloading and streaming content. If included in the RUI Client capability description, the value of this element SHALL be a space separated list of zero or more names of supported file and/or container formats for protected content by the DRM system indicated by the  "DRMSystemID" attribute, such as the OMA DRM Content Format (DCF). Valid values include: a system layer format name of the first column of Table <a href="volume2.html#protav" class="extRef">3</a> of [[.OIPF_MEDIA2]], and  a protection format of the second column of Table <a href="volume2.html#protav" class="extRef">3</a> of [[.OIPF_MEDIA2]], concatenated with an underscore '_'. In case of the Gateway centric approach defined by [[.OIPF_CSP2]], this value indicates the system layer and protection formats which are supported by the combination of OITF and CSP Gateway. Values are not case sensitive.
</ul>
<p>The &lt;drm&gt; element has the following attributes:</p><ul>
<li>attribute &ldquo;<b>DRMSystemID</b>&rdquo; SHALL include a supported DRM system. Valid values for the "DRMSystemID" include the values as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For example, for Marlin, the DRMSystemID value is &ldquo;urn:dvb:casystemid:19188&rdquo;. In case of the Gateway centric approach defined by [[.OIPF_CSP2]], this DRMSystemID attribute indicates the DRM System(s) of UNIS-CSP-G which is supported by the combination of OITF and CSP Gateway.
<li>attribute &ldquo;<b>protectionGateways</b>&rdquo; SHALL include a space separated list of zero or more names of supported  CSP Gateway types that are capable of supporting the DRM system indicated by attribute &ldquo;<code>DRMSystemID</code>&rdquo;.  This attribute is conditional mandatory and SHALL be specified in the case that the DRM System indicated by the &ldquo;<code>DRMSystemID</code>&rdquo; attribute is supported by the CSP Gateway when it is not an embedded CSPG (see <a href="volume7.html#embedded-cspg" class="extRef">Annex F</a> of [[.OIPF_CSP2]]). Valid values for the scheme for the Gateway centric approach defined by [[.OIPF_CSP2]] are &ldquo;<code>dtcp-ip</code>&rdquo; and &ldquo;<code>ci+</code>&rdquo;. Values are not case sensitive.
</ul>
<p>Examples:</p><pre>
&lt;drm DRMSystemID="urn:dvb:casystemid:19188"&gt;TS_BBTS TTS_BBTS MP4_PDCF&lt;/drm&gt;
&lt;drm DRMSystemID="urn:dvb:casystemid:12348" protectionGateways="ci+"&gt;TS_PF TTS_PF&lt;/drm&gt;
&lt;drm DRMSystemID="urn:dvb:casystemid:12348" protectionGateways="dtcp-ip"&gt;TS_PF&lt;/drm&gt;
&lt;drm DRMSystemID="urn:dvb:casystemid:6304"&gt;TS_PF&lt;/drm&gt;
</pre>
</section>
<section id="media-profile-capability-indication">
<h3>Media Profile Capability indication</h3>
<p>If an OITF supports streaming A/V content to the client, the client SHALL indicate this by including a non-empty list of &lt;audio_profile&gt; and/or &lt;video_profile&gt; elements in the RUI client capability description. The &lt;audio_profile&gt; and &lt;video_profile&gt; elements SHALL adhere to the following requirements in addition to what has been defined by bullet v) and w) of [Req. 5.2.1.a] of CEA-2014-A: </p><ul>
<li>Valid values for the &ldquo;type&rdquo; attribute of the &lt;audio_profile&gt; and &lt;video_profile&gt; elements include the MIME types given in section <a href="volume2.html#media-section" class="extRef">3</a> of [[.OIPF_MEDIA2]].
<li>Valid values for the name attribute of the &lt;audio_profile&gt; and &lt;video_profile&gt; elements SHALL include the DLNA media format profiles (as required by CEA-2014-A) as well as the following:<ul>
<li>for &lt;video_profile&gt; elements: the system format name, the video format name and the audio format name for A/V contents, concatenated with an underscore '_', as defined in section <a href="volume2.html#media-section" class="extRef">3</a> of [[.OIPF_MEDIA2]]. 2D and 3D capabilities SHALL be signalled separately.
<li>for &lt;audio_profile&gt; elements: the audio format name for pure audio contents in Table <a href="volume2.html#pure-audio" class="extRef">4</a> of [[.OIPF_MEDIA2]].
<li>for both &lt;video_profile&gt;, and &lt;audio_profile&gt; elements, it is allowed to include multiple profile names corresponding to the same MIME type, by separating each profile name with a whitespace character.</ul>
<li>Valid values for the &ldquo;transport&rdquo;-attribute include (a space-separated list of ) the protocol names as defined in the column &ldquo;Name for &lt;protocol&gt;&rdquo; in <a href="volume4.html#annex-e-1" class="extRef">Annex E.1</a> of [[.OIPF_PROT2]], whereby the value &ldquo;http&rdquo; as specified as default value for the &ldquo;transport&rdquo;-attribute in CEA-2014-A SHALL correspond to value &ldquo;http-get&rdquo;. HAS support (as defined by [[.OIPF_HAS2]]) is indicated by using &ldquo;has&rdquo; as the protocol name as indicated in <a href="volume4.html#annex-e-1" class="extRef">Annex E.1</a> of [[.OIPF_PROT2]]. MPEG DASH support (as defined by [[.OIPF_HAS2]]) is indicated by using &ldquo;dash&rdquo; as the protocol name as indicated in <a href="volume4.html#annex-e-1" class="extRef">Annex E.1</a> of [[.OIPF_PROT2]].
<li>The &lt;video_profile&gt; and &lt;audio_profile&gt; elements SHALL support a new attribute called &ldquo;DRMSystemID&rdquo;, which SHALL include a space separated list of zero or more DRM system IDs supported for the media profile(s), whereby the DRMSystemID SHALL correspond to a &lt;drm&gt; element (as defined in section <a href="#drm-capability-indication" class="sectionRef"></a>. about DRM capability indication) with the same value for attribute &ldquo;DRMSystemID&rdquo;. In the case the attribute &ldquo;DRMSystemID&rdquo; is specified, non-protected A/V contents of the media profile(s) SHALL be also supported. For non protected media profile(s), this attribute MAY be omitted (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information).
<li>Next to providing the list of supported audio and video profiles, the client SHALL include an &lt;audio_profile&gt; element and/or a &lt;video_profile&gt; element with the value  &ldquo;application/vnd.oipf.ContentAccessStreaming+xml&rdquo; for attribute &ldquo;type&rdquo;, to indicate support for the content access description document format as defined in section <a href="#streaming-cod" class="sectionRef"></a> as value for the &ldquo;data&rdquo; attribute of the A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> to initiate the streaming of content.
</ul>
<p>Examples:</p><pre class="xml-document">
&lt;video_profile type="application/vnd.oipf.ContentAccessStreaming+xml"/&gt;

&lt;video_profile 
    name="TS_MPEG2_SD_25_AC3 TS_AVC_HD_25_HEAAC" 
    type="video/mpeg" 
    DRMSystemID="urn:dvb:casystemid:19188" 
    transport="rtsp-rtp-udp"
/&gt;

&lt;video_profile 
    name="MP4_MPEG2_SD_25_AC3 MP4_AVC_HD_25_HEAAC" 
    type="video/mp4" 
    transport="http-get"
/&gt;

&lt;video_profile 
    name="TS_AVC_HD_25_HEAAC" 
    type="application/x-dtcp1" 
    DRMSystemID="urn:dvb:casystemid:12348" 
    transport="http-get"
/&gt;

&lt;audio_profile name="MPEG1_L3" type="audio/mpeg" transport="http-get"/&gt;
</pre>
<p>The example below is for a terminal supporting 3D video. Note that the first two values in the 'name' strings refer to 2D capabilities, and the third value refers to 3D capabilities.</p><pre class="xml-document">
&lt;video_profile
    name="TS_MPEG2_SD_25_AC3 TS_AVC_HD_25_HEAAC TS_AVC_3D_25_HEAAC"
    type="video/mpeg"
    DRMSystemID="urn:dvb:casystemid:19188"
    transport="rtsp-rtp-udp"
/&gt;

&lt;video_profile
  name="MP4_MPEG2_SD_25_AC3 MP4_AVC_HD_25_HEAAC MP4_AVC_3D_25_HEAAC"
  type="video/mp4"
  transport="http-get"
/&gt;
</pre>
</section>
<section id="remote-diagnostics-support">
<h3>Remote Diagnostics support</h3>
<p>The OITF SHALL indicate support for remote diagnostics (via the APIs defined in section <a href="#remote-management-apis" class="sectionRef"></a>) using the following element in the OITF's capability description (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):</p><pre class="xml-schema noborder">
&lt;xs:element name="remote_diagnostics" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>).</p>
</section>
<section id="svg-support">
<h3>SVG</h3>
<p>The OITF SHALL indicate support for SVG through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> or as defined in section <a href="#svg" class="sectionRef"></a> using the Remote UI Client Capability Description defined for SVG in that section - <code>image/svg+xml</code>.</p>
<p>In order to determine support for video tag in SVG the <code>hasFeature()</code> method with argument &ldquo;<code>http://www.w3.org/Graphics/SVG/feature/1.2/#Video</code>&rdquo; shall be used. Example:</p><pre class="javascript">
var hasvideo = document.implementation.hasFeature(
                  "http://www.w3.org/Graphics/SVG/feature/1.2/#Video", null)
</pre>
</section>
<section id="third-party-notification-support">
<h3>Third Party notification support</h3>
<p>If an OITF supports the 3<sup>rd</sup> party  polling mechanism as defined in section 5.6.2 of [[!CEA-2014-A]], including the extensions to section 5.6.2 as defined in Annex <a href="#changes-to-cea2014a-5-6-2" class="sectionRef"></a>, through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the <code>&lt;pollingNotifications&gt;</code> element defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>:</p><pre class="xml-schema noborder">
&lt;xs:element name="pollingNotifications" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>).</p>
</section>
<section id="MDTF-support">
<h3>Multicast Delivery Terminating Function support</h3>
<p>The OITF SHALL indicate support for the multicast delivery terminating function (via the APIs defined in section <a href="#application-oipfmdtf" class="sectionRef"></a>) using the following element in the OITF's capability description (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):</p><pre class="xml-schema noborder">
&lt;xs:element name="mdtf" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>).</p>
</section>
<section id="other-capability-extensions">
<h3>Other capability extensions</h3>
<p>The following extensions to the capability profile elements defined in [Req. 5.2.1.a] of CEA-2014-A SHALL be supported:<ol type="a">
<li>an additional value &ldquo;0.33x0.33&rdquo; for attribute &ldquo;scaling&rdquo; of the &lt;video_profile&gt; element in bullet w) of [Req. 5.2.1.a], with the following related extension to the schema for type &ldquo;scalingType&rdquo; (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):<pre class="xml-schema noborder">
&lt;xs:enumeration value="0.33x0.33"/&gt;
</pre>
</ol>
</section>
<section id="html5-video-capability">
<h3>HTML5 video</h3>
<p>The OITF SHALL indicate support for HTML5 video through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> and the &lt;html5_media&gt; element as defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>:</p><pre class="xml-schema noborder">
&lt;xs:element name="html5_media" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>).</p>
</section>
<section id="dlna-rui-rcf-support">
<h3>DLNA RUI Remote Control Function support</h3>
<p>The OITF SHALL indicate support for the DLNA RUI RCF (via the APIs defined in section <a href="#dlna-rui-remote-control-function-apis" class="sectionRef"></a>) using the following element in the OITF's capability description (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):</p><pre class="xml-schema noborder">
&lt;xs:element name="remoteControlFunction" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>).</p>
</section>
<section id="power-consmption-support">
<h3>Power Consumption</h3>
<p>The OITF SHALL indicate support for wake-up using the following elements in the OITF's capability description (see Annex <a href="#client-extensions-schema" class="sectionRef"></a> for more information):</p><pre class="xml-schema noborder">
&lt;xs:element name="wakeupApplication" type="xs:boolean"/&gt;
&lt;xs:element name="wakeupOITF" type="xs:boolean"/&gt;
&lt;xs:element name="hibernateMode" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>).</p>
</section>
<section id="widgets-support">
<h3>Widgets</h3>
<p>The OITF SHALL indicate support for Widget APIs through the base profile and UI profile name fragment strings as defined in section <a href="#default-ui-profiles" class="sectionRef"></a> &ldquo;<a href="#default-ui-profiles" class="sectionTitleRef"></a>&rdquo; and the &lt;widgets&gt; element defined in Annex <a href="#client-extensions-schema" class="sectionRef"></a>:</p><pre class="xml-schema noborder">
&lt;xs:element name="widgets" type="xs:boolean"/&gt;
</pre>
<p>If included, the value of this element SHALL be: (<code>true</code>|<code>false</code>).</p>
<p>Widget APIs are the following Widget related methods/attributes defined in sections <a href="#application-oipfApplicationManager" class="sectionRef"></a> and <a href="#application-class" class="sectionRef"></a>:</p><ul> 
<li><a href="#oipfApplicationManager-onwidgetinstallation" class="apiRef">ApplicationManager.onWidgetInstallation</a>
<li><a href="#oipfApplicationManager-onwidgetinstallation" class="apiRef">ApplicationManager.onWidgetUninstallation</a>
<li><a href="#oipfApplicationManager-installwidget" class="apiRef">ApplicationManager.installWidget</a>
<li><a href="#application-startwidget" class="apiRef">Application.startWidget</a>
<li><a href="#application-stopwidget" class="apiRef">Application.stopWidget</a>
<li><a href="#oipfApplicationManager-uninstallwidget" class="apiRef">ApplicationManager.uninstallWidget</a>
<li><a href="#oipfApplicationManager-widgets" class="apiRef">ApplicationManager.widgets</a>
</ul>
</section>
<section id="buffer-control-of-playback-support">
<h3>Buffer control of AV content playback API support</h3>
<p>The OITF SHALL indicate support for buffer control of AV content playback through the APIs defined in section <a href="#av-control-extensions-for-ui-feedback-of-buffering" class="sectionRef"></a>.</p>
<p>The schema of the &lt;playbackControl&gt; element is defined as follows:</p><pre class="xml-schema noborder">
&lt;xs:element name="playbackControl" type="playbackType"/&gt;
&lt;xs:complexType name="playbackType"&gt;
	&lt;xs:simpleContent&gt;
	    &lt;xs:extension base="xs:boolean"&gt;
	       &lt;xs:attribute name="type" type="xs:string"/&gt;
	    &lt;/xs:extension&gt;
	&lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
</pre>
<p>This element has the following semantics:</p><ul>
<li><b>&lt;playbackControl&gt;</b> - indicates whether or not the OITF supports the APIs defined in section <a href="#av-control-extensions-for-ui-feedback-of-buffering" class="sectionRef"></a> for control of  buffering strategy. If the value of the <code>&lt;playbackControl&gt;</code> element is <code>true</code> the attribute <code>type</code> SHALL include a non-empty space separated list of names indicating the forms of AV content playback control which are supported.<ul>
<li>attribute &ldquo;<b>type</b>&rdquo; SHALL include a non-empty space separated list of names indicating the forms of AV content playback control which are supported if the value of the <code>&lt;playbackControl&gt;</code> element is true. 
<p>Below is an extensible list of names which MAY be used for this attribute. These values are not case sensitive:</p><ul>
<li>&ldquo;<b>buffering</b>&rdquo;: indicates support for monitoring or controlling how full the playback buffer is reached.
<li>&ldquo;<b>has</b>&rdquo;: indicates support for monitoring or controlling HAS properties including the Representation and the Period.
<li>&ldquo;<b>dash</b>&rdquo; : indicates support for monitoring or controlling MPEG DASH properties including the Representation and the Period.
</ul></ul></ul>
</section>
<section id="temporal-clipping-support">
<h3>Temporal Clipping</h3>
<p>The OITF SHALL indicate support for temporal clipping using media fragments in URIs defined in section <a href="#uri-schemes" class="sectionRef"></a> by including the &lt;temporalClipping&gt; element in the XML capabilities as follows:</p><pre class="xml-schema noborder">
&lt;xs:element name="temporalClipping" type="hasCapability"/&gt;
&lt;xs:complexType name="hasCapability"/&gt;
</pre>
</section>
<section id="capability-elements-from-other-schemas">
<h3>Capability Elements from other schemas</h3>
<p>This specification describes capability elements which reflect the currently defined functionality. Additional functionality can be supported by an OITF and in such cases, the specification of such additional functionality will be able to define additional elements to be included. The set of capability elements is extendable through the following XML schema mechanism.</p><pre class="xml-schema noborder">
&lt;xs:any namespace="##other"/&gt;
</pre>
</section>
<section id="pointer-support">
<h3>Pointer support</h3>
The <code>&lt;pointer&gt;</code> element indicates whether or not the OITF provides the user with a way to make pointer-based input (such as mouse or touch) to the browser. If the capability is true then the OITF SHALL be able to generate all mouse event types as included in the Web Standards TV Profile [[.OIPF_WSTVP2]].
</section>

</section>
</section>

<!-- section 10 -->
<section id='dae-security'>
<h1>Security</h1>
<section id="application-service-security">
<h2>Application / Service Security</h2>
<p>This section defines the security model that applies to the privileged functionality exposed by an OITF to a server device. The main purpose of the security model is to protect local client side functionality exposed by an OITF to JavaScript from unauthorized use. For example in the case of PVR control API, untrusted servers should be prevented from scheduling recordings. </p>
<p>The security model is quite generic, in a sense that it is not limited to particular privileged browser extensions, but can be applied to any local client side functionality exposed to any kind of networked application. </p>
<section id="oitf-security-requirements">
<h3>OITF requirements</h3>
<p>The following requirements SHALL apply to OITFs that expose security and/or privacy sensitive (i.e. privileged) functionality in one or more of the cases described in section <a href="#specific-security-requirements" class="sectionRef"></a>.</p><ul>
<li>An OITF SHALL prevent a HTML document from a server from accessing the exposed security and/or privacy sensitive functionality, unless the server can be correctly authenticated (see below), and the server is granted the necessary privileges to access the security and/or privacy sensitive functionality.
<li>The OITF SHALL authenticate the server during a TLS handshake through a valid X.509v3 certificate, that is granted by a certificate authority that is trusted by the OITF. To this end, the OITF SHALL match the hostname or (sub)domainname of the HTML document's URI with the hostname or (sub)domainname as specified in the X.509v3 certificate, in the manner as defined in <a href="https://tools.ietf.org/html/rfc2818#section-3.1" class="extRef">section 3.1</a> of [[!RFC2818]].
<li>The OITF SHALL support the Online Certificate Status Protocol (OCSP), at least the Lightweight Profile as defined in RFC 5019 [[!RFC5019]],  to determine the current validity of the X.509v3 certificate before access to privileged functionality is granted.
<li>The OITF MAY support a private certificate extension for X.509v3 certificates called &ldquo;permissions&rdquo; that specifies a set of permissions requested by a server to access privileged functionality, through zero or more permission names associated with privileges. The OITF MAY grant an authenticated server the set of permissions, which are each associated with the right to access a specific set of privileged functionality. Allowed permissions names include the permission names as defined in section <a href="#permission-names" class="sectionRef"></a>.
<li>The set of permissions granted to an authenticated server by an OITF MAY depend on the occurrence of that server on a whitelist or blacklist available to the OITF.
<li>NOTE: Management of whitelists and blacklists available to an OITF is out of scope of this document.
<li>If the server does not have the necessary privileges to access a property, method or object, or the server cannot be properly authenticated, the OITF SHALL throw an error with the name property set to the value "SecurityError". The example below shows how this can be used by applications:<pre class="javascript">
try {
  object.foo()
} catch(e)
{
  if (e.name == "SecurityError") {
    // I am not authorised to do this
  }
}
</pre>
<li>The OITF MAY inform the user of the decision to deny a server requested access to privileged functionality and MAY offer the user the option to override this decision.
</ul>
</section>
<section id="server-security-requirements">
<h3>Server requirements</h3>
<p>The following requirements SHALL apply to servers that wish to access security and/or privacy sensitive (i.e. privileged) functionality exposed by an OITF, in one or more of the cases defined in section <a href="#specific-security-requirements" class="sectionRef"></a>:</p><ul>
<li>A server SHALL specify the use of TLS for each HTML document that accesses privileged functionality (i.e. by using the &ldquo;https://&rdquo; URI scheme for the URL of the HTML document).
<li>A server SHALL expose a valid X.509v3 certificate during the TLS certificate handshake. 
<li>A server MAY request an OITF for certain permissions to access privileged functionality through a private certificate extension. If a server wants to do so, the server MAY include a private certificate extension called &ldquo;permissions&rdquo; as part of a valid X.509v3 certificate. If included, the &ldquo;permissions&rdquo; extension specifies a set of permissions through zero or more permission names. Allowed permissions names include the permission names as defined in section <a href="#permission-names" class="sectionRef"></a>.
</ul>
</section>
<section id="specific-security-requirements">
<h3>Specific security requirements for privileged JavaScript APIs</h3>
This section defines the specific security requirements for specific privileged JavaScript APIs, such as the tuner/broadcast, recording, content download and DRM related APIs as defined in sections <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a>, <a href="#scheduled-recording-apis" class="sectionRef"></a>, <a href="#content-download-apis" class="sectionRef"></a> and <a href="#content-service-protection-api" class="sectionRef"></a> in addition to the security requirements defined in sections <a href="#oitf-security-requirements" class="sectionRef"></a> and <a href="#server-security-requirements" class="sectionRef"></a>.
<section id="security-requirements-for-tuner-control-and-lineup">
<h4>Security requirements for tuner control and lineup</h4>
Exposure of the channel line up and the video/broadcast APIs for controlling the (local) tuner as specified in section <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a> SHALL adhere to the security requirements in sections <a href="#security-requirements-for-exposure-of-the-tuner-channel-lineup" class="sectionRef"></a> and <a href="#security-requirements-for-tuner-control" class="sectionRef"></a> .
<section id="security-requirements-for-exposure-of-the-tuner-channel-lineup">
<h5>Security requirements for exposure of the tuner channel lineup</h5>
Exposure of the channel line up of the (local) tuner as specified in section <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a> SHALL adhere to the following security requirements:<ul>
<li>the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to obtain the channel lineup of the (local) tuner. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL:
<li>not convey the Client Channel Listing to the server through a HTTP POST.
<li>not expose the Client Channel Listing to the DAE application through the <a href="#video-broadcast-getchannelconfig" class="apiRef">getChannelConfig()</a> method of the <a href="#video-broadcast" class="apiRef">video/broadcast</a> object. Attempts to access this method SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>.
</ul>
</section>
<section id="security-requirements-for-tuner-control">
<h5>Security requirements for tuner control</h5>
Control of the (local) tuner as specified in section <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a> SHALL adhere to the following security requirements:<ul>
<li>the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to control the (local) tuner. If the server does not have the necessary privileges or the server cannot be properly authenticated, the OITF SHALL deny requests to switch a local tuner to another channel by throwing an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>.
</ul>
</section>

</section>
<section id="security-requirements-for-recording">
<h4>Security requirements for recording</h4>
<p>The recording functionality as specified in section <a href="#scheduled-recording-apis" class="sectionRef"></a> SHALL adhere to the following security requirements:</p><ul>
<li><i><u>Recording of broadcasted content</u></i>: the OITF SHALL perform a security check (as defined by section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to schedule recordings of broadcasts. If the server does not have the necessary privileges or the server cannot be properly authenticated, the OITF SHALL deny a server's request to access the functionality of the <a href="#application-oipfrecordingscheduler" class="apiRef">application/oipfRecordingScheduler</a> object (as defined by section <a href="#application-oipfrecordingscheduler" class="sectionRef"></a>), and SHALL also not expose the Client Channel Listing, neither through the HTTP POST, nor through the getChannelConfig() method. Furthermore, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from the server attempts to access any properties or methods on the application/oipfRecordingScheduler object.
<li><i><u>Recording of current A/V content broadcasted</u></i>: the OITF SHALL perform a security check (as defined by section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to record the current broadcast (as defined in section <a href="#video-broadcast-extensions-recording-timeshift" class="sectionRef"></a>). If the server does not have the necessary privileges or the server cannot be properly authenticated, the OITF SHALL deny a server's request to start a recording of the broadcast currently rendered by the video/broadcast object by throwing an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>.
<li><i><u>Control over and exposure of scheduled recordings</u></i>: the OITF SHALL restrict the visibility and control over scheduled recordings to those scheduled recordings that were initiated through a server from the same FQDN that scheduled the recordings.
</ul>
</section>
<section id="security-requirements-for-content-download">
<h4>Security requirements for content download functionality</h4>
<p>The content download functionality as defined in section <a href="#content-download-apis" class="sectionRef"></a> SHALL adhere to the following security requirements:<ul>
<li><i><u>Initiating a download</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to initiate a download. If the server does not have the necessary privileges or the server cannot be properly authenticated, the OITF SHALL NOT start downloading the content after receiving a content-access description document as defined in section <a href="#content-access-download-descriptor" class="sectionRef"></a>. 
</ul>
<p>NOTE 1: The server is the server that served the HTML document or third-party notification that includes a link to a content-access description document. This is not necessarily the same server from which the content is downloaded.</p>
<p>NOTE 2: The URL from which a content item is downloaded (i.e. as specified by a &lt;ContentURL&gt; element in the content-access description document) does not have to be protected by TLS.</p>
</section>
<section id="security-requirements-for-drm">
<h4>Security requirements for DRM related functionality</h4>
<p>The DRM control functionality (i.e. the <code>application/oipfDrmAgent</code> embedded object) as defined in section <a href="#application-oipfdrmagent" class="sectionRef"></a> SHALL adhere to the following security requirements:</p><ul>
<li><u><i>Accessing the DRM agent</i></u>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the DRM agent, i.e. by accessing the DRM agent embedded object as specified in section <a href="#application-oipfdrmagent" class="sectionRef"></a>. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of its properties or methods on the DRM agent embedded object.
</ul>
</section>
<section id="security-requirements-for-ims">
<h4>Security requirements for IMS functionality</h4>
<p>The IMS functionality (i.e. the <code>application/oipfCommunicationServices</code> embedded object) as defined in section <a href="#communication-services-apis" class="sectionRef"></a> SHALL adhere to the following security requirements:</p><ul>
<li><i><u>Accessing the IMS embedded object</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the IMS functionality, i.e. by accessing the IMS embedded object as specified in section <a href="#communication-services-apis" class="sectionRef"></a>. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of the classes, properties or methods defined in section <a href="#communication-services-apis" class="sectionRef"></a>.
</ul>
</section>
<section id="security-requirements-for-metadata-processing">
<h4>Security requirements for metadata processing functionality</h4>
<p>The metadata processing functionality (i.e. <code>the application/oipfSearchManager</code> embedded object and other APIs) as defined in sections <a href="#metadata-apis" class="sectionRef"></a> and <a href="#video-broadcast-extensions-eit-pf" class="sectionRef"></a> SHALL adhere to the following security requirements:</p><ul>
<li><i><u>Accessing the search manager</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the search manager, i.e. by accessing the <code>application/oipfSearchManager</code> embedded object as specified in section <a href="#application-oipfsearchmanager" class="sectionRef"></a>. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of the properties or methods on the SearchManager embedded object.
<li><i><u>Accessing enhanced metadata</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to access the extensions to <code>video/broadcast</code> for accessing EIT p/f information specified in section <a href="#video-broadcast-extensions-eit-pf" class="sectionRef"></a>, in order to prevent misuse of the EIT p/f information If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access to the programmes property of the <code>video/broadcast</code> object specified in section <a href="#video-broadcast-extensions-eit-pf" class="sectionRef"></a>.
</ul>
</section>
<section id="security-requirements-for-configuration-and-settings">
<h4>Security requirements for configuration and settings functionality</h4>
<p>The configuration and settings functionality (i.e. the application/oipfConfiguration embedded object and other APIs) as defined in section <a href="#configuration-and-setting-apis" class="sectionRef"></a> SHALL adhere to the following security requirements:</p><ul>
<li><u><i>Reading and modifying configuration and/or settings</i></u>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the configuration functionality, i.e. by accessing the configuration embedded object as specified in section <a href="#application-oipfconfiguration" class="sectionRef"></a>. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of the classes, properties or methods defined in section <a href="#configuration-and-setting-apis" class="sectionRef"></a>.
</ul>
</section>
<section id="security-requirements-for-service-provider-controlled-oitf">
<h4>Security requirements for APIs for OITFs under the control of a service provider</h4>
<p>APIs for OITFs under the control of a service provider SHALL adhere to the following security requirements:</p><ul>
<li><i><u>Accessing the extended tuner control APIs</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the extended AVcontrol APIs as specified in section <a href="#channelconfig-class" class="sectionRef"></a>. If the server does not have the necessary privileges or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of the classes, properties or methods defined in section <a href="#channelconfig-class" class="sectionRef"></a>.
<li><i><u>Accessing the extended PVR APIs</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the extended PVR APIs as specified in section <a href="#application-oipfrecordingscheduler-control-extension" class="sectionRef"></a>. If the server does not have the necessary privileges or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of the classes, properties or methods defined in section <a href="#application-oipfrecordingscheduler-control-extension" class="sectionRef"></a>.
<li><i><u>Accessing the download manager</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the download manager, i.e. by accessing the application/oipfDownloadManager embedded object as specified in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a>. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of the classes, properties or methods specified in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a>.
<li><i><u>Accessing all downloads</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to manage downloads not initiated by the current application, i.e. by accessing the downloads property of the application/oipfDownloadManager embedded object as specified in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a>. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access this property.
<li><i><u>Accessing the power management APIs</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the setPowerState method in section <a href="#localsystem-class" class="sectionRef"></a>. If the server does not have the necessary privileges or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access that method.
</ul>
</section>
<section id="security-requirements-for-remote-diagnostics">
<h4>Security requirements for remote diagnostics and management API</h4>
<p>The remote diagnostics and management API (i.e. <code>application/oipfRemoteManagement</code>) as defined in section <a href="#application-oipfremotemanagement" class="sectionRef"></a>) SHALL adhere to the following security requirements:</p><ul>
<li><i><u>Accessing remote diagnostics and management parameters and/or settings</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the remote diagnostics and management functionality, i.e. by accessing the <a href="#application-oipfremotemanagement" class="apiRef">application/oipfRemoteManagement</a> embedded object as specified in section <a href="#application-oipfremotemanagement" class="sectionRef"></a>. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of the classes, properties or methods defined in section <a href="#application-oipfremotemanagement" class="sectionRef"></a>.
</ul>
</section>
<section id="security-requirements-for-parental-control">
<h4>Security requirements for parental control manager</h4>
<p>The parental control manager API (i.e. <code>application/oipfParentalControlManager</code>) as defined in section <a href="#application-oipfparentalcontrolmanager" class="sectionRef"></a>) SHALL adhere to the following security requirements:</p><ul>
<li><i><u>Accessing parental control manager functionality</u></i>: the OITF SHALL perform a security check (as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>) to see if the server has the necessary privileges to interact with the parental control manager functionality, i.e. by accessing the <code>application/oipfParentalControlmanager</code> embedded object as specified in section <a href="#application-oipfparentalcontrolmanager" class="sectionRef"></a>. If the server does not have the necessary privileges, or the server cannot be properly authenticated, the OITF SHALL throw an error as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a> when an application loaded from that server attempts to access any of the classes, properties or methods defined in section <a href="#application-oipfparentalcontrolmanager" class="sectionRef"></a>.
</ul>
</section>
</section>
<section id="permission-names">
<h3>Permission names</h3>
<p>This section describes a non-limited set of permission names that MAY be included as part of the &ldquo;permissions&rdquo; extension of a X.509v3 certificate as defined in sections <a href="#oitf-security-requirements" class="sectionRef"></a> and <a href="#server-security-requirements" class="sectionRef"></a>:</p><ul>
<li>&ldquo;<b><i>permission_tuner control_lineup</i></b>&rdquo;: this permission name allows a server to receive/fetch the tuner's channel line-up and to switch an OITF's local tuner to another channel and to functionality as specified in section <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a> 
<li>&ldquo;<b><i>permission_tuner_lineup</i></b>&rdquo; : this permission name allows a server to receive/fetch the tuner's channel line-up as specified in section <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a>. 
<li>&ldquo;<b><i>permission_tuner_control</i></b>&rdquo; : this permission name allows a server to switch an OITF's local tuner to another channel as specified in section <a href="#scheduled-content-and-hybrid-tuner-apis" class="sectionRef"></a>. 
<li>&ldquo;<b><i>permission_recording</i></b>&rdquo; : this permission name allows a server to receive/fetch the tuner's channel line-up, and to instantiate the scheduler object (as defined by section <a href="#application-oipfrecordingscheduler" class="sectionRef"></a>) and access its functionality, and to access the additional functionality as specified in section <a href="#video-broadcast-extensions-recording-timeshift" class="sectionRef"></a> for the video/broadcast object to record and timeshift the current broadcast.
<li>&ldquo;<b><i>permission_download</i></b>&rdquo; : this permission name allows a server to initiate downloads.
<li>&ldquo;<b><i>permission_drmagent</i></b>&rdquo; : this permission name allows a server to interact with the DRM agent, i.e. by accessing the DRM agent embedded object as specified in section <a href="#application-oipfdrmagent" class="sectionRef"></a>
<li>&ldquo;<b><i>permission_metadata</i></b>&rdquo; : this permission name allows a server to access the DVB EIT p/f information of the current channel through the &ldquo;programmes&rdquo; property of the video/broadcast object, as specified in section <a href="#video-broadcast-extensions-eit-pf" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_metadata_search</i></b>&rdquo; : this permission name allows a server to access the search functionality provided client-side metadata search functionality (as defined in section <a href="#application-oipfsearchmanager" class="sectionRef"></a>).
<li>&ldquo;<b><i>permission_extendedAV</i></b>&rdquo; : this permission name allows a server to interact with the extended A/V control functionality provided by the OITF, as defined in section <a href="#av-control-extensions-for-playing-media-objects" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_recordingsmanager</i></b>&rdquo; : this permission name allows a server to interact with the recording scheduler on the OITF using the APIs defined in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> to manage recordings initiated by the current application.
<li>&ldquo;<b><i>permission_recordingsmanager_all</i></b>&rdquo; : this permission name allows a server to interact with the recording scheduler on the OITF using the APIs defined in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> to manage all recordings, including those initiated by other applications.
<li>&ldquo;<b><i>permission_recordingsmanager_samedomain</i></b>&rdquo; : this permission name allows a server to interact with the recording scheduler on the OITF using the APIs defined in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> and manage recordings initiated by applications from the same FQDN.
<li>&ldquo;<b><i>permission_clientCOD</i></b>&rdquo; : this permission name allows a server to interact with the CoD catalogue browsing functionality provided by the OITF, as defined in section <a href="#metadata-apis" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_settings</i></b>&rdquo; : this permission name allows a server to modify user settings and configuration using the APIs defined in section <a href="#application-oipfconfiguration" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_downloadmanager</i></b>&rdquo; : this permission name allows a server to interact with the download manager on the OITF using the APIs defined in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> to control downloads initiated by the current application.
<li>&ldquo;<b><i>permission_downloadmanager_all</i></b>&rdquo; : this permission name allows a server to interact with the download manager on the OITF using the APIs defined in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> and manage all downloads, including those initiated by other applications.
<li>&ldquo;<b><i>permission_downloadmanager_samedomain</i></b>&rdquo; : this permission name allows a server to interact with the download manager on the OITF using the APIs defined in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a> and manage downloads initiated by applications from the same FQDN. 
<li>&ldquo;<b><i>permission_ims</i></b>&rdquo;: this permission name allows a server to interact with an IMS Gateway using the APIs defined in section <a href="#communication-services-apis" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_remotemanagement</i></b>&rdquo;: this permission name allows a server to interact with an remote diagnostics and management API defined in section <a href="#application-oipfremotemanagement" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_gatewayinfo</i></b>&rdquo; : this permission name allows a server  to interact with the gateway discovery functionality provided by the client, as defined in sections <a href="#gateway-discovery-and-control" class="sectionRef"></a> and <a href="#gateway-discovery-and-control-apis" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_parentalcontrolmanager</i></b>&rdquo; : this permission name allows a server to interact with the parental control manager on the OITF using the APIs defined in section <a href="#parental-rating-and-parental-control-apis" class="sectionRef"></a> to override the parental control settings of an OITF.
<li>&ldquo;<b><i>permission_widget</i></b>&rdquo; : this permission name allows a server to interact with installed Widgets using the Widget APIs defined in section <a href="#widgets-support" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_wakeup</i></b>&rdquo; : this permission name allows a server to setup wake-up requests using the APIs defined in section <a href="#localsystem-class" class="sectionRef"></a>.
<li>&ldquo;<b><i>permission_set_power</i></b>&rdquo; : this permission name allows a server to set the power state to ON or ACTIVE_STANDBY using the <a href="#localsystem-setpowerstate" class="apiRef">setPowerState()</a> method defined in section <a href="#localsystem-class" class="sectionRef"></a>.
</ul>
</section>
<section id="loading-documents-from-different-domains">
<h3>Loading documents from different domains</h3>
<p>The contents of an &lt;iframe&gt;, &lt;embed&gt; or &lt;object&gt; element may be retrieved from an FQDN other than the one from which the top-level document is loaded. In this case, the OITF SHALL enforce security restrictions between the contents of the element and the parent document. These restrictions may be based on the nested browsing context as defined in section 5.1.1 (&ldquo;Nested Browsing Contexts&rdquo; of the HTML5 specification as referenced by [[!OIPF_WSTVP2]] and the security restrictions formalised in section 5.2.1 (&ldquo;Security&rdquo;) of  the HTML5 specification as referenced by [[!OIPF_WSTVP2]], excluding the features not included in this specification.</p>
<p>Documents SHALL be assigned the permissions associated with the FQDN from which they were loaded, as defined in section <a href="#oitf-security-requirements" class="sectionRef"></a>, rather than the permissions associated with the initial document of the application. For example documents loaded in an &lt;iframe&gt; element may be granted a different set of permissions from the top-level document that contains the &lt;iframe&gt; element. Similarly, following a link to a document from a different FQDN may result in the newly-loaded document having a different set of permissions than those granted to the previous document even though they are within the same application boundary.</p>
<p>As described in section <a href="#application-boundaries" class="sectionRef"></a>, for files requested with XMLHttpRequest, the Same-Origin Policy SHALL be extended using the application domain as defined in section <a href="#application-boundaries" class="sectionRef"></a>.</p>
</section>
</section>
<section id="user-authentication">
<h2>User Authentication</h2>
The OITF SHALL adhere to the user authentication requirements as specified in <a href="volume7.html#identification-authentication" class="extRef">section 5</a> of [[.OIPF_CSP2]].
</section>
<section id="dlna-rui-remote-control">
<h2>DLNA RUI Remote Control</h2>
The communication from the remote control device (DLNA RUIC) is secured by establishing a secure connection using SSL or TLS (i.e. HTTPS) if a <code>&lt;security&gt;</code> element in a DLNA RUIC Capability Description indicates that the Remote UI Client supports setting up a secure connection with the Remote UI Server (see section 5.2.1 of [[!CEA-2014-A]] for more information). It is the responsibility of the DAE application to require the DLNA RUIC to verify the user behind the remote control is actually the intended user. For example, this may be established by requiring a PIN number to be entered. It is outside the scope of this specification what measures are taken by the DAE application to ensure correct identification of the user.
</section>
</section>

<!-- section 11 -->
<section id="dae-widgets">
<h1>DAE Widgets</h1>
<p>DAE Widgets are a specialization of standard DAE applications. DAE Widgets are a profile of W3C Widgets. A mandatory requirement in the referenced W3C Widgets 1.0 specifications remains mandatory also for DAE Widgets and recommended and optional requirements in W3C Widgets 1.0 remain recommended and optional for the DAE Widgets, unless explicitly specified differently inside this document.</p>
<section id="widgets-packaging-and-configuration">
<h2>Widgets Packaging and Configuration</h2>
<p>A Widget SHALL be packaged in order to allow a single download and installation on an OITF. The packaging format for the files of a Widget is defined in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#zip-archive" class="extRef">section 5</a> of [[!Widgets-Packaging]]. Content inside the Widget package has to be organized according to <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#widget-packages" class="extRef">section 6</a> of [[!Widgets-Packaging]].</p>
<p>Each Widget package SHALL contain a configuration document as defined in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#configuration-document" class="extRef">section 7</a> of [[!Widgets-Packaging]]. All the attributes of the <code>&lt;widget&gt;</code> element are supported with the following exceptions and clarifications:</p><ul>
<li>This specification does not mandate support for any view mode (as defined in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#the-id-attribute" class="extRef">section 7.6.1</a> of [[!Widgets-Packaging]])
<li>&ldquo;id&rdquo; is mandatory for a DAE Widget. If this attribute is present in the manifest then the OITF SHALL use it. Otherwise the OITF should generate it internally and assign to the Widget.
</ul>
<p>Widgets also support Internationalization and Localization as defined in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#internationalization-and-localization" class="extRef">section 8</a> of [[!Widgets-Packaging]].</p>
<p>The steps for processing a Widget package and associated processing rules are described in <a href="http://www.w3.org/TR/2011/REC-widgets-20110927/#steps-for-processing-a-widget-package" class="extRef">section 9</a> of [[!Widgets-Packaging]].</p>
</section>
<section id="widgets-access-request">
<h2>Access Request</h2>
<p>A Widget running on a OITF can request access to potentially sensitive APIs or resources. In order to avoid data leaking a security model for Widgets is imposed. DAE Widgets SHALL run in a &ldquo;Widget execution scope&rdquo;, defined in <a href="http://www.w3.org/TR/2012/REC-widgets-access-20120207/#definitions" class="extRef">section 2</a> of [[!Widgets-Access]] as &ldquo;the scope (or set of scopes, seen as a single one for simplicity's sake) being the execution context for code running from documents that are part of the Widget package&rdquo;. Note that section 3 of the same specification states that &ldquo;A user agent must prevent the Widget execution scope from retrieving network resources, using any method (API, linking, etc.) and for any operation, unless the user agent has granted access to an explicitly declared access request.&rdquo;</p>
<p>DAE Widgets SHALL also support mechanisms to define network permissions as defined in sections <a href="http://www.w3.org/TR/2012/REC-widgets-access-20120207/#conformance" class="extRef">3</a> and <a href="http://www.w3.org/TR/2012/REC-widgets-access-20120207/#user-agent" class="extRef">4</a> of [[!Widgets-Access]].</p>
<p>Note that according to [[!Widgets-Access]] an OITF &ldquo;may grant access to certain URI schemes without the need of an access request if its security policy considers those schemes benign&rdquo;. Furthermore a OITF &ldquo;may deny access requests made via the access element (e.g. based on a security policy, user prompting, etc.)&rdquo;.</p>
</section>
<section id="widgets-interface">
<h2>Widget Interface</h2>
<p>A set of application programming interfaces (APIs) and events are defined for Widgets that enable baseline functionality such as exposing Widget metadata and runtime information.</p>
<p>The Widget interface primarily provides access to metadata derived from processing the Widget's configuration document. DAE Widgets SHALL support the Widgets interface as defined in <a href="http://www.w3.org/TR/2012/PR-widgets-apis-20120522/#the-windowwidget-interface" class="extRef">section 5</a> of [[!Widgets-APIs]]. This specification doesn't define any scheme handlers for the openURL() method.</p>
<p>The Widget interface makes use of the Storage interface defined in <a href="http://www.w3.org/TR/2011/CR-webstorage-20111208/#storage" class="extRef">section 4.1</a> of [[!Web-Storage]]. As an extension of that specification, Protected Keys in a Storage Area as defined in <a href="http://www.w3.org/TR/2012/PR-widgets-apis-20120522/#usage-example" class="extRef">section 6.1</a> of [[!Widgets-APIs]] are also allowed.</p>
<p>Note that as defined in <a href="http://www.w3.org/TR/2012/PR-widgets-apis-20120522/#the-widget-interface" class="extRef">section 6</a> of [[!Widgets-APIs]] an OITF SHOULD limit the total amount of space allowed for storage areas per Widget. Furthermore an OITF SHALL support key and values at least 4kB long.</p>
</section>
<section id="widget-digital-signature">
<h2>Digital Signature</h2>
<p>Widget authors and distributors SHALL digitally sign Widgets as a mechanism to ensure continuity of authorship and distributorship. Prior to instantiation, an OITF SHOULD use the digital signature to verify the integrity of the Widget package and to confirm the signing key(s).</p>
<p>The process of digitally signing a W3C Widget is defined in [[!Widgets-DigSig]].</p>
<p>Note that as defined in <a href="http://www.w3.org/TR/2011/PR-widgets-digsig-20110811/#signature-verification" class="extRef">section 9</a> of [[!Widgets-DigSig]] in case of signature validation failure the user SHALL be notified; means or format of a failure notification are left up to implementers. The OITF MAY ask the user if the Widget should be installed even if the validation failed or if the signature is missing. If the user accept launching the Widget, it SHALL be run without access to privileged API.</p>
</section>
</section>

<!-- section 12 -->
<section id="dae-performance">
<h1>Performance</h1>
<section id="graphics-performance">
<h2>Graphics Performance</h2>
<section>
<h3>Introduction (informative)</h3>
<p>The performance metrics here have been derived from a set of graphics benchmarks programs &mdash; the can be run from <a href="http://orange-opensource.github.com/orangemark/">http://orange-opensource.github.com/orangemark/</a>. Use of these benchmark programs is OPTIONAL in the present document. It is up to a testing or certification regime where graphics performance is relevant to decide whether to use them as-is, to use a derivative or to do something completely different.</p>
<p>Performance is expressed in a power of 2 logarithmic scale of the complexity of a page which can be updated at 25Hz. For example, when moving a frame around;</p><ul>
<li>1 means moving one frame around
<li>2 means moving 2 frames around simultaneously
<li>3 means moving 4 frames around simultaneously
<li>4 means moving 8 frames around simultaneously
<li>5 means moving 16 frames around simultaneously
</ul>
<p>Although the benchmark programs measure performance up to 10, typical TV use-cases are unlikely to benefit from values higher than 5. Values of 1 or 2 are unlikely to offer a good user experience, hence this section focuses on features that can be supported with values 3, 4 or 5.</p>
</section>
<section>
<h3>Performance levels</h3>
<p>Graphics performance is defined in terms of a number of performance levels. This version of the specification defines two levels, &ldquo;1&rdquo; and &ldquo;2'&rdquo;. An OITF that advertises level &ldquo;1&rdquo; graphics performance in its device capabilities SHALL comply with the minimum performance defined for that level. An OITF that advertises level &ldquo;2&rdquo; graphics performance in its device capabilities SHALL comply with the minimum performance defined for that level. An OITF MAY not comply with the minimum performance for even level &ldquo;1&rdquo;  in which case it SHALL NOT advertise either levels &ldquo;1&rdquo; or &ldquo;2&rdquo; in its device capabilities.</p>
<p>To be clear, in the present document, it is OPTIONAL for an OITF to support even graphics performance level &ldquo;1&rdquo;.</p>
</section>
<section>
<h3>Minimum 2D Graphics Performance</h3>
<p>The following table defines the minimum performance that SHALL be supported for animations using CSS transitions of the properties listed in order for an OITF to advertise support for levels 1 and 2 respectively.
Values in this table indicate the number of elements of the specified target being animated simultaneously. The number is expressed as a power of 2, i.e. a value of 3 SHALL mean 4 simultaneous animations, a value of 5 SHALL mean 16 simultaneous animations.</p>
<table class="simple" id="minimum-2d-graphics-performance">
<caption>Table ####: Minimum 2D graphics performance</caption>
<thead><tr><th>Target for the CSS Property</th><th>CSS Property being animated</th><th>Test</th><th>Level 1</th><th>Level 2</th></tr></thead>
<tr><td rowspan="11">Frame</td>
<td>background-color</td><td>2d/frame-color</td><td>3</td><td>5</td></tr>
<tr><td>background-color, opacity</td><td>2d/frame-color-alpha</td><td>3</td><td>5</td></tr>
<tr><td>left, top</td><td>2d/frame-left-top</td><td>3</td><td>5</td></tr>
<tr><td>left, top, opacity</td><td>2d/frame-opacity</td><td>3</td><td>5</td></tr>
<tr><td>transform: rotate</td><td>2d/frame-rotate</td><td>No requirement</td><td>5</td></tr>
<tr><td>transform: scale</td><td>2d/frame-scale</td><td>3</td><td>5</td></tr>
<tr><td>transform: skew</td><td>2d/frame-skew</td><td>No requirement</td><td>5</td></tr>
<tr><td>transform: matrix</td><td>2d/frame-matrix</td><td>3</td><td>5</td></tr>
<tr><td>border-radius</td><td>2d/frame-border-radius</td><td>3</td><td>5</td></tr>
<tr><td>width, height</td><td>2d/frame-width-height</td><td>3</td><td>5</td></tr>
<tr><td>linear-gradient</td><td>2d/frame-linear-gradient</td><td>3</td><td>5</td></tr>

<tr><td rowspan="6">Image</td>
<td>left, top</td><td>2d/image-top-left</td><td>3</td><td>5</td></tr>
<tr><td>left, top, opacity</td><td>2d/image-opacity</td><td>3</td><td>5</td></tr>
<tr><td>transform: rotate</td><td>2d/image-rotate</td><td>No requirement</td><td>5</td></tr>
<tr><td>transform: scale</td><td>2d/image-scale</td><td>3</td><td>5</td></tr>
<tr><td>transform: skew</td><td>2d/image-skew</td><td>No requirement</td><td>5</td></tr>
<tr><td>transform: matrix</td><td>2d/image-matrix</td><td>3</td><td>5</td></tr>

<tr><td rowspan="6">Text</td>
<td>left, top</td><td>2d/text-left-top</td><td>3</td><td>5</td></tr>
<tr><td>left, top, opacity</td><td>2d/text-opacity</td><td>3</td><td>5</td></tr>
<tr><td>transform: rotate</td><td>2d/text-rotate</td><td>No requirement</td><td>5</td></tr>
<tr><td>transform: scale</td><td>2d/text-scale</td><td>3</td><td>5</td></tr>
<tr><td>transform: skew</td><td>2d/text-skew</td><td>No requirement</td><td>5</td></tr>
<tr><td>text-shadow</td><td>2d/text-emboss</td><td>3</td><td>5</td></tr>
</table>
</section>

<section>
<h3>Minimum 3D Graphics Performance </h3>
<p>No minimum performance is defined for 3D transforms. </p>
</section>
<section>
<h3>Minimum Canvas Performance</h3>
<p>No minimum performance is defined for graphics using the Canvas element.</p>
</section>
<section>
<h3>Minimum WebGL Performance</h3>
<p>No minimum performance is defined for WebGL graphics.</p>
</section>
<section>
<h3>Performance Measurement </h3>
<p>The source for the benchmark suite can be found at <a href="https://github.com/Orange-OpenSource/orangemark">https://github.com/Orange-OpenSource/orangemark</a>, version &ldquo;V1.0.1&rdquo;. </p>
<p>In order to address variation between successive runs of the tests, it is RECOMMENDED that any testing or certification regime that references these graphics benchmarks programs, or a derivative of them, require them to be run several times and the highest and lowest runs discarded.
The graphics benchmark programs measure frame rate using the <code>mozPaintCount</code> property (if supported), otherwise the <code>requestAnimationFrame()</code> method (if supported &mdash; see [[TIMING-CONTROL]]) or a polyfill based on <code>setTimeout()</code>. OITFs MAY support other private or native mechanisms for measuring the frame rate. This specification is silent about the acceptability of these private or native mechanisms, this is a matter for any testing or certification regime that references these graphics benchmark programs.</p>
</section>

</section>
</section>


<!-- Annex A -->
<section class="appendix">
<h1>Change History (Informative)</h1>
<p>This Annex is intentionally left blank.</p>
</section>

<!-- Annex B -->
<section id='ce-html-profiling' class="appendix">
<h1>VOID</h1>
</section>

<!-- Annex C -->
<section id='design-rationalle' class="appendix">
<h1>Design Rationalle (Informative)</h1>
<section id="the-application-model">
<h2>The application model</h2>
<p>As specified in section <a href="#differences-applications-and-web-pages" class="sectionRef"></a>, applications are recorded within a hierarchy of applications. This hierarchy has a number of benefits for an environment where multiple applications may be executing simultaneously, including:</p><ul>
<li>Clear separation of applications so that permissions granted to one application cannot be exploited by another.
<li>Simpler event dispatch, whether for key events or externally triggered events such as parental control changes, caller ID integration, IM chat messaging, etc.
<li>The ability to deploy new applications without affecting other applications (either UI or structure).
<li>The ability for service providers to manage groups of applications, including invisible applications.
</ul>
<p>Each object representing an application possesses an interface that provides access to methods and attributes that are uniquely available to applications. For example, the facilities to create and destroy applications are accessed through such methods.</p>
<p>Development and maintenance efficiencies are gained through distinct application boundaries. Code reuse is offered through the application tree, permitting applications to export facilities as desired (for example, channel change logic may be embedded in the &ldquo;zapper&rdquo; application and exported to an EPG application). The paired advantages of compartmentalisation and code re-use are of increasing value as the number of authoring entities and applications grows &mdash; what is of marginal additional value for one authoring entity and three applications is of significant value for 10 authoring entities and 50 applications.</p>
</section>
</section>

<!-- Annex D -->
<section id='cod-clarification' class="appendix">
<h1>Clarification of Download COD, Streaming COD and CSP Interfaces (Informative)</h1>
<section>
<h2>Introduction</h2>
<p>There are many different usage models and scenarios that one can think of when dealing with protected content and the interactions the user or the device may have with a service provider. This includes usage models regarding user registration, domain management, license acquisition, downloading content, etc. This informative annex aims to clarify the usage of the interfaces as specified in sections <a href="#content-download" class="sectionRef"></a>, <a href="#streaming-cod" class="sectionRef"></a>, <a href="#content-download-apis" class="sectionRef"></a> and <a href="#content-service-protection-api" class="sectionRef"></a>. in the context of these interactions. However, this annex will only show some of the generic mechanisms as offered by these interfaces, not only the browser interfaces, but also including some of the local interfaces on the device (that actually do not need to be standardized) In the figure below these are indicated by dotted lines.</p>
<p>The main scenario that we envision is the following:</p>
<figure id="main-scenario">
<img alt="FIGURE 17" src="images/MainScenario.png" />
<figcaption>Figure ####: Main scenario</figcaption>
</figure>
<ol>
<li>The OITF shows the UI of the CoD store. With this UI the user is able to interact with the CoD store to do things, such as user registration, browsing the content offered by the CoD store, and purchase a license. 
<p>
This can be done inside the browser using a standard CE-HTML interface. In the figure above, this is identified by interface a. 
In those deployments where the OITF supports the metadata CG client, an embedded application or a DAE application can make use of metadata provided through a metadata CG client. This is identified by interface g*.</p>
<li>After purchasing/selection of the content the selected content needs to be fetched. To this end, the download manager or the A/V embedded object needs to be triggered with information on how to fetch the content. This is done by using a special descriptor, with an easily identifiable MIME type &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo; in case of download, and &ldquo;<code>application/vnd.oipf.ContentAccessStreaming+xml</code>&rdquo; in case of streaming. This is indicated by interfaces d0, d1, d2, e0, e1, and e2.
<p>For certain steps in these interactions, the CoD store may need to interact with the DRM agent. This can be done by talking directly to the DRM agent during a browser session using interfaces b0) and b1). Alternatively, the &lt;DRMControlInformation&gt; element of the content access descriptor can be used to convey DRM specific messages to the DRM agent. This is indicated by interface d3.</p>
<p>Note that both the DRM agent and Download manager are autonomous components that will be actively performing their duties, irrespective whether there is an active browser session or not. They will have their own interaction with e.g. the license server and download server, and possibly with the user. These interactions are identified by interfaces c1, c2, d4, d5. </p>
<li>The download manager or A/V player fetch the content, as indicated by interfaces d4 and e2. 
<li>Once the content is fetched, playback can be started in the A/V player. When the stream is protected, the A/V player will have to get a license from the DRM agent using interface f.
</ol>
</section>
<section>
<h2>List of interfaces</h2>
<p><b>Interface a: browse, select and purchase content from CoD store</b></p>
<p>This interface is used to interact with the CoD store for operations such as user registration, browsing the content offered by the CoD store, and purchase a license. This is a standard CE-HTML/HTTP interface.</p>
<p><br /><b>Interface b*: In-session interaction from web page with underlying DRM agent</b></p>
<p>Interface b0 (and the related interface b1) is the application/oipfDrmAgent JavaScript embedded object interface as defined in section <a href="#configuration-and-setting-apis" class="sectionRef"></a>. This interface will allow messages to be exchanged between pages from the CoD store and the underlying DRM agent, whilst the user is having a user interface session with the CoD store. Examples of these messages are Marlin Action tokens. This is useful to enable scenarios, such as subscription license acquisition, registration, domain management, etc.</p>
<p>The interface basically consists of one method: sendDRMMessage(String msgType, String msg), which is very generic in the sense that any kind of message can be exchanged. The exact payload and types of messages that could be exchanged is defined in the [[.OIPF_CSP2]]. An example of such message could be:</p><pre class="javascript">
pluginElement = document.getElementByID("drmplugin");
pluginElement.sendDRMMessage("application/vnd.marlin.drm.actiontoken+xml", 
                             "&lt;marlin&gt;...&lt;/marlin&gt;",
                             "urn:dvb:casystemid:19188");
...
&lt;object id="drmplugin" type="application/oipfDrmAgent"/&gt;
</pre>
<p>Note that this API is designed to be asynchronous in nature, because certain interactions may take a indeterminate amount of time. Therefore, it is not wise to make the method synchronous, since that could block the JavaScript engine. To this end we have defined an event handler: onDRMMessageResult, to register a callback function that will be called when the DRM agent completed handling of the message. For example:</p><pre class="javascript">
function callbackF(String msgID, String resultMsg, Integer resultCode) {
	...
}
document.getElementByID("drmplugin").onDRMMessageResult = callbackF;
</pre>
<p>An equivalent DOM2 event is also generated.</p>
<p>Content authors SHOULD be aware of the asynchronous nature of the API. Only after having received the callback message, the web page can assume that the DRM agent has handled the DRM message. The service author may need to define some visual cues to the user if he would like the user to wait for certain actions to finish. </p>
<p><br><b>Interface c*: Autonomous out-of-session interaction between DRM agent and CoD store</b></p>
<p>Interface c1 is the collection of interfaces between the DRM agent, the CoD store, the license server, etc. as defined in the [[.OIPF_CSP2]]. The interaction is typically done outside the scope of the browser, and also without the user being involved. In the few cases where the user would be involved, the device will typically have its own &ldquo;local&rdquo; user interface  to handle the interaction with the user. In some of these the DRM agent would need to open a web page to the originating CoD store, so that the user could resolve the issue directly with the store (e.g. using the rightsURL extracted from the MPEG2_TS). Since the user could be doing other things at that moment, it may not be appropriate to popup/replace the current browser session without the user consent. Therefore, the DRM agent could issue a notification event that will get listed along similar lines to a third-party notification event. The user would be notified that his attention is required with respect to the DRM agent, and can then decide to take action and launch the browser.</p>
<p>In the figure above, these UI interactions are identified by interface c2 and c3. These interfaces however are typically local inside the OITF, and are not specified in more detail. </p>
<p><br><b>Interface d*: Downloading content</b></p>
<p>These interfaces are used for downloading content. In order to trigger the download, a special content-access descriptor  (the content access download descriptor) with an easily identifiable MIME type &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo; is used. This descriptor contains all the relevant data related to fetch the content. This content-access descriptor is typically provided by the CoD store. A browser application can fetch this descriptor in various different ways, e.g. by following a link or through an XMLHttpRequest. This is identified by interface d0. The content access download descriptor and MIME type are defined in Annex <a href="#content-access-descriptor-formats" class="sectionRef"></a>. It contains elements, such as &lt;ContentURL&gt; which indicates where the content item can be fetched, and &lt;MetadataURL&gt; to indicate where additional metadata, such as genre, subtitles, artwork, etc. can be retrieved from.</p>
<p>Interface d1) (and related interface d2 are used to trigger/register the download with the download manager. This is done by handing over the content access download descriptor to the download manager by calling method <a href="#downloadtrigger-registerdownload" class="apiRef">registerDownload()</a> on the <a href="#application-oipfdownloadtrigger" class="apiRef">application/oipfDownloadTrigger</a> embedded object after retrieving the content-access descriptor e.g. through XMLHttpRequest. Once the download is registered, the download manager will take care that the content is downloaded. Since this may be a lengthy task, the download manager is an independent process from the browser, that will perform its duty in the background even if the browser is closed. By making the download manager an independent process of the browser, the user can in the meantime do other things.</p>
<p>Interface d3 is a local interface that is used to pass optional DRM messages carried in the content-access descriptor from the Download manager to the DRM agent. These messages are included as part of one or more <code>&lt;DRMControlInformation&gt;</code> element inside the content access download descriptor (as defined by Annex <a href="#content-access-descriptor-formats" class="sectionRef"></a>). These may include messages (such as a Marlin preview license) in cases where license information and the content to be downloaded can be packaged together.</p>
<p>Interface d4 is the actual interface for downloading the content. The protocols that can be used for downloading content are defined in the Open ITPV Forum Protocols specification document. The default protocol is HTTP, with support for HTTP Range requests. The HTTP Range requests are used in order for downloads to be able to resume after e.g. network failure or device power-down, because as mentioned above, the download manager is an autonomous component that must continue downloading the requested content items as a background process, even after a device power-down or network failure, until it succeeds or the user has given permission to terminate the download. </p>
<p>Interface d5 defines an interface to enable error recovery for the download mechanism. It could be used to recover from errors or other situations that lead to the corruption or deletion of the content/licenses or a current download to fail. An example usage is as follows: to be able to refetch the content, and its licenses from the CoD store the OITF may synchronize with the CoD store by issuing a secure HTTP GET request to the URL of element <code>&lt;OriginSite&gt;</code> concatenated with &ldquo;<code>/synchronize</code>&rdquo; as defined by the content-access descriptor, after which the IPTV application offering the content-download replies with an XML document describing the list of zero or more content IDs that had previously been downloaded by the given user (i.e. it is assumed that the IPTV application offering the content download still remembers which content a user has bought and downloaded before), using for example the following format: </p>
<pre class="xml-schema">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" 
           attributeFormDefault="unqualified"&gt;
  &lt;xs:element name="synchronizelist" type="SynchronizeType"/&gt;
  &lt;xs:complexType name="SynchronizeType"&gt;
    &lt;xs:sequence&gt;
       &lt;xs:element name="content" type="ContentType"/&gt;
     &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt; 
  &lt;xs:complexType name="ContentType"&gt;
     &lt;xs:sequence&gt;
       &lt;xs:element name="content_ID" type="xs:string" minOccurs="0"
          maxOccurs="unbounded"/&gt;
     &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt; 
&lt;/xs:schema&gt;
</pre>
<p>Example:</p>
<pre class="xml-document">
&lt;synchronizelist&gt;
   &lt;content&gt;
      &lt;content_ID&gt;item 1&lt;/content_ID&gt; 
      &lt;content_ID&gt;item 2&lt;/content_ID&gt;
      ...
   &lt;/content&gt;
 &lt;/synchronizelist&gt;
</pre>
<p>NOTE: To authenticate the user, cookies or single sign on may be used.</p>
<p>The OITF MAY use this information to decide which content and which licenses to refetch. Refetching the content is done by issuing a secure HTTP GET request to the following URL:</p>
<pre>
&lt;OriginSite&gt; + "/synchronize" + "?" + a &lt;content_ID&gt; value
</pre>
<p>after which the application offering the content download replies with the appropriate information to retrigger the download by providing the appropriate content access download descriptor in order to trigger the download manager and DRM agent to redownload the content and related licenses.</p>
<p>Interface d6:  Although the download manager is an autonomous process, the user may sometimes want to view or control the state of the download manager. To this end, the download manager will typically offer its own user interface, which allows the user to manage the ongoing downloads (e.g. suspend/resume, cancel) and monitor the progress of the items that are being downloaded. </p>
<p>In retail deployments this is typically a local user interface, for which no protocol needs to be defined. However, since it may be useful for the user to have a quick overview of the current downloads, in section <a href="#application-oipfmdtf" class="sectionRef"></a> of this document a visualization embedded object called application/oipfStatusView has been defined by which a (third-party) server provider could include an overview of the status of the download manager as part of its UI. This is interface d6 in the figure above.</p>
<p>NOTE: for managed deployments JavaScript interfaces may be needed to have more control over the UI of the download manager. This is covered by the download manager APIs in section <a href="#application-oipfdownloadmanager" class="sectionRef"></a>.</p>

<p><br><b>Interface e*: Unicast Streaming and playback of downloaded content using A/V Control object</b></p>
<p>The A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> may be used to render unicast streaming content triggered by a content-access streaming descriptor (as specified in section <a href="#using-av-control-for-content_fragments" class="sectionRef"></a>) and may be used to play back (partially) downloaded content by using the method setSource as specified in section <a href="#av-control-extensions-for-playing-media-objects" class="sectionRef"></a>. </p>
<p>Interface e0 can be used to pass for a content access streaming descriptor to set up a protected stream, by passing through interface e1 the necessary information for the A/V player to set up the stream through interface e2, and for passing included &lt;DRMControlInformation&gt; messages to the DRM agent for DRM protection of the streamed content using interface f. </p>
<p>Interface e0 can also be used to get feedback from the A/V player (such as DRM related playback errors as defined in section <a href="#video-broadcast-extensions-parental-ratings" class="sectionRef"></a>) in case of playing streaming content or partially downloaded content (through method <code>setSource()</code>).</p>
<p><br><b>Interface f: Request license</b></p>
<p>The A/V Player will render the content. When the content is protected, the A/V embedded object will have to get the necessary keys from the DRM agent using interface f in order to decrypt the content.</p>
<p>If the content is played inside the browser, interface e1 defines a callback event &ldquo;<code>onDRMRightsError</code>&rdquo; to allow the page to handle DRM-related errors (in addition to c1).</p>

<p><br><b>Interface g*: Local metadata based applications</b></p>
<p>These interfaces are for use with local OITF embedded and DAE applications that may wish to use a metadata CG client for browsing and selecting the content.</p>
</section>
<section>
<h2>Additional notes about Content-on-Demand</h2>
<p>For a detailed specification of how devices and users are authenticated, we refer to [[.OIPF_CSP2]]. For the security model related to accessing the DRM agent and Download manager from an external source, such as a web page (i.e. to open up the browser's sandbox), we refer to section <a href="#application-service-security" class="sectionRef"></a>.
</section>
</section>

<!-- Annex E -->
<section id='content-access-descriptor-formats' class="appendix">
<h1>Content Access Descriptor Syntax and Semantics</h1>
<section id="content-access-download-descriptor-format">
<h2>Content Access Download Descriptor Format</h2>
<p>An OITF that supports Content Download (i.e. if the <code>&lt;download&gt;</code> element has been given value &ldquo;<code>true</code>&rdquo; in the OITF's capability profile as specified in section <a href="#download-cod-capability" class="sectionRef"></a>)  SHALL support parsing and interpretation of a Content Access Download Descriptor with MIME type &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo;. </p>
<p>A valid Content Access Download Descriptor SHALL adhere to the following XML Schema: </p><pre class="xml-schema">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
           xmlns:tns="urn:oipf:iptv:ContentAccessDownloadDescriptor:2008-1" 
           xmlns:xml="http://www.w3.org/XML/1998/namespace" 
           targetNamespace="urn:oipf:iptv:ContentAccessDownloadDescriptor:2008-1" 
           elementFormDefault="qualified" attributeFormDefault="unqualified"&gt;
     &lt;!-- schema filename is  iptv-ContentAccessDownloadDescriptor.xsd -->
     &lt;!-- this schema redefines the generic Content Access Descriptor Schema iptv-
          AbstractContentAccessDescriptor.xsd as defined in Annex E.3 by limiting the allowable 
          values for attribute "TransferType" to "playable_download" and "full_download" --&gt;
     &lt;xs:redefine schemaLocation="iptv-AbstractContentAccessDescriptor.xsd"&gt;
        &lt;xs:simpleType name="TransferTypeEnum"&gt;
           &lt;xs:restriction base="tns:TransferTypeEnum"&gt;
              &lt;xs:enumeration value="full_download"/&gt;
              &lt;xs:enumeration value="playable_download"/&gt;
           &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
        &lt;xs:complexType name="ContItemType"&gt;
          &lt;xs:complexContent&gt;
             &lt;xs:extension base="tns:ContItemType"&gt;
                &lt;xs:sequence&gt;
                   &lt;xs:element name="availabilityWindow" type="tns:timeRangeType" 
                               minOccurs="0" maxOccurs="unbounded"/&gt;                
                &lt;/xs:sequence&gt;
              &lt;/xs:extension&gt;
            &lt;/xs:complexContent&gt;
          &lt;/xs:complexType&gt;
      &lt;/xs:redefine&gt;
      &lt;xs:complexType name="timeRangeType"&gt;
            &lt;xs:attribute name="start" type="xs:dateTime" use="required"/&gt;
            &lt;xs:attribute name="lastJoinTime" type="xs:dateTime"/&gt;
            &lt;xs:attribute name="end" type="xs:dateTime" use="required"/&gt;
      &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;
</pre>
<p>The semantics of the allowable values for attribute TransferType as defined by simple string type TransferTypeEnum is as follows:</p><ol type="a">
<li>Attribute &ldquo;TransferType&rdquo;,  which indicates the type of transfer used for the content, SHALL have one of the  following values:<ol type="i">
<li>&ldquo;full_download&rdquo;, which indicates that the content-item must be fully downloaded and stored before playback.
<li>&ldquo;playable_download&rdquo;, which indicates that the content-item is available for playback whilst it is being downloaded and stored by the download manager. The term &ldquo;playable_download&rdquo; is used solely in the context of the download manager and relates to storing the content (on persistent storage), and playing the stored version, and does not relate to buffering in the context of HTTP streaming. 
</ol></ol>

<p>The <code>&lt;availabilityWindow&gt;</code> element has the following semantics:</p>
<p><b>&lt;availabilityWindow&gt;</b> - indicates a time range for which the content is available for download.</p><ul>
<li>attribute &ldquo;<b>start</b>&rdquo; defines the time at which data becomes available for download in this availability window. Before this time, terminals should not attempt to acquire the content. All information needed for a download SHALL be available for a terminal that attempts to acquire the download at this time.
<li>attribute &ldquo;<b>lastJoinTime</b>&rdquo; defines the last time in this availability window at which a terminal could start acquiring the content and still acquire all of the content under optimum conditions.
<li>attribute &ldquo;<b>end</b>&rdquo; defines the time at which data stops being available for download in this availability window. NOTE: the purpose of indicating the end time is to provide information to a scheduling algorithm in the terminal.
</ul>
<p>]The syntax and semantics of the imported elements from the generic Content Access Descriptor Schema SHALL be as defined in annex <a href="#abstract-content-access-descriptor-format" class="sectionRef"></a>.</p>
<p>NOTE: An OITF SHALL silently ignore unknown elements and attributes that are part of a Content Access Download Descriptor.</p>
</section>

<section id="content-access-streaming-descriptor-format">
<h2>Content Access Streaming Descriptor Format</h2>
<p>An OITF SHALL support parsing and interpretation of a Content Access Streaming Descriptor with MIME type &ldquo;application/vnd.oipf.ContentAccessStreaming+xml&rdquo;. </p>
<p>A valid Content Access Streaming Descriptor SHALL adhere to the following XML Schema: </p><pre class="xml-schema">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" 
           xmlns:tns="urn:oipf:iptv:ContentAccessStreamingDescriptor:2008-1" 
           xmlns:xml="http://www.w3.org/XML/1998/namespace" 
           targetNamespace="urn:oipf:iptv:ContentAccessStreamingDescriptor:2008-1" 
           elementFormDefault="qualified" attributeFormDefault="unqualified"&gt;
     &lt;!-- schema filename is  iptv-ContentAccessStreamingDescriptor.xsd --&gt;
     &lt;!-- this schema redefines the generic Content Access Descriptor Schema iptv-
          AbstractContentAccessDescriptor.xsd as defined in Annex E.3 by limiting the allowable 
          values for attribute "TransferType" to "streaming" --&gt;
     &lt;xs:redefine schemaLocation="iptv-AbstractContentAccessDescriptor.xsd"&gt;
        &lt;xs:simpleType name="TransferTypeEnum"&gt;
           &lt;xs:restriction base="tns:TransferTypeEnum"&gt;
              &lt;xs:enumeration value="streaming"/&gt;
           &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
     &lt;/xs:redefine&gt;
&lt;/xs:schema&gt;
</pre>
<p>The semantics of the allowable values for attribute TransferType as defined by simple string type TransferTypeEnum is as follows:</p><ol type="a">
<li>Attribute &ldquo;TransferType&rdquo;,  which indicates the type of transfer used for the content, SHALL have one of the  following values: <ol type="i">
<li>&ldquo;streaming&rdquo;, which indicates that the content-item is streamed and should not be stored. This TransferType value is required for unicast streaming using an A/V Control object as defined in section <a href="#using-av-control-for-content_fragments" class="sectionRef"></a>.
</ol></ol>
<p>The syntax and semantics of the imported elements from the generic Content Access Descriptor Schema SHALL be as defined in annex <a href="#abstract-content-access-descriptor-format" class="sectionRef"></a>.</p>
<p>The &lt;notifyURL&gt; element has no meaning in this context, SHOULD NOT be encoded and SHOULD be ignored by OITFs if present.</p>
<p>NOTE: An OITF SHALL silently ignore unknown elements and attributes that are part of a Content Access Streaming descriptor.</p>
</section>

<section id="abstract-content-access-descriptor-format">
<h2>Abstract Content Access Descriptor Format</h2>
<p>This section specifies the generic (i.e. "abstract") content access descriptor XML Schema that forms the basis for the XML Schemas of document types: <code>application/vnd.oipf.ContentAccessDownload+xml</code> and <code>application/vnd.oipf.ContentAccessStreaming+xml</code>.</p>
<p>An Abstract Content Access Descriptor SHALL adhere to the semantics as defined in the bulleted list below. In this bulleted list, optional means optional for server, but mandatory to be supported on OITFs that have indicated support for MIME type &ldquo;<code>application/vnd.oipf.ContentAccessDownload+xml</code>&rdquo;. Mandatory means mandatory for the server  to include this element in the content access descriptor.</p>
<ol>
<li><b><i>&lt;Contents&gt;</i></b> - mandatory element which is a container for one or more associated &lt;ContentItem&gt; elements as child element. 
<li><b><i>&lt;ContentItem&gt;</i></b> - mandatory element which indicates a content-item. All other elements listed below are child-elements of a &lt;ContentItem&gt; element. 
<li><b><i>&lt;Title&gt;</i></b> - mandatory element which indicates a user interpretable name to describe the content item. In case of content download, it may serve as a basis/suggestion for the actual filename used for storing the downloaded content item. It is recommended for an OITF to not require the user to enter a filename and select the storage device for storing a downloaded content item.
<li><b><i>&lt;Synopsis&gt;</i></b> - optional element which indicates a user interpretable description of the content item.
<li><b><i>&lt;OriginSite&gt;</i></b> - mandatory element which indicates the URL of the site from which this content access description document can be downloaded. Typically this is the site from which the content is/can be purchased. 
<li><b><i>&lt;OriginSiteName&gt;</i></b> - Optional element, which gives the friendly name describing the origin site.
<li><b><i>&lt;ContentID&gt;</i></b> - Optional element which gives a unique identification of the content item relative to the OriginSite.
<li><b><i>&lt;ContentURL&gt;</i></b> - mandatory element which indicates the URL from which the content can be fetched. The element has the following attributes:<ol type="a">
<li>Optional attribute &ldquo;<code>DRMSystemID</code>&rdquo;, which indicates the DRM system for which this URL applies, using a value as defined by element <code>DRMSystemID</code> in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For example, for Marlin, the DRMSystemID value is &ldquo;urn:dvb:casystemid:19188&rdquo;. This attribute is used for linking a &lt;ContentURL&gt; to a  corresponding &lt;DRMControlInformation&gt; element with the same DRMSystemID value. If the &ldquo;DRMSystemID&rdquo; attribute is not specified or has value empty string, then this indicates that the content is not DRM protected. 
<li>Attribute &ldquo;<code>TransferType</code>&rdquo;,  which indicates the type of transfer used for the content. The concrete values that are allowed for this attribute are defined in annexes <a href="#content-access-download-descriptor-format" class="sectionRef"></a> and <a href="#content-access-streaming-descriptor-format" class="sectionRef"></a> for document types  <code>application/vnd.oipf.ContentAccessDownload+xml</code> and <code>application/vnd.oipf.ContentAccessStreaming+xml</code>.
<li>Mandatory attribute &ldquo;<code>Size</code>&rdquo;, which indicates the size of the content item in bytes. If the size is unknown (e.g. in case of streaming), the value of this element is -1. If the value is greater or equal to 0, the value given here SHALL correspond to the value given to the Content-Size HTTP header if the content is fetched through an HTTP ContentURL. If after downloading the content item the size of the downloaded content item does not match the indicated size parameter, the OITF SHALL report failed download (if the <code>application/oipfDownloadManager</code> object is used an event is dispatched to the onDownloadStateChange listener(s) with reason code 3, &ldquo;The item is invalid due to bad checksum or length&rdquo;). The OITF SHOULD remove the downloaded content item
<li>Optional attribute &ldquo;<code>MD5Hash</code>&rdquo;, which indicates the MD5 hash value [[!RFC1321]] of the content item. This value is used to check the correctness of the downloaded file. If after downloading the content item the MD5 hash value of the downloaded content item does not match the indicated MD5 hash value, it is recommended for the OITF to remove the downloaded content item.
<li>Optional attribute &ldquo;<code>Duration</code>&rdquo;, which indicates the media playback duration of the media item in the following form "hh:mm:ss".
<li>Mandatory attribute &ldquo;<code>MIMEType</code>&rdquo;, which indicates the MIME type of the content item. It is recommended for an OITF to inform the user if the content-type of a content item being retrieved cannot be interpreted by the OITF.
<li>Optional attribute &ldquo;<code>MediaFormat</code>&rdquo;, which describes the media format of the content item. The value of this element should be one of the terms defined by the <a href="volume3.html#avmediaformatCS" class="extRef">AVMediaFormatCS</a> classification scheme specified in [[.OIPF_META2]].
<li>Optional attribute &ldquo;<code>VideoCoding</code>&rdquo;, which describes the coding format of the video. The value of this element should be one of the terms defined by the <a href="volume3.html#visualcodingformatCS" class="extRef">VisualCodingFormatCS</a> classification scheme defined in [[.OIPF_META2]].
<li>Optional attribute &ldquo;<code>AudioCoding</code>&rdquo;, which describes the coding format of the audio. The value of this element should be one of the terms defined by the <a href="volume3.html#audiocodingformatCS" class="extRef">AudioCodingFormatCS</a> classification scheme defined in [[.OIPF_META2]].
<li>Optional attribute &ldquo;<code>PictureFormat</code>&rdquo;, which describes the picture format of the video. The value of this element should be one of the terms defined by the PictureFormatCS classification scheme defined in [[!TS102822-3-1]], with the URN "<code>urn:tva:metadata:cs:PictureFormatCS:2011</code>". Only the following termIDs defined in TVA PictureFormatCS  may be used:<ul>
<li>1 (2D Video)
<li>2.1.1 (Plano-Stereoscopic Video . Frame-Compatible 3D . Side-by-Side 3D Format)
<li>2.1.2 (Plano-Stereoscopic Video . Frame-Compatible 3D . Top-and-Bottom 3D Format).</ul>
</ol>
<p>Multiple &lt;ContentURL&gt; elements may be included for a single &lt;ContentItem&gt;, as long as each &lt;ContentURL&gt; element has a different value for the &ldquo;DRMSystemID&rdquo; attribute. </p>
<li><b><i>&lt;MetadataURL&gt;</i></b> - optional element which indicates the URL from which additional metadata can be fetched for the content item, such as artwork, subtitle files. By default the metadata must be a text/xml document formatted according to TV anytime, as defined in [[.OIPF_META2]].
<li><b><i>&lt;NotifyURL&gt;</i></b> - optional element which indicates the URL to which an HTTP GET request SHALL be made by the OITF, after the content-item has been fully and successfully fetched, in order to inform the server of the successful completion of the transfer. If any content is returned from the &lt;NotifyURL&gt;, it MAY be shown in the browser.
<li><b><i>&lt;IconURL&gt;</i></b> - optional element which indicates the URL of an image which is a visual representation of the item that is being downloaded. Valid content types include the image formats as listed in section <a href="volume2.html#image-section">9</a> of [[.OIPF_MEDIA2]].
<li><b><i>&lt;ParentalRating&gt;</i></b> - optional element which indicates the parental rating value (e.g. &ldquo;PG-13&rdquo;) for this content item. The element has the following attributes:<ol type="a">
<li>Attribute &ldquo;Scheme&rdquo;, which indicates the name of the parental rating scheme that is used for indicating the value. Valid rating scheme names include the ParentalRating classification scheme names as identified by property &ldquo;scheme&rdquo; of the ParentalRating object as defined in section <a href="#parentalrating-class" class="sectionRef"></a>.
<li>Attribute &ldquo;Region&rdquo;, which indicates the region to which the parental rating applies. Valid region names include the alpha-2 region codes as defined in ISO 3166-1. Values are not case sensitive.
</ol>
<p>Multiple &lt;ParentalRating&gt; elements may exist, as long as each &lt;ParentalRating&gt; element has a different value for the &ldquo;Scheme&rdquo; or the &ldquo;Region&rdquo; attribute.</p>
<li><b><i>&lt;DRMControlInformation&gt;</i></b> - optional element which allows the inclusion of DRM related information that SHALL be passed to the DRM agent. This element SHALL adhere to the DRMControlInformation Type Semantics as defined in <a href="volume3.html#drmcontrolinformation-type" class="extRef">table 9</a> of <a href="volume3.html#drm-control-information-extension" class="extRef">section 3.3.2</a> of [[.OIPF_META2]]. For Marlin, additional semantics are defined in <a href="volume7.html#protection-of-mpeg2-transport-streams" class="extRef">section 4.1.5</a> of [[.OIPF_CSP2]]. This element SHALL be included for any DRM System ID for which a corresponding &ldquo;DRMSystemID&rdquo; value was specified as attribute of a &lt;ContentURL> element.
Multiple &lt;DRMControlInformation&gt; elements MAY be included for a single &lt;ContentItem&gt;, as long as each &lt;DRMControlInformation&gt; element has a different value for its &ldquo;DRMSystemID&rdquo; child-element. 
</ol>
<p>An Abstract Content Access Descriptor SHALL adhere to the following XML Schema:</p>
<pre class="xml-schema">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
           elementFormDefault="qualified" attributeFormDefault="unqualified"&gt;
&lt;!-- schema filename is  iptv-AbstractContentAccessDescriptor.xsd --&gt;
&lt;!-- this is the generic (i.e. "abstract") content access descriptor XML Schema that forms the basis for the XML Schemas of document types: 
      application/vnd.oipf.ContentAccessDownload+xml and application/vnd.oipf.ContentAccessStreaming+xml. 
    This schema includes the definition for abstract type "DRMPrivateDataType" (as defined in Open IPTV Forum Solution 
    Specification Volume 3 Metadata Release 2) and its specific instance type "MarlinPrivateDataType" or "HexBinaryPrivateDataType" 
    (as defined in Open IPTV Forum Solution Specification Volume 7 Authentication, Content Protection and Service Protection Release 2) --&gt;
&lt;xs:import namespace="http://www.w3.org/XML/1998/namespace" 
           schemaLocation="http://www.w3.org/2001/xml.xsd"/&gt;
&lt;xs:include schemaLocation="csp-MarlinPrivateDataType.xsd"/&gt;
&lt;xs:include schemaLocation="csp-DRMPrivateDataType.xsd"/&gt;
&lt;xs:include schemaLocation="csp-HexBinaryPrivateDataType.xsd"/&gt;

&lt;xs:element name="Contents" type="ContentsType"/&gt;
  &lt;xs:complexType name="ContentsType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="ContentItem" type="ContItemType" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt; 
  &lt;xs:complexType name="ContItemType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Title" type="TitleType" minOccurs="1" maxOccurs="unbounded"/&gt; 
      &lt;xs:element name="Synopsis" type="SynopsisType" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xs:element name="OriginSite" type="xs:anyURI" minOccurs="1"/&gt;
      &lt;xs:element name="OriginSiteName" type="xs:string" minOccurs="0"/&gt;
      &lt;xs:element name="ContentID" type="xs:string" minOccurs="0"/&gt;
      &lt;xs:element name="ContentURL" type="ContentURLType" maxOccurs="unbounded"/&gt;
      &lt;xs:element name="MetadataURL" type="xs:anyURI" minOccurs="0"/&gt;
      &lt;xs:element name="NotifyURL" type="xs:anyURI" minOccurs="0"/&gt;
      &lt;xs:element name="IconURL" type="xs:anyURI" minOccurs="0"/&gt;
      &lt;xs:element name="ParentalRating" type="ParentalRatingType" minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
      &lt;xs:element name="DRMControlInformation" type="DRMControlInformationType" 
                  minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;  
  &lt;xs:complexType name="TitleType"&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xs:string"&gt;
        &lt;xs:attribute ref="xml:lang"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="SynopsisType"&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xs:string"&gt;
        &lt;xs:attribute ref="xml:lang"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="ContentURLType"&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xs:anyURI"&gt;
        &lt;xs:attribute name="DRMSystemID" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="TransferType" type="TransferTypeEnum" use="required"/&gt;
        &lt;xs:attribute name="MD5Hash" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="Duration" type="xs:duration" use="optional"/&gt;
        &lt;xs:attribute name="Size" type="xs:integer" use="required"/&gt;
        &lt;xs:attribute name="MIMEType" type="xs:string" use="required"/&gt;
        &lt;xs:attribute name="MediaFormat" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="VideoCoding" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="AudioCoding" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="PictureFormat" type="xs:string" use="optional"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
  &lt;!-- The TransferType is a string in this generic content access descriptor. The values of the TransferTypeEnum are restricted in the document instance types "application/vnd.oipf.ContentAccessDownloadDescriptor" and "application/vnd.oipf.ContentAccessStreamingDescriptor" as defined in Annexes E.1 and E.2.-&gt;
  &lt;xs:simpleType name="TransferTypeEnum"&gt;
    &lt;xs:restriction base="xs:string"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:complexType name="ParentalRatingType"&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xs:string"&gt;
        &lt;xs:attribute name="Scheme" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="Region" type="xs:string" use="optional"/&gt;
      &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="DRMControlInformationType"&gt;
    &lt;xs:sequence&gt;
       &lt;xs:element name="DRMSystemID" type="xs:string"/&gt;
       &lt;xs:element name="DRMContentID" type="xs:string"/&gt;
       &lt;xs:element name="RightsIssuerURL" type="xs:anyURI" minOccurs="0"/&gt;
       &lt;xs:element name="SilentRightsURL" type="xs:anyURI" minOccurs="0"/&gt;
       &lt;xs:element name="PreviewRightsURL" type="xs:anyURI" minOccurs="0"/&gt;
       &lt;xs:element name="DoNotRecord" type="xs:boolean" minOccurs="0"/&gt;
       &lt;xs:element name="DoNotTimeShift" type="xs:boolean" minOccurs="0"/&gt;
       &lt;xs:element ref="DRMGenericData" minOccurs="0" maxOccurs="unbounded"/&gt;
       &lt;xs:element ref="DRMPrivateData" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

   &lt;xs:element name="DRMGenericData" type="DRMGenericDataType"/&gt;
   &lt;xs:element name="DRMPrivateData" type="DRMPrivateDataType"/&gt;

   &lt;xs:complexType name="DRMGenericDataType"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;

   &lt;xs:element name="MarlinPrivateData" type="MarlinPrivateDataType" substitutionGroup="DRMPrivateData"/&gt;
   &lt;xs:element name="HexBinaryPrivateData" type="HexBinaryPrivateDataType" substitutionGroup="DRMPrivateData"/&gt;

&lt;/xs:schema&gt;
</pre>
<p>An OITF SHALL silently ignore unknown elements and attributes that are part of a content-access descriptor.</p>
</section>
</section>


<!-- Annex F -->
<section id='client-extensions-schema' class="appendix">
<h1>Client Extensions Schema</h1>
<p>This annex contains the schema that includes the extensions and modifications to the capability negotiation mechanism as defined in section <a href="#client-capability-description" class="sectionRef"></a>. This schema redefines and adds the necessary extensions to the existing capability description schema as defined in annex C of CEA-2014 [[!CEA-2014-A]]. The schema in this annex SHALL be used instead of the existing capability description as defined in annex C of CEA-2014 [[!CEA-2014-A]]. Note that for the additional &ldquo;0.33x0.33&rdquo; value for &ldquo;scalingType&rdquo; as defined in section <a href="#other-capability-extensions" class="sectionRef"></a>, a special construction has been defined. See the last two paragraphs of this annex for more information.</p>
<pre class="xml-schema">
&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;xs:schema xmlns="urn:oipf:config:oitf:oitfCapabilities: 2011-1" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema" 
           targetNamespace="urn:oipf:config:oitf:oitfCapabilities: 2011-1" 
           elementFormDefault="qualified" attributeFormDefault="unqualified"&gt;
  &lt;!-- schema filename is  config-oitf-oitfCapabilities.xsd --&gt;
  &lt;!-- Redefined uiExtensionsType of the original schema as defined in Annex C of CEA-2014 
       (i.e. imports/ce-html-profiles-1-0.xsd) to add the new elements defined in Section 9.3 
       of Open IPTV forum Volume 5 Declarative Application Environment Release 2 specification. 
       --&gt;
    &lt;xs:redefine schemaLocation="imports/ce-html-profiles-1-0.xsd"&gt;
    &lt;xs:complexType name="uiExtensionType"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="uiExtensionType"&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:element name="video_broadcast" type="videoBroadcastType" minOccurs="0" 
                           maxOccurs="unbounded"/&gt;
               &lt;xs:element name="overlaylocaltuner" type="overlayType"/&gt;
               &lt;xs:element name="overlayIPbroadcast" type="overlayType"/&gt;
               &lt;xs:element name="recording" type="pvrType"/&gt;
               &lt;xs:element name="parentalcontrol" type="parentalControlType"/&gt;
               &lt;xs:element name="extendedAVControl" type="xs:boolean"/&gt;
               &lt;xs:element name="clientMetadata" type="metadataType"/&gt;
               &lt;xs:element name="configurationChanges" type="xs:boolean"/&gt;
               &lt;xs:element name="communicationServices" type="xs:boolean"/&gt;
               &lt;xs:element name="presenceMessaging" type="xs:boolean"/&gt;
               &lt;xs:element name="drm" type="drmType" minOccurs="0" maxOccurs="unbounded"/&gt;
               &lt;xs:element name="remote_diagnostics" type="xs:boolean"/&gt;
               &lt;xs:element name="pollingNotifications" type="xs:boolean"/&gt;
               &lt;xs:element name="mdtf" type="xs:boolean"/&gt;
               &lt;xs:element name="widgets" type="xs:boolean"/&gt;
               &lt;xs:element name="html5_media" type="xs:boolean"/&gt;
               &lt;xs:element name="remoteControlFunction" type="xs:boolean"/&gt;
               &lt;xs:element name="wakeupApplication" type="xs:boolean"/&gt;
               &lt;xs:element name="wakeupOITF" type="xs:boolean"/&gt;
               &lt;xs:element name="hibernateMode" type="xs:boolean"/&gt;
               &lt;xs:element name="telephony_services" type="telephonyServicesType"/&gt;
               &lt;xs:element name="playbackControl" type="playbackType"/&gt;
               &lt;xs:element name="temporalClipping" type="hasCapability"/&gt;
               &lt;xs:any namespace="##other"/&gt;
            &lt;/xs:choice&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- Redefined downloadType to add attribute manageDownloads --&gt;
    &lt;xs:complexType name="downloadType"&gt;
      &lt;xs:simpleContent&gt;
          &lt;xs:extension base="downloadType"&gt;
             &lt;xs:attribute name="manageDownloads" type="manageDownloadsType" default="none"/&gt;
          &lt;/xs:extension&gt; 
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- Redefined audioProfileType to add attribute DRMSystemID --&gt;
    &lt;xs:complexType name="audioProfileType"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="audioProfileType"&gt;
            &lt;xs:attribute name="DRMSystemID" type="xs:string"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- Redefined videoProfileType to add attribute DRMSystemID --&gt;
    &lt;xs:complexType name="videoProfileType"&gt;
      &lt;xs:complexContent&gt;
         &lt;xs:extension base="videoProfileType"&gt;
            &lt;xs:attribute name="DRMSystemID" type="xs:string"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;/xs:redefine&gt;
    &lt;!-- ADDED: type definitions for the new elements defined in Section 9.3 of the 
            Open IPTV forum Volume 5 Declarative Application Environment Release 2 specification
        --&gt;
    &lt;xs:simpleType name="manageDownloadsType"&gt;
      &lt;xs:restriction base="xs:string"&gt;
         &lt;xs:enumeration value="none"/&gt;
         &lt;xs:enumeration value="initiator"/&gt;
         &lt;xs:enumeration value="samedomain"/&gt;
         &lt;xs:enumeration value="all"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:simpleType name="manageRecordingsType"&gt;
      &lt;xs:restriction base="xs:string"&gt;
         &lt;xs:enumeration value="none"/&gt;
         &lt;xs:enumeration value="initiator"/&gt;
         &lt;xs:enumeration value="samedomain"/&gt;
         &lt;xs:enumeration value="all"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:complexType name="videoBroadcastType"&gt;
      &lt;xs:attribute name="type" type="xs:string" use="required"/&gt;
      &lt;xs:attribute name="transport" type="xs:string"/&gt;
      &lt;xs:attribute name="nrstreams" type="xs:unsignedInt" default="1"/&gt;
      &lt;xs:attribute name="scaling" type="scalingType" default="arbitrary"/&gt;
      &lt;xs:attribute name="minSize" type="xs:unsignedInt" default="0"/&gt;
      &lt;xs:attribute name="postList" type="xs:boolean" default="false"/&gt;
      &lt;xs:attribute name="networkTimeshift" type="xs:boolean" default="false"/&gt;
      &lt;xs:attribute name="localTimeshift" type="xs:boolean" default="false"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="pvrType"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:boolean"&gt;
            &lt;xs:attribute name="ipBroadcast" type="xs:boolean" default="false"/&gt;
            &lt;xs:attribute name="HAS" type="xs:boolean" default="false"/&gt;
            &lt;xs:attribute name="DASH" type="xs:boolean" default="false"/&gt;        
            &lt;xs:attribute name="manageRecordings" type="manageRecordingsType" default="none"/&gt;
            &lt;xs:attribute name="postList" type="xs:boolean" default="false"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="parentalControlType"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:boolean"&gt;
            &lt;xs:attribute name="schemes" type="xs:string"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="metadataType"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:boolean"&gt;
            &lt;xs:attribute name="type" type="xs:string"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="drmType"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:string"&gt;
            &lt;xs:attribute name="DRMSystemID" type="xs:string" use="required"/&gt;
            &lt;xs:attribute name="protectionGateways" type="xs:string" default=""/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="telephonyServicesType"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:boolean"&gt;
            &lt;xs:attribute name="video" type="xs:boolean" default="false"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="playbackType"&gt;
      &lt;xs:simpleContent&gt;
         &lt;xs:extension base="xs:boolean"&gt;
            &lt;xs:attribute name="type" type="xs:string"/&gt;
         &lt;/xs:extension&gt;
      &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
  &lt;xs:complexType name="hasCapability"/&gt;
&lt;/xs:schema&gt;
</pre>
<p>Due to limitations of XML Schema it is not possible to redefine/extend the enumeration of type &ldquo;scalingType&rdquo; to add the additional value &ldquo;0.33x0.33&rdquo; as defined in section <a href="#other-capability-extensions" class="sectionRef"></a>. Therefore, this value must be directly added to the original schema as defined in annex C of [[!CEA-2014-A]] (i.e. imports/ce-html-profiles-1-0.xsd), as follows:</p><pre class="xml-schema noborder">
[...]
   &lt;xs:simpleType name="scalingType"&gt;
      &lt;xs:restriction base="xs:string"&gt;
         &lt;xs:enumeration value="arbitrary"/&gt;
         &lt;xs:enumeration value="quartersize"/&gt;
         &lt;xs:enumeration value="none"/&gt;
         &lt;xs:enumeration value="0.33x0.33"/&gt;
      &lt;/xs:restriction&gt;
   &lt;/xs:simpleType&gt;
[...]
</pre>
</section>

<!-- Annex G -->
<section id='client-channel-listing-format' class="appendix">
<h1>Client Channel Listing Format</h1>
<p>An OITF that supports sending the Client Channel Listing through the HTTP POST method defined in section <a href="#method-2-http-post" class="sectionRef"></a> SHALL adhere to the XML Schema of the Client Channel Listing defined in this annex for which the following semantics apply:</p>
<ol>
<li><b><i>&lt;ChannelConfig&gt;</i></b> - mandatory root element of the Client Channel Listing. 
<li><b><i>&lt;ChannelList&gt;</i></b> - mandatory container element for zero or more &lt;Channel&gt; elements, the order of which corresponds to the channel order as managed by the OITF.
<li><b><i>&lt;Channel&gt;</i></b> - element that represents a channel that can be received by a tuner of the OITF. The element has the following attributes:<ol type="a">
<li>Mandatory attribute &ldquo;<code>ccid</code>&rdquo; which specifies a unique identifier of the channel within the scope of the OITF. The format of <code>ccid</code> SHALL have a prefix 'ccid:', e.g., 'ccid:{tuner.}majorChannel{.minorChannel}'. The <code>ccid</code> is defined and managed by the OITF.
<li>Optional attribute &ldquo;<code>channelType</code>&rdquo; which indicates the type of media content carried over the channel. Valid values are specified in section <a href="#channel-constants" class="sectionRef"></a>. If not included, the default value is &ldquo;<code>TYPE_OTHER</code>&rdquo;.
<li>Mandatory attribute &ldquo;<code>idType</code>&rdquo; which specifies the type of identification that is used for the channel. Valid values are specified in section <a href="#channel-constants" class="sectionRef"></a>.
<li>Optional attribute &ldquo;tunerID&rdquo; which specifies a unique identifier of the tuner within the scope of the OITF.
<li><b><i>&lt;ONID&gt;</i></b> - mandatory child element of a &lt;Channel&gt; element of type ID_DVB_* or ID_ISDB_* which specifies the DVB or ISDB original network ID. The value can be empty (i.e. &lt;ONID/&gt;) if stream does not contain an SDT_Actual.</ol>
<li><b><i>&lt;TSID&gt;</i></b> - mandatory child element of a &lt;Channel&gt; element of type ID_DVB_* or ID_ISDB_* which specifies the DVB or ISDB transport stream ID.
<li><b><i>&lt;SID&gt;</i></b> - mandatory element of a &lt;Channel&gt; element of type ID_DVB_* or ID_ISDB_* which specifies the DVB or ISDB service ID.
<li><b><i>&lt;SourceID&gt;</i></b> - mandatory child element of a &lt;Channel&gt; element of type ID_ATSC_T which specifies the ATSC source_ID.
<li><b><i>&lt;Freq&gt;</i></b> - mandatory child element of a &lt;Channel&gt; element of type &ldquo;ID_ANALOG&rdquo; which specifies the frequency of the content carrier in kHz.
<li><b><i>&lt;CNI&gt;</i></b> - optional child element of a &lt;Channel&gt; element of type &ldquo;ID_ANALOG&rdquo; which specifies the VPS/PDC confirmed network identifier.
<li><b><i>&lt;IPBroadcastID&gt;</i></b> - mandatory child element of a &lt;Channel&gt; element of type &ldquo;ID_IPTV_SDS&rdquo; or &ldquo;ID_IPTV_URI&rdquo;. if the channel has type &ldquo;ID_IPTV_SDS&rdquo;, this element denotes the DVB Textual Service Identifier of the IP broadcast service, specified in the format &ldquo;ServiceName.DomainName&rdquo; with the ServiceName and DomainName as defined in 
TS 102 034 V1.3.1. If the channel has type &ldquo;ID_IPTV_URI&rdquo;, this element denotes the URI of the IP broadcast service.
<li><b><i>&lt;MajorChannel&gt;</i></b> - optional child element of a &lt;Channel&gt; element of type &ldquo;ID_ATSC_*&rdquo;. This element denotes the major channel number, if assigned. Value 0 otherwise.
<li><b><i>&lt;MinorChannel&gt;</i></b>  optional child element of a &lt;Channel&gt; element of type &ldquo;ID_ATSC_*&rdquo;. This element denotes the minor channel number (in relation to the major channel number as indicated through element &lt;MajorChannel&gt;) if assigned. Value 0 otherwise.
<li><b><i>&lt;Name&gt;</i></b> - mandatory child element of a &lt;Channel&gt; element which specifies the name of the broadcaster. May be an empty string.
<li><b><i>&lt;Favourite&gt;</i></b> - optional child element of a &lt;Channel&gt; element indicating that the user has marked this channel as a favourite. The element has the following attribute:<ol type="a">
<li>Optional attribute &ldquo;<code>FavIDS</code>&rdquo; indicating in which favourite lists, if any, this channel is selected.</ol>
<li><b><i>&lt;FavouriteLists&gt;</i></b> - optional child element of the &lt;ChannelConfig&gt; element containing one or more &lt;FavouriteList&gt; elements.
<li><b><i>&lt;FavouriteList&gt;</i></b> - mandatory child element of the &lt;FavouriteLists&gt; element that represents a favourite list that is (partially) managed by the OITF. The element has the following attribute:<ol type="a">
<li>Mandatory attribute &ldquo;<code>FavID</code>&rdquo; which specifies the unique identifier of the favourite list.</ol>
<li><b><i>&lt;FavName&gt;</i></b> - mandatory child element of the &lt;FavouriteList&gt; element specifying the name of the favourite list.
<li><b><i>&lt;CurrentFavouriteList&gt;</i></b> - conditionally optional child element of the &lt;ChannelConfig&gt; element specifying the currently active favourite list.
<li><b><i>&lt;Recordable&gt;</i></b> - optional child element of a &lt;Channel&gt; element indicating whether the channel can be recorded. Valid values include &ldquo;True&rdquo; or &ldquo;False&rdquo;. If this element is not included, the default value is &ldquo;False&rdquo;. The value SHALL be ignored if the OITF did not indicate support for control of its recording functionality.
<li><b><i>&lt;Locked&gt;</i></b> - optional child element of a &lt;Channel&gt; element indicating whether the current state of the parental control system prevents the channel from being viewed (e.g. a correct parental control pin has not been entered). Valid values include &ldquo;True&rdquo; or &ldquo;False&rdquo;. If this element is not included, the default value is &ldquo;False&rdquo;.
<li><b><i>&lt;ManualBlock&gt;</i></b> - optional child element of a &lt;Channel&gt; element indicating whether the user has manually blocked viewing of this channel.  Manual blocking of a channel treats the channel as if its parental rating value always exceeded the system threshold. Valid values include &ldquo;True&rdquo; or &ldquo;False&rdquo;. If this element is not included, the default value is &ldquo;False&rdquo;.
</ol>
<p>A valid Client Channel Listing SHALL adhere to the following XML Schema:</p><pre class="xml-schema">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"&gt; 
  &lt;xs:element name="ChannelConfig"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="ChannelList"/&gt;
        &lt;xs:sequence minOccurs="0"&gt;
          &lt;xs:element ref="FavouriteLists"/&gt;
          &lt;xs:element ref="CurrentFavouriteList" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="ChannelList"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="Channel" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="Channel"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        For a DVB digital channel use ONID+TSID+SID,
        for an ISDB (ARIB) digital channel use ONID+TSID+SID,
        for a ATSC terrestrial channel use SourceID,
        for analog channel use Freq and CNI (if available).
        The IPBroadcastID element is relevant for IPTV broadcasts, as defined in Section 7.5.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:choice&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="ONID"/&gt;
            &lt;xs:element ref="TSID"/&gt;
            &lt;xs:element ref="SID"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:element ref="SourceID"/&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="Freq"/&gt;
            &lt;xs:element ref="CNI" minOccurs="0"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:element ref="IPBroadcastID"/&gt;
        &lt;/xs:choice&gt;
        &lt;xs:element ref="Name"/&gt;
        &lt;xs:element ref="Favourite" minOccurs="0"/&gt;
        &lt;xs:element ref="Recordable" minOccurs="0"/&gt;
        &lt;xs:element ref="Locked" minOccurs="0"/&gt;
        &lt;xs:element ref="ManualBlock" minOccurs="0"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="CCID" type="xs:IDREF" use="required"/&gt;
      &lt;xs:attribute name="channelType" type="xs:string" default="TYPE_OTHER"/&gt;
      &lt;xs:attribute name="idType" type="xs:string" use="required"/&gt;
      &lt;xs:attribute name="TunerID" type="xs:IDREF" use="optional"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="ONID" type="xs:integer"/&gt;
  &lt;xs:element name="TSID" type="xs:integer"/&gt;
  &lt;xs:element name="SID" type="xs:integer"/&gt;
  &lt;xs:element name="SourceID" type="xs:integer"/&gt;
  &lt;xs:element name="Freq" type="xs:integer"/&gt;
  &lt;xs:element name="CNI" type="xs:integer"/&gt;
  &lt;xs:element name="IPBroadcastID" type="xs:string"/&gt;
  &lt;xs:element name="MajorChannel" type="xs:integer"/&gt;
  &lt;xs:element name="MinorChannel" type="xs:integer"/&gt;
  &lt;xs:element name="Name" type="xs:string"/&gt;
  &lt;xs:element name="Favourite"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:attribute name="FavIDS" type="xs:IDREFS"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="FavouriteLists"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="FavouriteList" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:element name="FavouriteList"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="FavName"&gt;
          &lt;xs:attribute name="FavID" type="xs:ID" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  &lt;xs:complexType name="FavName"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="FavName"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:element name="FavName" type="xs:string"/&gt;
  &lt;xs:element name="CurrentFavouriteList"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:attribute name="FavID" type="xs:IDREF" use="required"/&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;  
  &lt;xs:element name="Recordable" type="xs:boolean"/&gt;
  &lt;xs:element name="Locked" type="xs:boolean"/&gt;
  &lt;xs:element name="ManualBlock" type="xs:boolean"/&gt;
&lt;/xs:schema&gt;
</pre>
</section>

<!-- Annex H -->
<section id='display-model-annex' class="appendix">
<h1>Display Model</h1>
<section id="display-model-logical-planes">
<h2>Logical plane model</h2>
<p>Digital TV terminals typically have multiple planes for displaying graphics, subtitles, video and background color. This section defines a logical plane model for OITFs. Figure <a href="#logical-plane-model" class="figureRef"></a> shows the ordering of these logical planes.</p>
<figure id="logical-plane-model">
<img alt="FIGURE 18" src="images/LogicalPlaneModel.png" />
<figcaption>Figure ####: Logical plane model (informative)</figcaption>
</figure>
<p>This logical plane model does not imply any particular physical implementation. For instance, the presence of two graphic planes and a subtitle plane does not imply a requirement for three hardware graphic planes.</p>
<p>The logical planes are defined as follows:</p><ul>
<li>The &ldquo;Background color plane&rdquo; displays a single uniform color which SHALL be black. This plane SHALL be at the bottom of the logical display stack.
<li>The &ldquo;Video plane&rdquo; is used to display video. This plane SHALL be on top of the background color plane in the logical display stack.  The interaction between the &ldquo;video plane&rdquo; and the video/broadcast object is described in section <a href="#server-security-requirements" class="sectionRef"></a>. Streamed video may appear to be presented in a plane other than the logical video plane. The present document is intentionally silent about the mechanism used by an OITF to achieve this behaviour
<li>The &ldquo;Subtitles plane&rdquo; is used to display subtitles. This plane SHALL be on top of the video plane in the logical display stack.
<li>The &ldquo;DAE application graphic plane&rdquo; is used to display any running DAE applications. This plane SHALL be on top of the subtitles plane in the logical display stack. The logical resolution of this plane is given by the <code>&lt;width&gt;</code> and <code>&lt;height&gt;</code> elements of the capability description. The default background color of the browser rendering canvas (as defined in section 2.3.1 of <mark class="error">CSS2.1</mark>) is terminal specific. Applications should explicitly set the background of their <code>&lt;body&gt;</code> element to transparent using (for example) the background-color CSS rule or any equivalent construct.<div class="editor-note">This could be "Bert Bos et al. Cascading Style Sheets, level 2 (CSS2) Specification. 07 June 2011. W3C Recommendation. URL: http://www.w3.org/TR/2011/REC-CSS2-20110607/" as used in the Web Services TV Profile</div>
<li>The &ldquo;Platform-specific application graphic plane&rdquo; is used to display applications specific to the OITF such as native system menus, banners or pop-ups. This plane SHALL be on top of the DAE application graphic plane in the logical display stack.
</ul>
<p>For subtitles, the following rules apply:</p><ul>
<li>OITFs SHOULD support simultaneous display of application and subtitles. In that case, the OITF SHALL display the application over the subtitles (as shown in Figure <a href="#logical-plane-model" class="figureRef"></a>). If the video is rescaled, the subtitles SHALL be rescaled/repositioned appropriately or not displayed at all.
<li>If the presentation of subtitles is requested prior to the launch of an application, then OITFs which cannot support simultaneous display of applications and subtitles SHALL display subtitles in preference to running the application. The OITF MAY offer the end-user the opportunity to disable subtitles and run the application instead.
<li>If the presentation of subtitles is requested while an application is running, OITFs which cannot support simultaneous display of applications and subtitles SHALL display applications in preference to the presentation of subtitles.
</ul>
<p>NOTE: In consequence, display of subtitles with broadband delivered video is only possible on such terminals by including the subtitles as part of the video. </p>
</section>
<section id="display-model-object-interactions">
<h2>Interaction with the video/broadcast and A/V Control objects</h2>
<p>The behaviour of the video/broadcast object is defined in section <a href="#video-broadcast-state-diagram" class="sectionRef"></a>.  When no video/broadcast object is instantiated, or when all video/broadcast objects are in the Unrealized state, broadcast video presentation SHALL be under the control of the OITF.  When video is under the control of the OITF:</p><ul>
<li>Any broadcast video being presented SHALL be displayed in the logical video plane.
<li>The complete logical video plane SHALL be filled.
<li>The OITF MAY scale and/or position video, for example to remove black bars.
</ul>
<p>For broadcast related applications as defined in section <a href="#broadcast-related-applications" class="sectionRef"></a>, broadcast video presentation SHALL initially be under the control of the OITF.  Applications wanting to control video presentation SHALL create a video/broadcast object.</p>
<p>When a video/broadcast object is in any state other than the Unrealized state, broadcast video presentation SHALL be under the control of the application. When video is under the control of the application:</p><ul>
<li>When the video/broadcast object or A/V Control object is not in &ldquo;full-screen mode&rdquo;, any video being presented SHALL be scaled and positioned  in the following way:<ul>
<li>if the video/broadcast object has the same aspect ratio as the video the four corners of the video SHALL match exactly the corners of the video/broadcast object 
<li>otherwise the video SHALL be scaled such that one side of the video fills the video/broadcast object fully without cropping the picture. The aspect ratio SHALL be preserved. Along the side where the video is shorter than the video/broadcast object, the video SHALL be centered. The area of the video plane not containing video SHALL be opaque black.
</ul>
<li>When the video/broadcast object or A/V Control object is in &ldquo;full-screen mode&rdquo;, presented video SHALL be scaled to fill the entire logical video plane. The OITF MAY further scale and/or position video, for example to remove black bars.
<li>Depending on the Z index of the video/broadcast or A/V Control object with respect to other HTML elements (regardless of whether the object is in &ldquo;fullscreen mode&rdquo; or not), presented opaque video may fully or partially overlap other HTML elements with a lower Z index, and may in turn be fully or partially overlapped by HTML elements with a higher Z index. As a result of this, video may appear to be presented in a plane other than the logical video plane. This specification is intentionally silent about the mechanism used by an OITF to achieve this behaviour.
<li>Calling the <code>Application.hide()</code> method SHALL cause video (and any subtitles) being presented under the control of that application  to be hidden, and any audio being presented by the video/broadcast or A/V Control object under the control of that application to be muted. Calling <code>Application.show()</code> SHALL cause video and audio presentation to be restored.
</ul>
<p>If the release() method is called on a video/broadcast object, or if the object is garbage collected, control of broadcast video presentation SHALL be returned to the OITF and video SHALL be re-scaled and re-positioned (if necessary).</p>
</section>
<section id="display-model-graphic-safe-area">
<h2>Graphic safe area (informative)</h2>
<p>Figure <a href="#graphic-safe-area" class="figureRef"></a> shows the recommended safe area for content authoring for the OITF_HD_UIPROF default profile:
<figure id="graphic-safe-area">
<img alt="FIGURE 19" src="images/GraphicSafeArea.png" style="width:90%" />
<figcaption>Figure ####: Graphic safe area</figcaption>
</figure>
</section>
<section id="display-model-current-channel">
<h2>Current Channel (informative)</h2>
<p>There are 3 different &ldquo;current channel&rdquo; concepts in this specification;</p><ul>
<li>The current channel of an OITF. This is the most obvious &ldquo;current channel&rdquo; to the end-user but the most complex to properly define technically &mdash; particularly where more than one channel is being presented at the same time. The bindToCurrentChannel() method implicitly defines this as this the channel whose audio is being presented.
<li>The current channel of a video/broadcast object. This is the easiest to define technically.
<li>The current channel of a broadcast-related application. This is the channel which is currently the source of the signalling information controlling the lifecycle of a broadcast-related application (as described in section <a href="#broadcast-related-applications" class="sectionRef"></a>). 
</ul>
<p>In simple situations, all of these may refer to the same channel. In complex situations they may not. Here are some examples;</p>
<table class="simple" id="clariciation-of-current-channel-concept">
<caption>Table ####: Clarification of the &ldquo;current channel&rdquo; concept in different scenarios</caption>
<thead><tr><th>Scenario</th><th>Current Channel of OITF</th><th>Current Channel of  video /broadcast object(s)</th><th>Current channel of broadcast-related application(s)</th></tr></thead>
<tr><td>The OITF is presenting exactly one broadcast video channel, this video is being presented by a <code>video/broadcast</code> object (in the Presenting state) which is part of a broadcast-related application which is controlled by signalling information from that broadcast video channel</td><td colspan="3">All 3 current channels reference the same broadcast channel.</td></tr>
<tr><td>The OITF is presenting exactly one broadcast video channel, this video is under the control of the OITF (as defined in section <a href="#display-model-object-interactions" class="sectionRef"></a>) and one or more broadcast-related applications are running which are controlled by signalling information from that broadcast video channel none of which have a <code>video/broadcast</code> object outside the Unrealized state.</td><td>The channel being presented by the OITF</td><td>Not relevant</td><td>The channel being presented by the OITF</td></tr>
<tr><td>The OITF is presenting exactly one broadcast video channel, this video is under the control of the OITF (as defined in section <a href="#display-model-object-interactions" class="sectionRef"></a>) and no broadcast-related applications are running.</td><td>The channel being presented by the OITF</td><td>Not relevant</td><td>Not relevant</td></tr>
<tr><td>The OITF is presenting two broadcast video channels, one main channel (responding to channel up and channel down) and a PiP channel.</td><td>The main channel (the one responding to channel up / channel down)</td><td>Not relevant</td><td>Not relevant</td></tr>
<tr><td>The OITF is presenting two broadcast video channels, one main channel (responding to channel up and channel down) and a PiP channel.  A broadcast-related application is running associated with the main channel. The user swaps the main channel to PiP and vice-versa.</td><td>The channel which was previously PiP.</td><td>Not relevant</td><td>This specification does not address what happens to broadcast-related applications under these circumstances.</td></tr>
<tr><td>A broadcast-independent or service provider related DAE application has two <code>video/broadcast</code> objects, one presenting the channel resulting from a call to bindToCurrentChannel() and the second presenting another channel set by setChannel().</td><td>The same as the current channel of the <code>video/broadcast</code> object presenting the channel resulting from a call to bindToCurrentChannel()</td><td>The two <code>video/broadcast</code> objects have different current channels.</td><td>Not relevant</td></tr>
</table>
</section>
</section>

<!-- Annex I -->
<section class="appendix" id="profile-of-html5">
<h1>Backwards Compatible Profile of HTML5 Media Elements</h1>
<section>
<h2>Introduction</h2>
<p>This annex lists the media related elements and types from the HTML5 specification as referenced by [[.OIPF_WSTVP2]] (sections 4.8.6 through to 4.8.10) and defines a set of attributes, methods and constants which are common between the 2009-08-25 version of the HTML5 specification and the candidate recommendation. Attributes, methods, constants and elements which are included in one specification but not the other are recorded in informative notes.  Attributes, methods, constants and elements which were included in the 2009-08-25 version and are not included in the candidate recommendation are not REQUIRED by this annex but MAY be included unless they conflict with something in the candidate recommendation.</p>
<p>NOTE: The track element was not included in the 2009-08-25 version and is not included here.</p>
</section>
<section>
<h2>Video Element</h2>
<p><b>Content attributes included from this interface:</b> <code>src</code>, <code>poster</code>, <code>preload</code>, <code>autoplay</code>, <code>loop</code>, <code>controls</code>, <code>width</code>, <code>height</code></p>
<p>NOTE: The <code>autobuffer</code> content attribute from the 2009-08-25 version is not included in the candidate recommendation and hence is not required here.</p>
<p>NOTE: The <code>crossorigin</code>, <code>mediagroup</code> and <code>muted</code> content attributes in the candidate recommendation were not included in the 2009-08-25 version and are not included here.</p>
<p><b>DOM attributes included from this interface:</b> <code>width</code>, <code>height</code>, <code>poster</code>, <code>videoWidth</code>, <code>videoHeight</code></p>
<p><b>DOM methods included from this interface:</b> none</p>
<p><b>DOM constructors included from this interface:</b> none</p>
<p><b>DOM constants included from this interface:</b> none</p>
<p>In addition, DOM attributes, methods and constants are inherited from the <code>media</code> element.</p>
</section>
<section>
<h2>Audio Element</h2>
<p><b>Content attributes included from this interface:</b> <code>src</code>, <code>preload</code>, <code>autoplay</code>, <code>loop</code>, <code>controls</code></p>
<p>NOTE: The <code>autobuffer</code> content attribute from the 2009-08-25 version is not included in the candidate recommendation and hence is not required here.</p>
<p>NOTE: The <code>crossorigin</code>, <code>mediagroup</code> and <code>muted</code> content attributes in the candidate recommendation were not included in the 2009-08-25 version and are not included here.</p>
<p><b>DOM attributes included from this interface:</b> none</p>
<p><b>DOM methods included from this interface:</b> none</p>
<p><b>DOM constructors included from this interface:</b> <code>Audio()</code></p>
<p>NOTE: The constructor <code>Audio(in DOMString src)</code> is not included as it is not widely implemented.</p>
<p><b>DOM constants include from this interface:</b> none</p>
<p>In addition, DOM attributes, methods and constants are inherited from the <code>media</code> element.</p>
</section>
<section>
<h2>Source Element</h2>
<p><b>Content attributes included from this interface:</b> <code>src</code>, <code>type</code>, <code>media</code></p>
<p><b>DOM attributes included from this interface:</b> <code>src</code>, <code>type</code>, <code>media</code></p>
<p><b>DOM methods included from this interface:</b> none</p>
<p><b>DOM constructors included from this interface:</b> none</p>
<p><b>DOM constants included from this interface:</b> none</p>
</section>
<section>
<h2>Media Element</h2>
<p><b>Content attributes included from this interface:</b> none</p>
<p><b>DOM attributes included from this interface:</b> <code>error</code>, <code>src</code>, <code>currentSrc</code>, <code>networkState</code>, <code>autobuffer</code>, <code>buffered</code>, <code>readyState</code>, <code>seeking</code>, <code>currentTime</code>, <code>startTime</code>, <code>duration</code>, <code>paused</code>, <code>defaultPlaybackRate</code>, <code>playbackRate</code>, <code>played</code>, <code>seekable</code>, <code>ended</code>, <code>autoplay</code>, <code>loop</code>, <code>controls</code>, <code>volume</code>, <code>muted</code> and <code>preload</code>.</p>
<p>NOTE: The <code>crossOrigin</code>, <code>startDate</code>, <code>mediaGroup</code>, <code>controller</code>, <code>audioTracks</code>, <code>videoTracks</code> and <code>textTracks</code> attributes were not included in the 2009-08-25 version and are not included here.</p>
<p>NOTE: The <code>autobuffer</code> and <code>startTime</code> attributes from the 2009-08-25 version are not included in the candidate recommendation and hence are not required here.</p>
<p><b>DOM methods included from this interface:</b> <code>load()</code>, <code>canPlayType(in DOMString type)</code>, <code>play()</code>, <code>pause()</code></p>
<p>NOTE: The <code>addTextTrack</code> method was not included in the 2009-08-25 version and is not included here.</p>
<p><b>DOM constructors included from this interface:</b> none</p>
<p><b>DOM constants included from this interface:</b> <code>NETWORK_EMPTY</code>, <code>NETWORK_IDLE</code>, <code>NETWORK_LOADING</code>, <code>NETWORK_NO_SOURCE</code>, <code>HAVE_NOTHING</code>, <code>HAVE_METADATA</code>, <code>HAVE_CURRENT_DATA</code>, <code>HAVE_FUTURE_DATA</code>, <code>HAVE_ENOUGH_DATA</code></p>
<p>NOTE: The <code>NETWORK_LOADED</code> constant is not included in the candidate recommendation and hence is not included here. The numeric value assigned for <code>NETWORK_LOADED</code> in the 2009-08-25 version has been re-used for <code>NETWORK_NO_SOURCE</code> in the candidate recommendation &mdash; a conflict that prevents <code>NETWORK_LOADED</code> from being OPTIONAL in this annex.</p>
<p><b>Events included from this interface:</b> <code>loadstart</code>, <code>progress</code>, <code>suspend</code>, <code>abort</code>, <code>error</code>, <code>emptied</code>, <code>loadedmetadata</code>, <code>loadeddata</code>, <code>canplay</code>, <code>canplaythrough</code>, <code>playing</code>, <code>waiting</code>, <code>seeking</code>, <code>seeked</code>, <code>ended</code>, <code>timeupdate</code>, <code>durationchange</code>, <code>ratechange</code>, <code>volumechange</code>, <code>play</code> and <code>pause</code>. </p>
<p>NOTE: The <code>load</code> and <code>loadend</code> events are not included in the candidate recommendation and hence are not included here.</p>
<p>NOTE: The <code>stalled</code> event is not included due to not being widely implemented.</p>
</section>
<section>
<h2>Other object types</h2>
<p>Types included as specified: <code>MediaError</code>, <code>TimeRanges</code></p>
<p>NOTE: The <code>AudioTrack</code>, <code>AudioTrackList</code>, <code>VideoTrack</code>, <code>VideoTrackList</code>, <code>MediaController</code>, <code>TextTrack</code>, <code>TextTrackList</code>, <code>TextTrackCue</code>, <code>TextTrackCueList</code> interfaces were not included in the 2009-08-25 version and are not included here.</p>
</section>
<section>
<h2>Dependencies</h2>
<p>Where methods, attributes, constants and behaviour included from the HTML5 specification refers to other W3C specifications, (e.g. DOM4), that reference is OPTIONAL. Implementations MAY use that reference or any equivalent reference which works and is technically coherent.</p>
</section>
</section>

<!-- Annex J -->
<section class="appendix" id="dlna-rcf-sequences">
<h1>DLNA RUI Remote Control Function Sequences</h1>
<section id="remote-ui-and-box-models">
<h2>Remote UI and box models (informative)</h2>
<p>The architecture overview from section 4.1 of [[!CEA-2014-A]] defines various box models. Next to the i-Box model for accessing IPTV service providers or 3<sup>rd</sup> party internet services, it defines a 2-Box and 3-box model for in-home remote UI. Box Models are divided by not only where the server resides but also where the UI control point reside to perform discovery and setup of a remote UI connection. In case of the 2-Box and 3-box model the UI control point is a UPnP control point that discovers in-home servers.  In case of the 2-box model, there is a UPnP Remote UI control point inside the OITF. If the UPnP remote UI control point resides in an external device (e.g. web pad, remote controller), whereby the external device lists the Remote UI servers and sets up a UI connection between the OITF and Remote UI Server this is called the 3-box model. An OITF that supports the 3-box model must be discoverable through UPnP itself, and expose the profile information of a Remote UI client to the home network.</p>
<p>For the OITF, only the CEA-2014-A i-Box model is mandatory. The 2-box and 3-box models are optional. The default interaction with the Application Gateway (AG), the IMS Gateway (IG) and the CSP gateway (CSPG) deviate in the following manner. However, it is not precluded for an AG, IG, CSPG or other devices in the home network to expose themselves as a regular UPnP Remote UI server that is compliant with CEA-2014, for example to serve a Remote UI of its configuration screen to the OITF.</p><ul>
<li>The AG is similar to a level 1 remote UI server as defined in section 5.1.1.2 of [[!CEA-2014-A]], with the difference that [Req. 5.1.1.2.d] is replaced with a different device description. The device description of the AG is defined in  <a href="volume4.html#s10-1-1-2" class="extRef">section 10.1.1.2</a> of [[!OIPF_PROT2]]. The requirements [Req. 5.1.1.2.b] and [Req. 5.1.1.2.c] are now optional: a URL to the XML UI Listing is provided by element &lt;agUIServerURL&gt; of the AG Description XML document. Note that  the UPnP Device description of the AG MAY offer a CEA-2014-A compatible level 1 or level 2 remote UI server in its UPnP device hierarchy that point to the same XML UI listing.
<li>The IG enables the discovery of IPTV services through the HNI-IGI interface as defined in [[!OIPF_PROT2]]. This is quite different from a level 1 or level 2 remote UI server. The details of the device discovery of the IG are defined in <a href="volume4.html#s10-1-1-1" class="extRef">section 10.1.1.1</a> of [[!OIPF_PROT2]].
</ul>
<p>Irrespective of the box models, and the discovery mechanism used, the OITF performs the following general steps to set up a connection to any internet or in-home service:</p><ol>
<li>Setup &amp; Connect phase:<ol type="a">
<li>The OITF connects to a URL of a DAE application offered by a server over an HTTP connection. The capability profile of an OITF is conveyed to the server, using the &ldquo;User-Agent&rdquo; HTTP header, to enable the server to adjust the contents to the DAE capabilities of the OITF. An OITF that supports additional content formats (e.g. Flash) can also convey these extensions to the server.
<li>After setting up the connection, the XHTML and/or SVG contents that constitute the DAE application are downloaded to the OITF.
<li>This connection can also be set up by a separate UI Control Point in case of an OITF that supports a 3-box model.</ol>
<li>Presenting web content:<ol type="a">
<li>After downloading the XHTML and/or SVG contents, the DAE application may become active and display a user interface as defined by the XHTML and/or SVG contents.</ol>
<li>Controlling the UI: <ol type="a">
<li>Remote control, keyboard and mouse events can be handled within scripts.
<li>Native control for web forms and spatial navigation must be supported.
<li>Client-side scripting control for the playback of A/V content must be supported.</ol>
<li>Dynamic UI Updates: <ol type="a">
<li>User interfaces can be dynamically updated by the server using a persistent TCP connection (NotifSocket) or through XML updates over an HTTP connection (AJAX).</ol>
<li>3<sup>rd</sup> Party Notifications: <ol type="a">
<li>Notification messages linked to UI content can arrive on the OITF outside of an active UI interaction between the OITF and the server.</ol>
</ol>
<section>
<h3>i-Box model</h3>
<p>The i-Box Model supports the remote presentation and control of UIs that reside on a server on the Internet (WAN). The client (OITF) resides within the home domain, and is either non-discoverable and has a built-in &ldquo;Connection setup and control&rdquo; to perform connection management related operations, or is discoverable by an external so called UI Control Point within the home domain that allow the connection management related operations to be controlled by another device. This configuration is depicted in the diagram below. </p>
<figure>
<img alt="FIGURE 20" src="images/i-Box-Model.png" />
<figcaption>Figure ####: i-Box Model</figcaption>
</figure>
</section>
<section>
<h3>2-Box model</h3>
<p>The 2-Box Model describes a configuration in which the server is discoverable in the home network. Since the client is not discoverable, it must have a UI Control Point in order to be functional in the network to be able to discover an AG device description (as defined in <a href="volume4.html#upnp" class="extRef">section 10</a> of [[.OIPF_PROT2]]), or a Remote UI server description as described in section 5.1 of [[!CEA-2014-A]].</p>
<figure>
<img alt="FIGURE 21" src="images/2-Box-Model.png" />
<figcaption>Figure ####: 2-Box Model</figcaption>
</figure>
</section>
<section>
<h3>3-Box model</h3>
<p>When both the Remote UI Server and the Remote UI Client are discoverable, the configuration can be described by the 3-Box UI Model. This configuration has no restriction on the location of the UI Control Point for the discovery and connection management, as illustrated in the diagram below. </p>
<figure>
<img alt="FIGURE 22" src="images/3-Box-Model.png" />
<figcaption>Figure ####: 3-Box Model</figcaption>
</figure>
</section>
</section>


<section>
<h2>DLNA RUI Remote Control Function Sequences</h2>
<p>There are two cases to send the control UI to the Remote Control Device:</p><ul>
<li>First, when the DAE application is created (for example, when loaded in response to a request from the Remote Control Device), the DAE application SHALL try to give a proper control UI to the Remote Control Device (Creating DAE app &rarr; finding the Remote Control Device handle &rarr; giving the control UI). See Annex <a href="#remote-ui-and-box-models" class="sectionRef"></a>.
<p>The DAE application is launched in response to an HTTP request from an OITF control UI being rendered in the Remote Control Device. The DAE application checks the <code>currentRemoteDeviceHandle</code> property when it has completed loading. If this property returns undefined, it means that the current DAE application wasn't launched by a Remote Control Device (but by some other means), whereas if this property returns a value (the Remote Control Device handle), the DAE application knows that it must send its Control UI to the Remote Control Device. </p>
<p>This scenario is made based on <a href="architecture.html#s10-6" class="extRef">section 10.6</a> of [[.OIPF_ARCH2]].</p>
<li>Second, when the DAE application is already running, the DAE application sends a control UI in response to a control UI request (DAE app running &rarr; getting the CUI request event &rarr; giving the control UI). See annex <a href="#obtaining-the-control-ui-from-a-running-dae-application" class="sectionRef"></a>.
<p>The DAE application is currently being executed in the OITF and during this time the Remote Control Device requests the control UI from it. In this case, the OITF generates the <code>ReceiveRemoteMessage</code> event to the DAE application with type set to 0. Then the DAE application retrieves the control UI from the IPTV Applications server and returns it to the Remote Control Device.</p>
</ul>
<p>Annex <a href="#messages-between-rcd-and-dae" class="sectionRef"></a> shows the message flow for sending and receiving messages between control UI in the Remote Control Device and the DAE application.
<p>NOTE: Dotted lines in the diagrams below indicate internal operations.</p>
<section>
<h3>Launching a DAE application to obtain the Control UI</h3>
<figure>
<img src="images/DLNA-RUI-RCF-launching.png" alt="DLNA-RUI-RCF-launching.png"/>
</figure>
<p>The following is a brief description of the steps in the flow:<br />
NOTE: The dotted line is an internal operation.</p><ol>
<li>The user activates a DLNA RUIC function.
<li>The DLNA RUIC discovers the DLNA RUIS in the OITF as defined in section 5.1 of [[!CEA-2014-A]] , and the DLNA RUIC and the DLNA RUIS perform capability profile matching using the mechanism defined in section 5.2 of [[!CEA-2014-A]].
<li>DLNA RUIC requests XML UI Listing to DLNA RUIS, and gets it.
<li>DLNA RUIC renders XML UI Listing in its own screen.
<li>The user chooses the OIPF CUI in the XML UI Listing.
<li>DLNA RUIC requests the OIPF CUI and gets it. (This OIPF CUI could be made based on Open IPTV Forum Metadata information)
<li>DLNA RUIC renders the OIPF CUI.
<li>The user starts OIPF service with the OIPF CUI which came from DLNA RUIS in the OITF.<br />
NOTE: The steps from step 1 to step 8 conform to the normal DLNA RUI sequence.
<li>The OIPF CUI in the DLNA RUIC sends the OIPF service HTTP Request with capability in the User-Agent to DLNA RUIS. The OIPF service HTTP Request is vender specific URI to create DAE application.
<li>DLNA RUIS orders the DAE Browser to execute the requested DAE application. 
<li>DAE Browser requests the DAE application.
<li>IPTV Applications server sends the requested DAE application.
<li>DAE Browser executes the DAE application.
<li>When the DAE application is loaded, the OITF dispatches a <code>ReceiveRemoteMessage</code> event with type <code>CREATE_APP</code> to the <code>application/oipfRemoteControlFunction</code> object in the DAE application.
<li>The DAE application requests the CUI by using XMLHttpRequest object with capability of DLNA RUIC.
<li>The IPTV Applications server sends the CUI.
<li>The DAE application sends the CUI to the <code>application/oipfRemoteControlFunction</code> object by using the <code>sendRemoteMessage()</code> method.
<li>DLNA RUIS sends the content of the CUI CE-HTML document to DLAN RUIC through a HTTP Response body.
<li>DLNA RUIC renders the CUI. DLNA RUIC fetches resources (images/css/js) directly from the IPTV application server.
<li>DLNA RUIC sends a message to the DAE application and receive the response message.
</ol>
</section>
<section id="obtaining-the-control-ui-from-a-running-dae-application">
<h3>Obtaining the control UI from a running DAE application</h3>
<figure><img src="images/ObtainingControlUIFromRunningDAEApplication.png" alt="ObtainingControlUIFromRunningDAEApplication.png"/></figure>
<p>The following is a brief description of the steps in the flow:<br />
NOTE: The dotted line is an internal operation.</p><ol>
<li>DAE application which has the application/oipfRemoteControlFunction object is being executed.
<li>The Server Side XML UI Listing is updated in the DLNA RUIS through the <code>useServerSideXMLUIListing()</code> method.
<li>DLNA RUIS compiles the XML UI listing
<li>The user activates a DLNA RUIC function.
<li>The DLNA RUIC discovers the DLNA RUIS in the OITF as defined in section 5.1 of [[!CEA-2014-A]] , and the DLNA RUIC and the DLNA RUIS perform capability profile matching using the mechanism defined in section 5.2 of [[!CEA-2014-A]].
<li>DLNA RUIC requests XML UI Listing to DLNA RUIS.
<li>DLNA RUIS sends the Server side XML UI Listing to the DLNA RUIC.
<li>DLNA RUIC renders XML UI Listing in its own screen.
<li>When a user chooses one of the CUIs in the XML UI Listing, DLNA RUIC sends the HTTP request message (<code>/rcf/request_cui</code>) with the RUIC capability information in the User-Agent to DLNA RUIS to get the CUI.
<li>The <code>application/oipfRemoteControlFunction</code> object dispatches a <code>ReceiveRemoteMessage</code> event with type <code>REQUEST_CUI</code> to the DAE application.
<li>The DAE application requests the CUI using XMLHttpRequest object, including the capability description received from the RUIC in the request.
<li>The IPTV Applications server sends the CUI.
<li>The DAE application sends the CUI to the <code>application/oipfRemoteControlFunction</code> object by using the <code>sendRemoteMessage()</code> method.
<li>DLNA RUIS sends the content of the CUI CE-HTML to DLAN RUIC (+RUIPL+) by using HTTP Response body
<li>DLNA RUIC renders the CUI. DLNA RUIC fetches resources (images/css/js and any other HTML documents) directly from the IPTV application server.
<li>DLNA RUIC sends a message to the DAE application and receive the response message as described in Annex <a href="#messages-between-rcd-and-dae" class="sectionRef"></a>.
</ol>
</section>
<section id="messages-between-rcd-and-dae">
<h3>Sending and receiving messages between the Remote Control Device and DAE application</h3>
<figure><img src="images/MessagesBetweenDLNARCFandDAEApplication.png" alt="MessagesBetweenDLNARCFandDAEApplication.png"/></figure>
<p>The following is a brief description of the steps in the flow:</p><ol>
<li>DLNA RUIC renders the CUI.
<li>User sends a message to the DAE application. For example, user clicks a button which could send a specific message to the DAE application.
<li>The CUI sends a message to the DLNA RUIS by using a pre-defined URL (<code>/rcf/request_msg</code>).
<li>The <code>application/oipfRemoteControlFunction</code> object dispatches a <code>ReceiveRemoteMessage</code> event with type <code>REQUEST_MSG</code> to the DAE application.
<li>The DAE application handles the message received from the DLNA RUIC.
<li>The DAE application sends a message to the <code>application/oipfRemoteControlFunction</code> object by using a <code>sendRemoteMessage()</code> method.
<li>DLNA RUIS sends a message to DLNA RUIC.
</ol>
</section>
</section>
</section>

<!-- Annex K -->
<section class="appendix" id="collections">
<h1>Collections</h1>
<p>This document defines a number of JavaScript collections, used by APIs to return lists of objects from the OITF to applications (e.g. lists of channels or EPG search results). Many of these collections have identical semantics, and so for the sake of brevity, the following notation is used to define these collections.<p>
<p>Each collection is an instance of the Collection<i>&lt;T&gt;</i> parameterized class (see Annex <a href="#collection-template" class="sectionRef"></a>), and is defined in the following way:</p><pre>
typedef Collection&lt;Foo&gt; FooCollection
typedef Collection&lt;Bar&gt; BarCollection
</pre>
<p>where Foo or Bar is the name of the class that may be stored in the collection. For example:</p><pre>
typedef Collection&lt;String&gt; StringCollection
typedef Collection&lt;Channel&gt; ChannelList
</pre>
<p>Collections defined in this way SHALL follow the semantics defined in Annex <a href="#collection-template" class="sectionRef"></a>, and may be extended with additional properties and methods as necessary.</p>
<p>Collections defined in this way always represent snapshots of the state of the OITF at a given time. They are not updated automatically if the state of the OITF changes. This means that different instances of a specific type of collection may contain different values.</p>

<section id="collection-template">
<h2>The Collection template </h2>
<p>The <code>Collection<i>&lt;T&gt;</i></code> class is a parameterized class whose instances are (possibly zero-length) collections of values of type <i>T</i>. The properties and methods defined below SHALL be present on any instance of a <code>Collection<i>&lt;T&gt;</i></code> class. Instances of a <code>Collection<i>&lt;T&gt;</i></code> class SHALL support the use of array notation to access objects in the collection.</p>
<p>Instances of a <code>Collection<i>&lt;T&gt;</i></code> class SHALL be considered to be immutable, except by APIs defined on the collection. Attempts to insert items into instances of a <code>Collection<i>&lt;T&gt;</i></code> class using array notation SHALL fail.</p>

<section id="collection-template-properties">
<h3>Properties</h3>
<table class="dae-property-table">
<tr><td class="api-signature">readonly Integer <b>length</b></td></tr>
<tr><td>The number of items in the collection</td></tr>
</table>
</section>
<section id="collection-template-methods">
<h3>Methods</h3>
<table class="dae-method-table">
<tr><td colspan="3" class="api-signature"><i>&lt;T&gt;</i> <b>item</b>( Integer index )</td></tr>
<tr>
<td class="dae-method-table-label">Description</td>
<td colspan="2">Return the item at position index in the collection, or undefined if no item is present at that position.</td>
</tr>
<tr>
<td class="dae-method-table-label">Arguments</td>
<td class="dae-method-table-argument">index</td>
<td>The index of the item that SHALL be returned</td>
</tr>
</table>
</section>
</section>

</section>


<!-- Annex L -->
<section class="appendix">
<h1>SVG Video Tag Support</h1>
<p>This section provides a comparison between SVG  &lt;video&gt; and the visual objects defined in this specification. When not supported by SVG it is indicated with NS (Not Supported). When not in the scope of SVG it is indicated with NA (Not Applicable). If there are differences in values or behaviour additional information is provided under the Comments column.</p>
<table class="simple">
<thead>
<tr><th></th><th>A/V Control object</th><th>Broadcast object</th><th>SVG IDL attributes</th><th>Comments</th></tr>
</thead>
<tbody>
<tr><td rowspan="8">General</td>
<td>Number width</td>
<td>Integer width</td>
<td>Video element: width attribute</td>
<td></td>
</tr>
<tr>
<td>Number height</td>
<td>Integer height</td>
<td>Video element: height attribute</td>
<td></td>
</tr>
<tr>
<td>readonly Boolean fullScreen</td>
<td>readonly Boolean fullScreen</td>
<td>Video element: viewbox attribute</td>
<td></td>
</tr>
<tr>
<td>setFullScreen( Boolean fullscreen)</td>
<td>void setFullScreen( Boolean fullscreen )</td>
<td>Video element: viewbox attribute</td>
<td></td>
</tr>
<tr>
<td>focus()</td>
<td></td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>Object onfocus</td>
<td>function onfocus</td>
<td>DOM2 Event Model: DOMFocusIn</td>
<td></td>
</tr>
<tr>
<td>Object onblur</td>
<td>function onblur</td>
<td>DOM2 Event Model: DOMFocusOut</td>
<td></td>
</tr>
<tr>
<td>Object onFullScreenChange</td>
<td>function onFullScreenChange</td>
<td>NS</td>
<td></td>
</tr>

<tr><td rowspan="2">Volume</td>
<td>Boolean setVolume( Number volume )</td>
<td>Boolean setVolume( Integer volume )</td>
<td>Audio element: audio-level attribute</td>
<td>The range specified in SVG is 0 to 1.0 with 0 silencing the audio.</td>
</tr>
<tr>
<td></td>
<td>Integer getVolume()</td>
<td></td>
<td></td>
</tr>

<tr><td rowspan="4">Components (e.g. subtitles, languages)</td>
<td>AVComponentCollection getComponents( Integer componentType )</td>
<td>AVComponentCollection getComponents( Integer componentType )</td>
<td>audioLanguage = 'auto' |  &lt;list-of-language-ids&gt;<br />
subtitleLanguage = 'auto' |  &lt;list-of-language-ids&gt;<br />
audioType = 'auto' | 'normal' | 'descriptive'<br />
subtitleType = 'auto' | 'normal' | 'hearingImpaired' | 'none'<br />
teletextType = 'auto' | 'normal' | 'none'<br /></td>
<td></td>
</tr>
<tr>
<td>AVComponentCollection getCurrentActiveComponents( Integer componentType )</td>
<td>AVComponentCollection getCurrentActiveComponents( Integer componentType )</td>
<td></td>
<td></td>
</tr>
<tr>
<td>void selectComponent( AVComponent component )</td>
<td>void selectComponent( AVComponent component )</td>
<td></td>
<td></td>
</tr>
<tr>
<td>void unselectComponent( AVComponent component )</td>
<td>void unselectComponent( AVComponent component )</td>
<td></td>
<td></td>
</tr>

<tr><td colspan="5"></td></tr>

<tr><td rowspan="10">Broadcast specific</td>
<td></td>
<td>function onChannelChangeError( Channel channel, Number errorState )</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Integer playState</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>function onPlayStateChange( Number state, Number error )</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Channel bindToCurrentChannel()</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>void setChannel( Channel channel, Boolean trickplay, String contentAccessDescriptorURL )</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>void prevChannel()</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>void nextChannel()</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>void release()</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>void setChannel( Channel channel, Boolean trickplay, String contentAccessDescriptorURL, Integer offset )</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>readonly Channel currentChannel</td>
<td>NA</td>
<td></td>
</tr>

<tr><td colspan="5"></td></tr>

<tr><td rowspan="20">Playback control</td>
<td>String data</td>
<td></td>
<td>Video element: xlink:href attribute</td>
<td></td>
</tr>
<tr>
<td>readonly Number playPosition</td>
<td>readonly Integer playPosition</td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>readonly Number playTime</td>
<td></td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>readonly Number playState</td>
<td></td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>readonly Number error</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>readonly Number speed</td>
<td>readonly Number playSpeed</td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>Boolean play( Number speed )</td>
<td>Boolean resume()<br />
Boolean pause()</td>
<td>Media element: pause/resume attributes<br />
SMIL: speed attribute</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Boolean setSpeed( Number speed )</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td>Boolean stop ()</td>
<td>void stopRecording()</td>
<td>Media element: end attribute<br />
stopRecording is NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Boolean stopTimeshift()</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td>Boolean seek( Number pos)</td>
<td>Boolean seek( Integer offset, Integer reference )</td>
<td>Media element: begin attribute</td>
<td></td>
</tr>
<tr>
<td>Boolean next ()</td>
<td></td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>Boolean previous ()</td>
<td></td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>function onPlaySpeedChanged( Number speed )</td>
<td>function onPlaySpeedChanged( Number speed )</td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>onPlayPositionChanged( Integer position )</td>
<td>function onPlayPositionChanged( Integer position )</td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>readonly Number playSpeeds[ ]</td>
<td>readonly Number playSpeeds[ ]</td>
<td>NS</td>
<td></td>
</tr>
<tr>
<td>readonly String oitfSourceIPAddress</td>
<td></td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td>readonly String oitfSourcePortAddress</td>
<td></td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td>Boolean oitfNoRTSPSessionControl</td>
<td></td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td>String oitfRTSPSessionId</td>
<td></td>
<td>NA</td>
<td></td>
</tr>

<tr><td colspan="5"></td></tr>

<tr><td rowspan="8">Recording specific</td>
<td></td>
<td>String recordNow( Integer duration )</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>readonly Integer playbackOffset</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>readonly Integer maxOffset</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>readonly Integer recordingState</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>function onRecordingEvent</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>readonly Integer state</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>readonly Integer error</td>
<td>NA</td>
<td></td>
</tr>
<tr>
<td></td>
<td>readonly String recordingId</td>
<td>NA</td>
<td></td>
</tr>
</tbody>

</table>
</section>

<!-- Annex M -->
<section class="appendix">
<h1>Multimedia Telephony sequences (Informative)</h1>
This section contains some examples of typical Multimedia Telephony sequences that involve a DAE Application and the Multimedia Telephony API. All the sequences expect that the user is successfully registered to the network as a pre-condition.
<section>
<h2>Full-duplex voice telephony call flow</h2>
<p>After a registration procedure, performed through the registerUser method of the application/oipfCommunicationServices object, a peer can generate an outgoing call or receive an incoming call:</p><ul>
<li>Incoming Call: An incoming call is notified to the application through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with appropriate parameters. The application can answer to an incoming call invoking the answer method with the appropriate parameters identifying the specific action to be executed: accept, refuse, etc.
<li>Outgoing Call: An outgoing call can be initiated by a peer invoking the <a href="#oipfcommunicationservices-call" class="apiRef">call</a> method with the URI of the remote peer. The originating peer is notified about the state of the call by the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> raised during the progress (e.g.: ringing state) and the call result phases.
</ul>
<p>When a call session becomes active (i.e.: the media data are available) the function <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> will be invoked with appropriate parameters. An active call can be closed by one of the peers at any time invoking the <a href="#oipfcommunicationservices-hangup" class="apiRef">hangUp</a> method. The other peer will receive a notification of this operation through the function <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> with an hang-up specific parameter. When the call session is closed the function <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> will be invoked again with a session end specific parameter.</p>
<figure>
<img src="images/FullDuplexVoiceTeleohonyCallFlow.png" alt="FullDuplexVoiceTeleohonyCallFlow.png"/>
</figure>
<p>The following is a brief description of the steps in the flow:<br />
NOTE: This is just an example of a possible call flow.</p><ol>
<li>A peer starts a call invoking the <a href="#oipfcommunicationservices-call" class="apiRef">call</a> method with the URI of the remote peer.
<li>The remote peer is notified about an incoming call through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> with event type <code>EVENT_INCOMING_CALL</code>.
<li>The peer is notified about the progress of his call request through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_CALL_PROGRESS</code>.
<li>The remote peer accepts the incoming call request invoking the <a href="#oipfcommunicationservices-answer" class="apiRef">answer</a> method with <code>ANSWER_ACCEPT</code> response parameter.
<li>The peer is notified about the result of his call request through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_CALL_RESULT</code> and status equal to <code>ACCEPT</code>.
<li>The peer is notified about the availability of the session and of the related media streams through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_START</code>.
<li>The remote peer is notified about the availability of the session and of the related media streams through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_START</code>.
<li>The peer closes the communication invoking the <a href="#oipfcommunicationservices-hangup" class="apiRef">hangUp</a> method.
<li>The remote peer is notified through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_HANGUP</code>. 
<li>The peer receives a notification when the session is completely closed through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_END</code>.
<li>The remote peer receives a notification when the session is completely closed through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_END</code>.
</ol>

</section>
<section>
<h2>Full-duplex Video telephony call flow</h2>
<p>A Video telephony call flow is basically derived from a Voice telephony call flow with few additions:<ul>
<li>The application/oipfCommunicationServices object, through the showLocalVideoPreview method, can activate and deactivate the rendering of the local video captured by the selected video capture device to provide a preview to the user. This method can be invoked before or after a call setup. The video stream is graphically displayed by an A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> or an HTML5 video element. 
<li>When a call setup is successfully completed and a remote video stream is available, the application can invoke the showRemoteVideo method, which renders the media and display it through an A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> or an HTML5 video element.
</ul>
<figure>
<img src="images/FullDuplexVideoTeleohonyCallFlow.png" alt="FullDuplexVideoTeleohonyCallFlow.png"/>
</figure>
<p>The following is a brief description of the steps in the flow:<br />
NOTE: This is just an example of a possible call flow.</p><ol>
<li>A peer activates a local video preview invoking the <a href="#oipfcommunicationservices-showlocalvideopreview" class="apiRef">showLocalVideoPreview</a> method and passing the HTML ID of the A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> or HTML5 video element that will display the stream.
<li>A peer starts a call invoking the <a href="#oipfcommunicationservices-call" class="apiRef">call</a> method with the URI of the remote peer.
<li>The remote peer is notified about an incoming call through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> with event type <code>EVENT_INCOMING_CALL</code>.
<li>The peer is notified about the progress of his call request through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_CALL_PROGRESS</code>.
<li>The remote peer accepts the incoming call request invoking the <code>answer</code> method with <code>ANSWER_ACCEPT</code> response parameter.
<li>The peer is notified about the result of his call request through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_CALL_RESULT</code> and status equal to <code>ACCEPT</code>.
<li>The remote peer activates a local video preview invoking the <a href="#oipfcommunicationservices-showlocalvideopreview" class="apiRef">showLocalVideoPreview</a> and passing the HTML ID of the A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> or HTML5 video element that will display the stream.
<li>The peer is notified about the availability of the session and of the related media streams through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_START</code>.
<li>The remote peer is notified about the availability of the session and of the related media streams through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_START</code>.
<li>The peer activates the remote video invoking the <a href="#oipfcommunicationservices-showremotevideo" class="apiRef">showRemoteVideo</a> and passing the HTML ID of the A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> or HTML5 video element that will display the stream.
<li>The remote peer activates the remote video invoking the <a href="#oipfcommunicationservices-showremotevideo" class="apiRef">showRemoteVideo</a> and passing the HTML ID of the A/V Control object as defined in section <a href="#media-playback-apis" class="sectionRef"></a> or HTML5 video element that will display the stream.
<li>The peer closes the communication invoking the <a href="#oipfcommunicationservices-hangup" class="apiRef">hangUp</a> method.
<li>The remote peer is notified through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_HANGUP</code>. 
<li>The peer receives a notification when the session is completely closed through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_END</code>.
<li>The remote peer receives a notification when the session is completely closed through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_END</code>.
</ol>
</section>
<section>
<h2>Capture device and call parameters setting flow</h2>
<p>The Multimedia Telephony API provides methods for enumerating the capture devices installed or connected to the OITF, for selecting the devices that will be used during the call and to retrieve and set transmission parameter for the call. The methods provide also support for muting or unmuting outgoing video or audio streams.</p>
<figure>
<img src="images/CaptureDeviceAndCallParamterSettingsFlow.png" alt="CaptureDeviceAndCallParamterSettingsFlow.png" />
</figure>
<p>The following is a brief description of the relevant steps in the flow:<br />
NOTE: This is just an example of a possible call flow.  The descriptions of steps already described in previous sections are omitted.</p><ol>
<li>The application retrieves the list of capture devices for audio or video through the <a href="#oipfcommunicationservices-getdevicelist" class="apiRef">getDeviceList</a> method.
<li>The application sets the capture device to be used during the call for audio or video through the <code>setCaptureDevice</code> method.
<li>The application sets the video size for the outgoing video stream through the <a href="#oipfcommunicationservices-setcallparameter" class="apiRef">setCallParameter</a> method with the <code>VIDEO_SIZE</code> parameter.
<li>The application sets the video framerate for the outgoing video stream through the <a href="#oipfcommunicationservices-setcallparameter" class="apiRef">setCallParameter</a> method with the <code>VIDEO_FPS</code> parameter.
<p>The description of the other steps is provided in the previous section.</p>
<li value="15">During the call the application can mute the outgoing video stream by invoking the <a href="#oipfcommunicationservices-setcallparameter" class="apiRef">setCallParameter</a> method with the <code>VIDEO_PAUSE</code> parameter.
</ol>
</section>
<section>
<h2>Full-duplex Voice to Video telephony session update flow</h2>
<p>The Multimedia Telephony API provides also support for updating a call adding or removing audio or video streams from an ongoing session. </p>
<p>During a call one of the peers can decide to request the addition for example of video to the current audio-only session through the <a href="#oipfcommunicationservices-callupdate" class="apiRef">callUpdate</a> method. The other peer will receive a notification of this request through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> event with a request specific parameter. The peer can then answer to this request invoking the  <a href="#oipfcommunicationservices-callanswerupdate" class="apiRef">callAnswerUpdate</a> method. The peer that originated the update request will be notified of the response through a <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> event with a response specific parameter. When the updated call session becomes active (i.e. the media data are available) the function <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> will be invoked with a session update specific parameter.</p>
<figure>
<img src="images/FullDuplexVoiceToVideoTelephonySessionUpdateFlow.png" alt="FullDuplexVoiceToVideoTelephonySessionUpdateFlow.png"/>
</figure>
<p>The following is a brief description of the steps in the flow:<br>
NOTE: This is just an example of a possible call flow. The descriptions of steps already described in previous sections are omitted.</p><ol>
<li value="3">The peer requests an update of the current call session through the <a href="#oipfcommunicationservices-callupdate" class="apiRef">callUpdate</a> method with the <code>callType</code> parameter equal to <code>AUDIO_VIDEO</code>.
<li>The remote peer is notified through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_INCOMING_UPDATE</code>. 
<li>The remote peer accepts the incoming update request invoking the <a href="#oipfcommunicationservices-callanswerupdate" class="apiRef">callAnswerUpdate</a> method with <code>UPDATE_ACCEPT</code> response parameter.
<li>The peer is notified about the result of his call request through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_UPDATE</code> and status equal to <code>ACCEPT</code>.
<li>The peer is notified about the availability of the updated session and of the related media streams through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_UPDATE</code>.
<li>The remote peer is notified about the availability of the updated session and of the related media streams through the <a href="#oipfcommunicationservices-oncallevent" class="apiRef">onCallEvent</a> function with event type <code>EVENT_SESSION_UPDATE</code>.
</ol>
</section>
</section>

<!-- Annex N -->
<section id='server-root-certificates' class="appendix">
<h1>Server root certificate selection policy (Informative)</h1>
<section>
<h2>Introduction</h2>
<p>This informative annex describes the policy that is adopted for the selection of root certificates for inclusion in terminals compliant with this specification. A list of such certificates is published at <a href="http://www.oipf.tv/root-certificates">http://www.oipf.tv/root-certificates</a>.</p>
</section>
<section>
<h2>Background</h2>
<p>There are over 150 root certificates in web browsers at the time of publication.</p><ul>
<li>This list changes frequently over time.
<li>The larger the list of root certificates the more likely it is to change.
</ul>
<p>The security of TLS against man-in-the-middle attacks is dependent on the weakest root certificate trusted by a terminal.</p>
<p>The security of various key lengths changes with time as computing power increases. Specifically 1024 bit RSA keys are no longer recommended for use.</p>
<p>Service providers need to know which root certificates are trusted by terminals to achieve interoperability. Service providers are often not in control of the servers delivering their content (e.g. delivery via a CDN).</p>
<p>Service providers may also wish to make use of third party web services that are not under their control. </p>
<p>Maintaining an independent list of root certificates that are validated requires significant resources.</p>
</section>
<section>
<h2>Policy</h2>
<ul>
<li>The Mozilla list of approved root certificates has been selected as the authoritative source for the mandatory and optional list of root certificates for inclusion in terminals compliant with this specification. This was chosen because:<ol>
<li>The approved root certificate list is publicly available.
<li>The process for inclusion in the list is open.
<li>Anyone can take part in the acceptance process.
<li>The acceptance process itself happens in public.
<li>Metadata is provided to differentiate root certificates for web server authentication, e-mail and code signing,
<li>The procedure for requesting a root certificate for inclusion in the list requires a test website be provided which uses that certificate.</ol>
<li>The Mozilla list of approved root certificates is published on their website  at <a href="http://www.mozilla.org/projects/security/certs/">http://www.mozilla.org/projects/security/certs/</a>. Each certificate marked as approved for web server authentication is automatically an optional root certificate as specified in section <a href="#root-certificates" class="sectionRef"></a>.
<li>This specification will rely upon the Mozilla list for verifying the trustworthiness of Certificate Authorities.
<li>A list of root certificates that are mandatory will be maintained which will be a subset of the certificates specified above.<ol>
<li>The list will be updated periodically.
<li>The list will only include certificates that use algorithms mandated by section <a href="#cipher-suites" class="sectionRef"></a>.
<li>The mandatory list of certificates will be determined based on the requirements of service providers and the Certificate Authorities that are in widespread use.
<li>The list will be compiled relying upon published statistics to determine how widespread a Certificate Authority is.
<li>Certificate Authorities may be excluded from the mandatory list if they impose requirements that are deemed unreasonable.
<li>A revision history of changes to the mandatory list will be maintained and published.</ol>
</ul>
<p>This policy is subject to change.</p>
</section>
</section>

<!-- Annex O -->
<section id='changes-to-cea2014a-5-6-2' class="appendix">
<h1>Changes to section 5.6.2 of CEA-2014-A</h1>
<ul>
<li>Support for this section SHALL be optional for an OITF. Support for section 5.6.2 SHALL be indicated through the OITF's capability description by using element <code>&lt;pollingNotifications&gt;</code> as defined in section <a href="#third-party-notification-support" class="sectionRef"></a>.
<li>Extend requirement 5.6.2.a as follows<br /><b><i>[Req. 5.6.2.a]</i></b> An i-Box Remote UI Client SHALL support polling-based 3<sup>rd</sup>-party notifications from an i-Box server. 

<ol>
<!-- 1 -->
<li>To manage the polling process for a particular notification, an i-Box Remote UI Client SHALL support the following method of the Window/UIContentFrame object:
<p style="padding-left:1cm">Boolean <b>subscribeToNotifications</b>(String url, String name, Number period, String type) </p>
<p>where</p><ul>
<li><b>url</b> is the complete URL of the HTTP GET request made by the Remote UI Client every <i>period</i> seconds; the domain of <i>url</i> SHALL equal the domain of the current document in the CE-HTML browser window, and use SSL or TLS security[24][9][10]; if it doesn't, this method has no effect and returns <i>false</i>. If <i>url</i> equals the URL of any existing notification subscription and the value of <i>period</i> is positive, the <i>name</i> and <i>period</i> of that notification subscription is updated.
<li><b>name</b> is the user friendly name of the notification service.
<li><b>period</b> is the polling period of this subscription in seconds. If the value of <i>period</i> equals 0, any existing notification subscription with exactly the same URL is cancelled, and the return value indicates the former existence of such a subscription. If the value of <i>period</i> is negative, no changes are made and the return value indicates whether a subscription to the given URL already exists. If the value of <i>period</i> is positive, <i>true</i> is returned only if the Remote UI Client subscribes, or updates an existing subscription.
<li><b>type</b> is the highest priority event type that will be sent by the notification service, and SHALL be one of the event types listed in bullet 10 of [Req 5.6.1.a], without the &ldquo;upnp:&rdquo;-prefix.
</ul>

<p>On executing the subscribeToNotifications method to subscribe to a new notification, the Remote UI Client SHALL alert the user to the impending new notification subscription (including information about the highest priority notification type that will be sent by the Remote UI Server), and provide the user with at least two options:</p><ul>
<li>subscribe to this notification, and 
<li>do not subscribe to this notification. 
</ul>
<p>This does not exclude an option that allows a user to always accept notifications from the same URL. </p>
<p>If the Remote UI Client does not subscribe because the user declined, the <b>subscribeToNotifications</b> method SHALL return <i>false</i>.</p>

<!-- 2 -->
<li><u>To manage the polling process for a particular notification, an i-Box Remote UI Client SHALL support the following method of the Window/UIContentFrame object:</u>
<p style="padding-left:1cm" id="subscribetonotificationsasync"><u>Number <b>subscribeToNotificationsAsync</b>(String url, String name, Number period, String type) </u></p>
<p><u>where</u></p><ul>
<li><u><b><i>url</i></b> is the complete URL of the HTTP GET request made by the Remote UI Client every <i>period</i> seconds. <i>url</i> SHALL have the same origin as the current document in the CE-HTML browser window, and use SSL or TLS security [24][9][10]; if it doesn't, this method has no effect and an event indicating a negative response is dispatched. If <i>url</i> equals the URL of any existing notification subscription and the value of <i>period</i> is positive, the <i>name</i> and <i>period</i> of that notification subscription is updated.</u>
<li><u><b><i>name</i></b> is the user friendly name of the notification service.</u>
<li><u><b><i>period</i></b> is the polling period of this subscription in seconds. The value of period SHALL be greater than zero.</u>
<li><u><b><i>type</i></b> is the highest priority event type that will be sent by the notification service, and SHALL be one of the event types listed in bullet 9 of [Req 5.6.1.a], without the &ldquo;upnp:&rdquo;-prefix.</u>
<li><u>The return value of his method indicated the ID of the subscription request. This is used when notifying the application of the result of this call, to link a response to the request that generated it.</u>
</ul>
<p><u>On executing the <b>subscribeToNotificationsAsync</b> method to subscribe to a new notification, the Remote UI Client SHALL asynchronously alert the user to the impending new notification subscription (including information about the highest priority notification type that will be sent by the Remote UI Server), and provide the user with at least two options:</u></p><ul> 
<li><u>subscribe to this notification, and </u>
<li><u>do not subscribe to this notification. </u>
</ul>
<p><u>This does not exclude an option that allows a user to always accept notifications from the same URL. </u></p>
<p><u>Calls to <b>subscribeToNotificationsAsync</b> return immediately.  The application will be notified via the <b>onNotificationSubscriptionResponse</b> function (or corresponding DOM-2 event) user has chosen to subscribe or to not subscribe to the notification.</u></p>
<p><u>If two calls to <b>subscribeToNotificationsAsync</b> with the same value for <i>url</i> overlap (i.e. the notification event of the first call has not yet been dispatched), the Remote UI Client SHALL interrupt the first call and generate a response event as if the request had been declined. </u></p>

<!-- 3 -->
<li><u>An i-Box Remote UI Client SHALL support the following property of the Window/UIContentFrame object:</u>
<p style="padding-left:1cm"><u>script  <b>onNotificationSubscriptionResponse</b></u></p>
<p><u>where the specified function is called with arguments id and response, which are defined as follows:</u></p><ul>
<li>Number <b>id</b> &mdash; the ID of the subscription request, as indicated by the return value of the <b>subscribeToNotificationsAsync</b> method.
<li>Boolean <b>response</b> &mdash; the response indicating whether the subscription request has been accepted.  A value of <i>false</i> indicates that the request has been declined.  A value of <i>true</i> indicates that the request has been accepted.
</ul>

<!-- 4 -->
<li><u>An i-Box Remote UI Client SHALL support the following method of the Window/UIContentFrame object: </u>
<p style="padding-left:1cm"><u>void <b>unsubscribe</b>(string url, string name)</u></p> 
<p><u>where</u></p><ul>
<li><u><b><i>url</i></b> is the URL used to subscribe to a notification, which SHALL have the same origin as the current document in the CE-HTML browser window</u>
<li><u><b><i>name</i></b> is the user friendly name of the notification service.</u>
</ul>
<p><u>On executing the unsubscribe method, the Remote UI Client SHALL unsubscribe from the specified notification service.  If the application is not subscribed to the specified notification service or if the page currently loaded in the CE-HTML browser window is not from the same origin as url, this method SHALL have no effect. When this method returns, the application shall no longer be subscribed to the notification service.</u><p>


<!-- 5 -->
<li><u>An i-Box Remote UI Client SHALL support the following method of the Window/UIContentFrame object:</u>
<p style="padding-left:1cm"><u>StringCollection <b>listNotificationSubscriptions</b>()</u></p>
<p><u>where the return value of this method SHALL be a collection of URLs of notification services to which HTML documents from the same origin are currently subscribed.</u></p>



<!-- 6 -->
<li><u>An i-Box Remote UI Client SHALL support the following method of the Window/UIContentFrame object:</u>
<p style="padding-left:1cm"><u>Boolean <b>isSubscribed</b>(string url, string name)</u></p> 
<p><u>where</u></p><ul>
<li><u><b><i>url</i></b> is the URL used to subscribe to a notification, which SHALL have the same origin as the current document in the CE-HTML browser window</u>
<li><u><b><i>name</i></b> is the user friendly name of the notification service.</u>
<li><u>The return value of this method SHALL be <i>true</i> if <i>url</i> has the same origin as the current application and application is currently subscribed to the specified notification service, or <i>false</i> otherwise.</u>
</ul>


</ol>
</ul>

</section>

</body>
</html>